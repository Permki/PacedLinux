/*
 * Copyright (C) 2013, Netronome Systems, Inc.  All rights reserved.
 *
 * Disclaimer: this file is provided without any warranty
 * as part of an early-access program, and the content is
 * bound to change before the final release.
 */

#ifndef NFP3800_PCIE_H
#define NFP3800_PCIE_H

/*================================================================*/
/* TGT 9                                                          */

/*----------------------------------------------------------------*/
/* CPP Address Map (CPP_BASE = IMB translation: island + indexes) */

/* CPP_BASE + NFP3800_PCIE_SRAM */
#define NFP3800_PCIE_SRAM                                         (0x000000)
/* CPP_BASE + NFP3800_PCIE_IM + (nfp_im.h) */
#define NFP3800_PCIE_IM                                           (0x010000)
/* CPP_BASE + NFP3800_PCIE_EM + (nfp_em.h) */
#define NFP3800_PCIE_EM                                           (0x020000)
/* CPP_BASE + NFP3800_PCIE_BAR + NFP3800_PCIE_BAR_* */
#define NFP3800_PCIE_BAR                                          (0x030000)
/* CPP_BASE + NFP3800_PCIE_DMA + NFP3800_PCIE_DMA_* */
#define NFP3800_PCIE_DMA                                          (0x0800000)
/* CPP_BASE + NFP3800_PCIE_DMADESC + NFP3800_PCIE_DMADESC_* */
#define NFP3800_PCIE_DMADESC                                      (0x050000)
/* CPP_BASE + NFP3800_PCIE_DMAMSIX + NFP3800_PCIE_DMADESC_* */
#define NFP3800_PCIE_DMAMSIX                                      (0x060000)
/* CPP_BASE + NFP3800_PCIE_QCTLR[256] + (nfp_qctlr.h) */
#define NFP3800_PCIE_Q(_x)                                        (0x0400000 + ((_x) & 0xff) * 0x800)

/*----------------------------------------------------------------*/
/* XPB Address Map (XPB_BASE = NFP3800_XPB_ISLAND(island))          */

#define PCIEX_BASE                                            (0xa0000)

/* XPB_BASE + NFP3800_PCIEX_COMPCFG + NFP3800_PCIEX_COMPCFG_* */
#define NFP3800_PCIEX_COMPCFG                                     (PCIEX_BASE + 0x000000)
/* XPB_BASE + NFP3800_PCIEX_Q_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_Q_ECC                                       (PCIEX_BASE + 0x010000)
/* XPB_BASE + NFP3800_PCIEX_SRAM_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_SRAM_ECC                                    (PCIEX_BASE + 0x020000)
/* XPB_BASE + NFP3800_PCIEX_IM + (nfp_im.h) */
#define NFP3800_PCIEX_IM                                          (PCIEX_BASE + 0x030000)
/* XPB_BASE + NFP3800_PCIEX_WQ_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_WQ_ECC                                      (PCIEX_BASE + 0x040000)
/* XPB_BASE + NFP3800_PCIEX_TODMADESC_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_TODMADESC_ECC                               (PCIEX_BASE + 0x050000)
/* XPB_BASE + NFP3800_PCIEX_FROMDMADESC_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_FROMDMADESC_ECC                             (PCIEX_BASE + 0x060000)
/* XPB_BASE + NFP3800_PCIEX_BD_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_BD_ECC                                      (PCIEX_BASE + 0x070000)
/* XPB_BASE + NFP3800_PCIEX_CFGLUT_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_CFGLUT_ECC                                  (PCIEX_BASE + 0x080000)
/* XPB_BASE + NFP3800_PCIEX_CTRLHALM_ECC + (nfp_ecc.h) */
#define NFP3800_PCIEX_CTRLHALM_ECC                                (PCIEX_BASE + 0x100000)
/* XPB_BASE + NFP3800_MEGUSTORE_BASE */
#define NFP3800_PCIEX_MEGUSTORE_BASE                              (PCIEX_BASE + 0x200000)
/* XPB_BASE + NFP3800_PCIEX_CTRLXPB */
#define NFP3800_PCIEX_CTRLXPB                                     (PCIEX_BASE + 0x300000)

/* XPB_BASE + NFP3800_PCIEX_PF_* */
#define NFP3800_PCIEX_PF_(x)         (NFP3800_PCIEX_CTRLXPB + 0x200000 + 0x1000 * ((x) & 0x7))
/* XPB_BASE + NFP3800_PCIEX_VF + NFP3800_PCIEX_VF_* */
#define NFP3800_PCIEX_VF_G12(_x)          (NFP3800_PCIEX_CTRLXPB + 0x230000 + (0x1000 * ((_x) & 0x3f)))
#define NFP3800_PCIEX_VF_G16_0(_x)        (NFP3800_PCIEX_CTRLXPB + 0x240000 + (0x1000 * ((_x) & 0x3f)))
#define NFP3800_PCIEX_VF_G16_1(_x)        (NFP3800_PCIEX_CTRLXPB + 0x250000 + (0x1000 * ((_x) & 0x3f)))
#define NFP3800_PCIEX_VF_G16_2(_x)        (NFP3800_PCIEX_CTRLXPB + 0x260000 + (0x1000 * ((_x) & 0x3f)))
#define NFP3800_PCIEX_VF_G4(_x)           (NFP3800_PCIEX_CTRLXPB + 0x270000 + (0x1000 * ((_x) & 0x3f)))

#define NFP3800_PCIEX_CTRLCFG     (PCIEX_BASE + 0x300000)
#define NFP3800_PCIEX_LM          (NFP3800_PCIEX_CTRLXPB +  0x220000)

/* MEG USTORE MAP */
#define NFP3800_PCIEX_MEG0USTORE_ECC                              (NFP3800_PCIEX_MEGUSTORE_BASE + 0x00000)
#define NFP3800_PCIEX_MEG1USTORE_ECC                              (NFP3800_PCIEX_MEGUSTORE_BASE + 0x10000)

/*----------------------------------------------------------------*/
/* CPP SRAM Address Map                                           */
/*  1st 1/2 of Shared SRAM in PCIe is not usable by SW as it's    */
/*  used by the DMA engine and target logic, specifically DMA/    */
/*  RxVendMsg/PcieTarget Write buffers used by HW exclusively.    */
/*----------------------------------------------------------------*/

#define NFP3800_PCIE_SRAM_DMAFROMPCIE_TOKEN                       (0x0000)
#define NFP3800_PCIE_SRAM_RXVENDOR_MSGBUF                         (0x4000)
#define NFP3800_PCIE_SRAM_DMAFROMPCIE_BUF                         (0x5000)
#define NFP3800_PCIE_SRAM_RESERVED                                (0x5800)
#define NFP3800_PCIE_SRAM_PCIE_TGT_WR                             (0x6000)
#define NFP3800_PCIE_SRAM_DMATOPCIE_TOKEN                         (0x8000)
#define NFP3800_PCIE_SRAM_MSIX(_x)                                (0xC000 + (0x400 * ((_x) & 0x2)))
#define NFP3800_PCIE_SRAM_EXPLICIT(_x)                            (0xD000 + (0x80 * ((_x) & 0x1f)))
#define NFP3800_PCIE_SRAM_PCIE_TGT_RD                             (0xE000)

/*================================================================*/


/* HGID: c3e5162fe280 */

#ifndef NFP3800_LONGNAMES

/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeToCppExpansionBAR_[3]_[8] - PCIe to CPP Translation Expansion BARs for a Physical Function BAR X
    Bits: 31:29 MapType(rw) - Map Type
    Bits: 28:27 LengthSelect(rw) - Used to select the weighting of the CPP length field.
    Bits: 26:23 Target_BaseAddress(rw) - MapType 0, 1 and 2 this field specifies TargetID, otherwise upper portion of Base Address.
    Bits: 22:21 Token_BaseAddress(rw) - MapType 0 and 1 this field specifies CPP Token, otherwise upper portion of Base Address.
    Bits: 20:16 Action_BaseAddress(rw) - MapType 0 this field specifies Action, otherwise upper portion of Base Address.
    Bits: 15:0  BaseAddress(rw) - Base address. Each mapping uses a varying number of bits, always starting at the most significant bit. Remaining least significant bits are ignored.
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PF_P2C(_x, _y, _z) (0x00000000 + (0xc0 * ((_x) & 0x7)) + (0x20 * ((_y) & 0x3)) + (0x4 * ((_z) & 0x7)))
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_of(_x) (((_x) >> 29) & 0x7)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_FIXED (0)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_BULK (1)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_TARGET (2)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_GENERAL (3)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_EXPLICIT0 (4)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_ROCE (5)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_MAP_TYPE_TRAP (6)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_LEN(_x) (((_x) & 0x3) << 27)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_LEN_of(_x) (((_x) >> 27) & 0x3)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_LEN_32BIT (0)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_LEN_64BIT (1)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_LEN_0BYTE (3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_TARGET(_x) (((_x) & 0xf) << 23)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_TARGET_of(_x) (((_x) >> 23) & 0xf)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_TOKEN(_x) (((_x) & 0x3) << 21)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_TOKEN_of(_x) (((_x) >> 21) & 0x3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_ACTADDR(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_ACTADDR_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_BASE(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PF_P2C_BASE_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeToCppExpansionBARVf_[3]_[2] - PCIe to CPP Translation for Virtual Function BAR X
    Bits: 31:30 LengthSelect(rw) - Used to select the weighting of the CPP length field.
    Bits: 29:26 Target(rw) - Specifies Target ID.
    Bits: 25:24 Token(rw) - Specifies CPP Token.
    Bits: 23:22 MapType(rw) - Map Type selects memory mapped or internal peripheral target mapping
    Bits: 21:0  BaseAddress(rw) - Base address. Each aperture uses a varying number of bits, always starting at the most significant bit of the BaseAddr field. Remaining least significant bits of BaseAddr are ignored. NOTE: Trap Mode uses bits [20:16] for CPP Action
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_VF_P2C_BAR(_x, _y, _z) (0x00000060 + (0xc0 * ((_x) & 0x7)) + (0x8 * ((_y) & 0x3)) + (0x4 * ((_z) & 0x1)))
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_LEN(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_LEN_of(_x) (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_LEN_32BIT (0)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_LEN_64BIT (1)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_LEN_0BYTE (3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_TARGET(_x) (((_x) & 0xf) << 26)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_TARGET_of(_x) (((_x) >> 26) & 0xf)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_TOKEN(_x) (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_TOKEN_of(_x) (((_x) >> 24) & 0x3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE_of(_x) (((_x) >> 22) & 0x3)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE_MEM (0)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE_ROCE (1)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE_QCTL (2)
#define     NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_MAP_TYPE_TRAP (3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_BASE(_x) (((_x) & 0x3fffff) << 0)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_VF_P2C_BAR_BASE_of(_x) (((_x) >> 0) & 0x3fffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR0 - PCIe to CPP Explicit Command BAR 0
    Bits: 31:30 SignalType(rw) - Signal type to expect from CPP target. Set 1 bit for each signal expected. If 0 this implies the PCIe component should expect no CPP signal and will complete the PCIe request immediately, potentially before the CPP request completes. This use case is reserved for 3rd party Mastering and Signaling. Ensure all Explicit CPP Command fields (Data/Signal Master, Data/Signal Ref) are configured properly for the intended Master/Target combination.
    Bits: 29:28 Token(rw) - CPP command token
    Bits: 23:0  Address(rw) - This field represents bits [39:22] of CPP command address, starting with the msb and truncating unnecessary lsb bits, depending on the size of the aperture. See figure 2.2 for more detail of address bit muxing.
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_P2CX0(_x, _y) (0x00000080 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_SIGTYPE(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_SIGTYPE_of(_x) (((_x) >> 30) & 0x3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_TOK(_x) (((_x) & 0x3) << 28)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_TOK_of(_x) (((_x) >> 28) & 0x3)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_ADDR(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX0_ADDR_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR1 - PCIe to CPP Explicit Command BAR 1
    Bits: 30:24 SignalRef(rw) - CPP command signal reference, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
    Bits: 23:14 DataMaster(rw) - CPP command data master, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
    Bits: 13:0  DataRef(rw) - CPP command data reference, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_P2CX1(_x, _y) (0x00000084 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_SIGNAL_REF(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_SIGNAL_REF_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_DATA_MASTER(_x) (((_x) & 0x3ff) << 14)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_DATA_MASTER_of(_x) (((_x) >> 14) & 0x3ff)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_DATA_REF(_x) (((_x) & 0x3fff) << 0)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX1_DATA_REF_of(_x) (((_x) >> 0) & 0x3fff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR2 - PCIe to CPP Explicit Command BAR 2
    Bits: 31:28 Target(rw) - CPP command target ID
    Bits: 27:23 Action(rw) - CPP Command Action Encoding
    Bits: 22:18 Length(rw) - CPP command length
    Bits: 17:10 ByteMask(rw) - CPP command byte mask
    Bits:  9:0  SignalMaster(rw) - CPP command signal master, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_P2CX2(_x, _y) (0x00000088 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_TGT(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_TGT_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_ACT(_x) (((_x) & 0x1f) << 23)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_ACT_of(_x) (((_x) >> 23) & 0x1f)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_LEN(_x) (((_x) & 0x1f) << 18)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_LEN_of(_x) (((_x) >> 18) & 0x1f)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_BYTE_MASK(_x) (((_x) & 0xff) << 10)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_BYTE_MASK_of(_x) (((_x) >> 10) & 0xff)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_SIGNAL_MASTER(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_BAR_PCIETOCPPEXPANSIONBAR_PF_PCIEEXPLICITCMD_P2CX2_SIGNAL_MASTER_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: CPPToPCIeBAR[8] - CPP to PCIe translation BAR
    Bits: 31:30 MapType(rw) - Map Type
    Bits: 29    OverrideRID(rw) - Set if, Requester ID in PCIe TLP header should be overridden.
    Bits: 28:21 RequesterID(rw) - Value for Requester ID (if OverrideRID is set) to use in PCIe TLP header. Otherwise ignored.
    Bits: 20:0  Address(rw) - PCIe address bits [47:27] for 32-bit mode and [20:8] map to bits [47:35] for 40-bit mode. NOTE: For Type-1 Configuration cycles to the PCIe bus, bit [3] of this field should be set to '1'.
*/
#define NFP3800_PCIE_BAR_C2P(_x)                             (0x00000600 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_BAR_C2P_TYPE(_x)                      (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_C2P_TYPE_of(_x)                   (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_BAR_C2P_TYPE_MEM                    (0)
#define     NFP3800_PCIE_BAR_C2P_TYPE_IO                     (1)
#define     NFP3800_PCIE_BAR_C2P_TYPE_CFG                    (2)
#define   NFP3800_PCIE_BAR_C2P_ARI_ENABLE                    BIT(29)
#define   NFP3800_PCIE_BAR_C2P_ARI(_x)                       (((_x) & 0xff) << 21)
#define   NFP3800_PCIE_BAR_C2P_ARI_of(_x)                    (((_x) >> 21) & 0xff)
#define   NFP3800_PCIE_BAR_C2P_ADDR(_x)                      (((_x) & 0x1fffff) << 0)
#define   NFP3800_PCIE_BAR_C2P_ADDR_of(_x)                   (((_x) >> 0) & 0x1fffff)
/*----------------------------------------------------------------
  Register: CPPToPCIeBaseExt[8] - CPP to PCIe BAR Base Address extension
    Bits: 15:0  Cpp2Pcie_Base_Addr_Ext(rw) - An extension of the Base Address field of the Cpp2PCIe BAR to form a 64-bit PCIe address.
*/
#define NFP3800_PCIE_BAR_C2P_EXT(_x)                         (0x00000620 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_BAR_C2P_EXT_CPP2PCI_BASE_ADDR_EXT(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_BAR_C2P_EXT_CPP2PCI_BASE_ADDR_EXT_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeMsixInterruptGenerator_PcieMsiSwGenEntry[256] - Used by Software to generate MSI Interrupts. Must be in MSI mode. msi_ctrl_reg register MSIEn=1. The offset into the table is used to generate the 8-bit function number
    Bits:  4:0  MsiVectorNum(wo) - The MSI Vector number to use when software is generating MSI Interrupts.
*/
#define NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PCIE_MSI_SW_GEN(_x) (0x00060000 + (0x4 * ((_x) & 0xff)))
#define   NFP3800_PCIE_MSIX_PCIEMSIXINTERRUPTGENERATOR_PCIE_MSI_SW_GEN_MSI_VEC_NUM(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIE_MSIX_PCIEMSIXINTERRUPTGENERATOR_PCIE_MSI_SW_GEN_MSI_VEC_NUM_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeMsixInterruptGenerator_PcieMsixSwGenEntry[256] - Used by software to generate MSIX Interrupts. Must be in MSIX mode. msix_ctrl register MSIxEn=1
    Bits:  7:0  MsixVectorNum(wo) - The MSIX Vector number to use when software is generating MSIX Interrupts.
*/
#define NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PCIE_MSIX_SW_GEN(_x) (0x00060000 + (0x4 * ((_x) & 0xff)))
#define   NFP3800_PCIE_MSIX_PCIEMSIXINTERRUPTGENERATOR_PCIE_MSIX_SW_GEN_MSIX_VEC_NUM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_MSIX_PCIEMSIXINTERRUPTGENERATOR_PCIE_MSIX_SW_GEN_MSIX_VEC_NUM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeTargetFuncCfgLUT[64] - Lookup table that stores for each VF the base addr of its queue region, number of queues and which associated PF
    Bits: 31    EntryValid(rw) - A valid bit to indicate the table entry has been initialized.
    Bits: 29:28 PhysFuncNum(rw) - PF number associated with the VF.
    Bits: 24:16 QueueCount(rw) - The 9-bit count of queues assigned to VF, used to check if queue request is valid or out of range, where the queue count is specified as number of queues minus 1
    Bits:  8:0  QueueBaseAddr(rw) - The 9-bit base addr of where VF queues start.
*/
#define NFP3800_PCIE_VFLUT_VF_CFG_LUT(_x)                    (0x00070000 + (0x4 * ((_x) & 0x3f)))
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_VALID                BIT(31)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_PF_NUM(_x)           (((_x) & 0x3) << 28)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_PF_NUM_of(_x)        (((_x) >> 28) & 0x3)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_QUE_COUNT(_x)        (((_x) & 0x1ff) << 16)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_QUE_COUNT_of(_x)     (((_x) >> 16) & 0x1ff)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_QUE_BASE(_x)         (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIE_VFLUT_VF_CFG_LUT_QUE_BASE_of(_x)      (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven0 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd0 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven0 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd0 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd0 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven0 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd0 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven0 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd0 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven0 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd0 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:0  CPPAddressLo(wo) - Lower 32-bits of 40-bit CPP bus address unless ModeSelect==3 and DmaMode[13]==1 (Packet Mode). In Packet Mode this field contains the {SequenceNumber[15:00],2h0,TotalLength[13:0]}. The SequenceNumber is copied to the metadata written to the CTM. The TotalLength is the total number of bytes of a Packet Mode Gather DMA and must be equal to the total of each stage of the DMA operation. (refer to the DMA section of the EAS).
*/
#define NFP3800_PCIE_DMA_TOPCI_HI_EVEN0                      0x00000000
#define NFP3800_PCIE_DMA_TOPCI_HI_ODD0                       0x00000010
#define NFP3800_PCIE_DMA_TOPCI_MED_EVEN0                     0x00000020
#define NFP3800_PCIE_DMA_TOPCI_MED_ODD0                      0x00000030
#define NFP3800_PCIE_DMA_TOPCI_LO_ODD0                       0x00000040
#define NFP3800_PCIE_DMA_FROMPCI_HI_EVEN0                    0x00000060
#define NFP3800_PCIE_DMA_FROMPCI_HI_ODD0                     0x00000070
#define NFP3800_PCIE_DMA_FROMPCI_MED_EVEN0                   0x00000080
#define NFP3800_PCIE_DMA_FROMPCI_MED_ODD0                    0x00000090
#define NFP3800_PCIE_DMA_FROMPCI_LO_EVEN0                    0x000000a0
#define NFP3800_PCIE_DMA_FROMPCI_LO_ODD0                     0x000000b0
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY0_CPP_ADDR_LO(_x)   (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY0_CPP_ADDR_LO_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven1 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd1 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven1 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd1 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd1 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven1 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd1 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven1 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd1 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven1 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd1 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:30 ModeSelect(wo) - Selects what type of signaling, AutoPush or Event, or indicates Packet Mode, also see DMA Mode field
    Bits: 29:14 DmaMode(wo) - Indicates Signal or Event to generate on completed command or can be DMA descriptor extension for Data Gather support, depending on ModeSelect bits
    Bits: 13:12 CppToken(wo) - Specifies CPP Token to be used when issuing CPP commands for the transfer.
    Bits: 11:8  DmaConfigRegIndex(wo) - Index register for CPP transaction. Used to index from which register to get supplemental DMA descriptor configuration. NOTE: lsb chooses low or high half of 4B configuration register
    Bits:  7:0  CPPAddressHi(wo) - Upper 8-bits of 40-bit CPP bus address unless ModeSelect==3 and DmaMode[13]==1 (Packet Mode). In Packet Mode this field is the 8-bit QID copied to the metadata written to the CTM (refer to the DMA section of the EAS).
*/
#define NFP3800_PCIE_DMA_TOPCI_HI_EVEN1                      0x00000004
#define NFP3800_PCIE_DMA_TOPCI_HI_ODD1                       0x00000014
#define NFP3800_PCIE_DMA_TOPCI_MED_EVEN1                     0x00000024
#define NFP3800_PCIE_DMA_TOPCI_MED_ODD1                      0x00000034
#define NFP3800_PCIE_DMA_TOPCI_LO_ODD1                       0x00000044
#define NFP3800_PCIE_DMA_FROMPCI_HI_EVEN1                    0x00000064
#define NFP3800_PCIE_DMA_FROMPCI_HI_ODD1                     0x00000074
#define NFP3800_PCIE_DMA_FROMPCI_MED_EVEN1                   0x00000084
#define NFP3800_PCIE_DMA_FROMPCI_MED_ODD1                    0x00000094
#define NFP3800_PCIE_DMA_FROMPCI_LO_EVEN1                    0x000000a4
#define NFP3800_PCIE_DMA_FROMPCI_LO_ODD1                     0x000000b4
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL(_x)      (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL_of(_x)   (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL_0      (0)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL_1      (1)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL_2      (2)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_MODE_SEL_3      (3)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE(_x)      (((_x) & 0xffff) << 14)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE_of(_x)   (((_x) >> 14) & 0xffff)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE_0      (0)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE_1      (1)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE_2      (2)
#define     NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_MODE_3      (3)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_CPP_TOKEN(_x)     (((_x) & 0x3) << 12)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_CPP_TOKEN_of(_x)  (((_x) >> 12) & 0x3)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_CFG_INDEX(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_DMA_CFG_INDEX_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_CPP_ADDR_HI(_x)   (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY1_CPP_ADDR_HI_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven2 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd2 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven2 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd2 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd2 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven2 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd2 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven2 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd2 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven2 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd2 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:0  PCIeAddressLo(wo) - Lower 32 bits of 40-bit PCIe address
*/
#define NFP3800_PCIE_DMA_TOPCI_HI_EVEN2                      0x00000008
#define NFP3800_PCIE_DMA_TOPCI_HI_ODD2                       0x00000018
#define NFP3800_PCIE_DMA_TOPCI_MED_EVEN2                     0x00000028
#define NFP3800_PCIE_DMA_TOPCI_MED_ODD2                      0x00000038
#define NFP3800_PCIE_DMA_TOPCI_LO_ODD2                       0x00000048
#define NFP3800_PCIE_DMA_FROMPCI_HI_EVEN2                    0x00000068
#define NFP3800_PCIE_DMA_FROMPCI_HI_ODD2                     0x00000078
#define NFP3800_PCIE_DMA_FROMPCI_MED_EVEN2                   0x00000088
#define NFP3800_PCIE_DMA_FROMPCI_MED_ODD2                    0x00000098
#define NFP3800_PCIE_DMA_FROMPCI_LO_EVEN2                    0x000000a8
#define NFP3800_PCIE_DMA_FROMPCI_LO_ODD2                     0x000000b8
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY2_PCIE_ADDR_LO(_x)  (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY2_PCIE_ADDR_LO_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven3 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd3 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven3 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd3 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd3 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven3 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd3 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven3 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd3 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven3 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd3 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:20 XferLength(wo) - Size of transfer. Specified as number of bytes minus 1.
    Bits: 19:12 RequesterID(wo) - 8-bit Requester ID to use (if OverrideRID is set)
    Bits: 11    OverrideRID(wo) - If set the value of RequesterID will be used for the Requester-ID in the PCIe TLP header
    Bits: 10:8  TransClass(wo) - Indicates the transaction class.
    Bits:  7:0  PCIeAddressHi(wo) - Upper 8 bits of 40-bit PCIe address
*/
#define NFP3800_PCIE_DMA_TOPCI_HI_EVEN3                      0x0000000c
#define NFP3800_PCIE_DMA_TOPCI_HI_ODD3                       0x0000001c
#define NFP3800_PCIE_DMA_TOPCI_MED_EVEN3                     0x0000002c
#define NFP3800_PCIE_DMA_TOPCI_MED_ODD3                      0x0000003c
#define NFP3800_PCIE_DMA_TOPCI_LO_ODD3                       0x0000004c
#define NFP3800_PCIE_DMA_FROMPCI_HI_EVEN3                    0x0000006c
#define NFP3800_PCIE_DMA_FROMPCI_HI_ODD3                     0x0000007c
#define NFP3800_PCIE_DMA_FROMPCI_MED_EVEN3                   0x0000008c
#define NFP3800_PCIE_DMA_FROMPCI_MED_ODD3                    0x0000009c
#define NFP3800_PCIE_DMA_FROMPCI_LO_EVEN3                    0x000000ac
#define NFP3800_PCIE_DMA_FROMPCI_LO_ODD3                     0x000000bc
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_LENGTH(_x)        (((_x) & 0xfff) << 20)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_LENGTH_of(_x)     (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_RID(_x)           (((_x) & 0xff) << 12)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_RID_of(_x)        (((_x) >> 12) & 0xff)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_RID_OVERRIDE      BIT(11)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_TRANS_CLASS(_x)   (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_TRANS_CLASS_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_PCIE_ADDR_HI(_x)  (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMADESCRLEGACY3_PCIE_ADDR_HI_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMADescrConfig0 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig1 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig2 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig3 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig4 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig5 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig6 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig7 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
    Bits: 30    FrmPcieCppRnd8BOdd(rw) - When set, the length of the CPP portion of the From PCIe DMA is rounded up to the nearest 8 bytes. This bit has no effect on To PCIe DMAs.
    Bits: 29    FreeCtmPacketOdd(rw) - When set, a ToPCIe DMA issues a free packet command as part of the packet completion process to free the packet in the CTM packet engine
    Bits: 28    SignalOnlyOdd(rw) - Specifies if DMA is a signal-only, no data transferred.
    Bits: 27:26 EndPaddingOdd(rw) - Specifies if 0-padding should be inserted at the end of DMA transfers to PCIe.
    Bits: 25:24 StartPaddingOdd(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits: 23    IdBasedOrderingOdd(rw) - Specifies if ID-Based Ordering attribute should be set for PCIe request.
    Bits: 22    RelaxedOrderingOdd(rw) - Specifies if Relaxed Ordering attribute should be set for PCIe request.
    Bits: 21    NoSnoopOdd(rw) - Specifies if No Snoop attribute should be set for PCIe request.
    Bits: 20    Target64bitOdd(rw) - Specifies if CPP Target is 64-bit or 32-bit, default is 32-bit.
    Bits: 19:16 CppTargetIDOdd(rw) - Selects CPP Target to be used for DMA.
    Bits: 14    FrmPcieCppRnd8BEven(rw) - When set, the length of the CPP portion of the From PCIe DMA is rounded up to the nearest 8 bytes. This bit has no effect on To PCIe DMAs.
    Bits: 13    FreeCtmPacketEven(rw) - When set, a ToPCIe DMA issues a free packet command as part of the packet completion process to free the packet in the CTM packet engine
    Bits: 12    SignalOnlyEven(rw) - Specifies if DMA is a signal-only, no data transferred.
    Bits: 11:10 EndPaddingEven(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits:  9:8  StartPaddingEven(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits:  7    IdBasedOrderingEven(rw) - Specifies if ID-Based Ordering attribute should be set for PCIe request.
    Bits:  6    RelaxedOrderingEven(rw) - Specifies if Relaxed Ordering attribute should be set for PCIe request.
    Bits:  5    NoSnoopEven(rw) - Specifies if No Snoop attribute should be set for PCIe request.
    Bits:  4    Target64bitEven(rw) - CPP target is 64-bit. Set if target supports 64-bit transactions, or cleared if target only supports 32-bit transaction.
    Bits:  3:0  CppTargetIDEven(rw) - Selects CPP Target to be used for DMA.
*/
#define NFP3800_PCIE_DMA_CFG0                                0x000000c0
#define NFP3800_PCIE_DMA_CFG1                                0x000000c4
#define NFP3800_PCIE_DMA_CFG2                                0x000000c8
#define NFP3800_PCIE_DMA_CFG3                                0x000000cc
#define NFP3800_PCIE_DMA_CFG4                                0x000000d0
#define NFP3800_PCIE_DMA_CFG5                                0x000000d4
#define NFP3800_PCIE_DMA_CFG6                                0x000000d8
#define NFP3800_PCIE_DMA_CFG7                                0x000000dc
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_FRM_PCIE_CPP_RND8B_ODD BIT(30)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_FREE_CTM_PACKET_ODD BIT(29)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_SIGNAL_ONLY_ODD    BIT(28)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD(_x)    (((_x) & 0x3) << 26)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD_of(_x) (((_x) >> 26) & 0x3)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD_16B  (1)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD_64B  (2)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_ODD_128B (3)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD(_x)  (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD_of(_x) (((_x) >> 24) & 0x3)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD_16B (1)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD_64B (2)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_ODD_128B (3)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_ID_BASED_ORDER_ODD BIT(23)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_RELAXED_ORDER_ODD  BIT(22)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_NO_SNOOP_ODD       BIT(21)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_TARGET_64_ODD      BIT(20)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_CPP_TARGET_ODD(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_CPP_TARGET_ODD_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_FRM_PCIE_CPP_RND8B_EVEN BIT(14)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_FREE_CTM_PACKET_EVEN BIT(13)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_SIGNAL_ONLY_EVEN   BIT(12)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN(_x)   (((_x) & 0x3) << 10)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN_of(_x) (((_x) >> 10) & 0x3)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN_16B (1)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN_64B (2)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_END_PAD_EVEN_128B (3)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN_of(_x) (((_x) >> 8) & 0x3)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN_16B (1)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN_64B (2)
#define     NFP3800_PCIE_DMA_DMADESCRCONFIG_START_PAD_EVEN_128B (3)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_ID_BASED_ORDER_EVEN BIT(7)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_RELAXED_ORDER_EVEN BIT(6)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_NO_SNOOP_EVEN      BIT(5)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_TARGET_64_EVEN     BIT(4)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_CPP_TARGET_EVEN(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIE_DMA_DMADESCRCONFIG_CPP_TARGET_EVEN_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: DMAQStatToPCI0 - Queue status for ToPCIe DMA command queues
    Bits: 31:24 DmaLoQueAvail(ro) - DMA Low priority queue space available
    Bits: 23:16 DmaLoQueWrPtr(ro) - DMA Low priority queue write pointer
    Bits: 13    DisAriError(rw) - Setting this bit disables VF Access errors from dropping DMAs. When this bit is clear VF Access Errors cause DMAs using the errored VF to be dropped
    Bits: 12    ResetDMA(w1c) - Setting this bit clears the DMA Queue Read/Write Pointers. This bit can only be written after software writes a 1 to the QueueStop register. Software should only set this bit after waiting for any inflight DMAs to complete.
    Bits: 11    MultiBitError(rw1c) - When non-zero, A multi-bit error was detected while reading from the DMA Descriptor memory.
    Bits: 10    DisDmaDescMultiBitErr(rw) - When set, DMA Engine ingores Descriptor multibit errors.
    Bits:  9    HaltOnPfDmaError(rw) - When set, DMA Engine will halt on a physical function access error.
    Bits:  8    HaltOnRdMultiBitError(rw) - When set, DMA Engine will halt on a DMA Descriptor multibit error.
    Bits:  7:6  DmaError(rw1c) - When non-zero, DMA had an error. Bit 0 indicates a virtual function access error. Bit 1 indicates a physical function access error.
    Bits:  5:4  QueueOverflow(rw1c) - When non-zero, DMA queue descriptor is written to a full queue.
    Bits:  3    HaltOnFull(rw) - When non-zero, DMA Engine will halt when full
    Bits:  2    HighQueueStop(rw) - Set when the DMA engine High Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  1    MediumQueueStop(rw) - Set when the DMA engine Medium Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  0    LowQueueStop(rw) - Set when the DMA engine Low Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
*/
#define NFP3800_PCIE_DMA_QSTS0_TOPCI                         0x000000e0
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_LO_AVAIL(_x)      (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_LO_AVAIL_of(_x)   (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_LO_WRPTR(_x)      (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_LO_WRPTR_of(_x)   (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DIS_ARI_ERROR         BIT(13)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_RESET_DMA             BIT(12)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_MULTIBIT_ERROR        BIT(11)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DIS_DMADESC_MULTIBIT_ERR BIT(10)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_PF_ERROR_HALT         BIT(9)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_MULTIBIT_ERROR_HALT   BIT(8)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_ERROR(_x)         (((_x) & 0x3) << 6)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_DMA_ERROR_of(_x)      (((_x) >> 6) & 0x3)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW(_x)    (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW_NOOVFL (0)
#define     NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW_LOWOVFL (1)
#define     NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW_MEDOVFL (2)
#define     NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_OVERFLOW_HIGHOVFL (3)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_QUEUE_HALT_FULL       BIT(3)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_HI_QUEUE_STOP         BIT(2)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_MED_QUEUE_STOP        BIT(1)
#define   NFP3800_PCIE_DMA_QSTS0_TOPCI_LO_QUEUE_STOP         BIT(0)
/*----------------------------------------------------------------
  Register: DMAQStatToPCI1 - Queue status for ToPCIe DMA command queues
  Register: DMAQStatFrmPCI1 - Queue status for FrmPCIe DMA command queues
    Bits: 31:24 DmaHiQueAvail(ro) - DMA High priority queue space available
    Bits: 23:16 DmaHiQueWrPtr(ro) - DMA High priority queue write pointer
    Bits: 15:8  DmaMedQueAvail(ro) - DMA Medium priority queue space available
    Bits:  7:0  DmaMedQueWrPtr(ro) - DMA Medium priority queue write pointer
*/
#define NFP3800_PCIE_DMA_QSTS1_TOPCI                         0x000000e4
#define NFP3800_PCIE_DMA_QSTS1_FROMPCI                       0x000000ec
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_HI_AVAIL(_x)  (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_HI_AVAIL_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_HI_WRPTR(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_HI_WRPTR_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_MED_AVAIL(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_MED_AVAIL_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_MED_WRPTR(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMAQUEUESTATUS1_DMA_MED_WRPTR_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMAQStatFrmPCI0 - Queue status for FrmPCIe DMA command queues
    Bits: 31:24 DmaLoQueAvail(ro) - DMA Low priority queue space available
    Bits: 23:16 DmaLoQueWrPtr(ro) - DMA Low priority queue write pointer
    Bits: 15:14 PktModeStgError(rw1c) - When non-zero, DMA detected a packet mode descriptor stage was in error. This indicates a start stage was received for a context that was still in use or a middle or end packet mode stage was detected with no previus start stage. In both cases the descriptors are dropped.
    Bits: 13    DisAriError(rw) - Setting this bit disables VF Access errors from dropping DMAs. When this bit is clear VF Access Errors cause DMAs using the errored VF to be dropped
    Bits: 12    ResetDMA(w1c) - Setting this bit clears the DMA Queue Read/Write Pointers. This bit can only be written after software writes a 1 to the QueueStop register. Software should only set this bit after waiting for any inflight DMAs to complete.
    Bits: 11    MultiBitError(rw1c) - When non-zero, A multi-bit error was detected while reading from the DMA Descriptor memory.
    Bits: 10    DisDmaDescMultiBitErr(rw) - When set, DMA Engine ingores Descriptor multibit errors.
    Bits:  9    HaltOnPfDmaError(rw) - When set, DMA Engine will halt on a physical function access error.
    Bits:  8    HaltOnRdMultiBitError(rw) - When set, DMA Engine will halt on a DMA Descriptor multibit error.
    Bits:  7:6  DmaError(rw1c) - When non-zero, DMA had an error. Bit 0 indicates a virtual function access error. Bit 1 indicates a physical function access error.
    Bits:  5:4  QueueOverflow(rw1c) - When non-zero, DMA queue descriptor is written to a full queue.
    Bits:  3    HaltOnFull(rw) - When non-zero, DMA Engine will halt when full
    Bits:  2    HighQueueStop(rw) - Set when the DMA engine High Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  1    MediumQueueStop(rw) - Set when the DMA engine Medium Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  0    LowQueueStop(rw) - Set when the DMA engine Low Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
*/
#define NFP3800_PCIE_DMA_QSTS0_FROMPCI                       0x000000e8
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_LO_AVAIL(_x)    (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_LO_AVAIL_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_LO_WRPTR(_x)    (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_LO_WRPTR_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR_of(_x) (((_x) >> 14) & 0x3)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR_NOPMSTGERR (0)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR_LOWPMSTGERR (1)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR_MEDPMSTGERR (2)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_PKT_MODE_STG_ERROR_HIGHPMSTGERR (3)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DIS_ARI_ERROR       BIT(13)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_RESET_DMA           BIT(12)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_MULTIBIT_ERROR      BIT(11)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DIS_DMADESC_MULTIBIT_ERR BIT(10)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_PF_ERROR_HALT       BIT(9)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_MULTIBIT_ERROR_HALT BIT(8)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_ERROR(_x)       (((_x) & 0x3) << 6)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_DMA_ERROR_of(_x)    (((_x) >> 6) & 0x3)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW(_x)  (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW_NOOVFL (0)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW_LOWOVFL (1)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW_MEDOVFL (2)
#define     NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_OVERFLOW_HIGHOVFL (3)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_QUEUE_HALT_FULL     BIT(3)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_HI_QUEUE_STOP       BIT(2)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_MED_QUEUE_STOP      BIT(1)
#define   NFP3800_PCIE_DMA_QSTS0_FROMPCI_LO_QUEUE_STOP       BIT(0)
/*----------------------------------------------------------------
  Register: DMACntrlConfig1 - DMA performance configure, cpp and pcie request issue rates
    Bits: 31:28 DmaFrmCppRate(rw) - DMA FromPCIe rate at which requests are issued to CPP
    Bits: 27:24 DmaToPcieRate(rw) - DMA ToPCIe rate at which requests are issued to CPP
    Bits: 23:20 DmaToCppRate(rw) - DMA ToPCIe rate at which requests are issued to PCIe
    Bits: 19:16 DmaFrmPcieRate(rw) - DMA FromPCIe rate at which requests are issued to PCIe
    Bits: 15:12 DmaFrmPcieIssueLoad(rw) - DMA FromPCIe issue rate load value. Controls rate at which requests are issued to PCIe
    Bits:  0    DmaRateLimitSelect(rw) - Selects the type of rate limiting used by the DMA engine.
*/
#define NFP3800_PCIE_DMA_CTRL_CFG1                           0x000000f8
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_CPP_RATE(_x)    (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_CPP_RATE_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_TO_PCIE_RATE(_x)    (((_x) & 0xf) << 24)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_TO_PCIE_RATE_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_TO_CPP_RATE(_x)     (((_x) & 0xf) << 20)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_TO_CPP_RATE_of(_x)  (((_x) >> 20) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_PCIE_RATE(_x)   (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_PCIE_RATE_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_PCIE_ISSUE_LOAD(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_FRM_PCIE_ISSUE_LOAD_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG1_DMA_RATE_LIMIT_SELECT   BIT(0)
#define     NFP3800_PCIE_DMA_CTRL_CFG1_DMA_RATE_LIMIT_SELECT_BWRATELIMIT (0 << 0)
#define     NFP3800_PCIE_DMA_CTRL_CFG1_DMA_RATE_LIMIT_SELECT_ISSUERATELIMIT BIT(0)
/*----------------------------------------------------------------
  Register: DMACntrlConfig2 - DMA Bandwidth configuration, cpp and pcie request bandwidth control
    Bits: 31:28 DmaToCppTh(rw) - Selects the threshold of the rate limiter in 256 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 27:24 DmaToPcieTh(rw) - Selects the threshold of the rate limiter in 512 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 23:20 DmaFrmCppTh(rw) - Selects the threshold of the rate limiter in 512 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 19:16 DmaFrmPcieTh(rw) - Selects the threshold of the rate limiter in 256 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 14:12 DmaRate(rw) - Controls the number of cycles between credit decrements in all of the Token bucket rate shapers. A value of 0 equates to 1 cycle. A value of 7 equates to 8 cycles.
    Bits: 11:9  DmaToCppCredit(rw) - Controls bandwidth of CPP Reads when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  8:6  DmaToPcieCredit(rw) - Controls bandwidth of PCIe Writes when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  5:3  DmaFrmCppCredit(rw) - Controls bandwidth of CPP Reads when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  2:0  DmaFrmPcieCredit(rw) - Controls bandwidth of PCIe Reads when in BWRateLimit mode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
*/
#define NFP3800_PCIE_DMA_CTRL_CFG2                           0x000000fc
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_CPP_TH(_x)       (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_CPP_TH_of(_x)    (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_PCIE_TH(_x)      (((_x) & 0xf) << 24)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_PCIE_TH_of(_x)   (((_x) >> 24) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_CPP_TH(_x)      (((_x) & 0xf) << 20)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_CPP_TH_of(_x)   (((_x) >> 20) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_PCIE_TH(_x)     (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_PCIE_TH_of(_x)  (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_RATE(_x)            (((_x) & 0x7) << 12)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_RATE_of(_x)         (((_x) >> 12) & 0x7)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_CPP_CREDIT(_x)   (((_x) & 0x7) << 9)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_CPP_CREDIT_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_PCIE_CREDIT(_x)  (((_x) & 0x7) << 6)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_TO_PCIE_CREDIT_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_CPP_CREDIT(_x)  (((_x) & 0x7) << 3)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_CPP_CREDIT_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_PCIE_CREDIT(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_CTRL_CFG2_DMA_FRM_PCIE_CREDIT_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: DMADescrTPHConfig[8] - Specifies additional DMA configuration information to supplement incoming descriptor, TPH Value and Steering Tag settings.
    Bits: 26    TphCtrlEnaOdd(rw) - When set the TPH Value and associated TPH Steering Tag are used during the all DMA TLPs. When clear the TPH and TPH Steering Tag are not used for DMA TLPs
    Bits: 25:24 TphOdd(rw) - TPH Value used in all DMA TLPs when TphCtrlEnaOdd bit is set.
    Bits: 23:16 TphStOdd(rw) - TPH Steering Tag used in all DMA TLPs when TphCtrlEnaOdd bit is set.
    Bits: 10    TphCtrlEnaEven(rw) - When set the TPH Value and associated TPH Steering Tag are used during the all DMA TLPs. When clear the TPH and TPH Steering Tag are not used for DMA TLPs
    Bits:  9:8  TphEven(rw) - TPH Value used in all DMA TLPs when TphCtrlEnaEven bit is set.
    Bits:  7:0  TphStEven(rw) - TPH Steering Tag used in all DMA TLPs when TphCtrlEnaEven bit is set.
*/
#define NFP3800_PCIE_DMA_DMA_STAG(_x)                        (0x00000100 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_CTRL_ENA_ODD         BIT(26)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ODD(_x)              (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ODD_of(_x)           (((_x) >> 24) & 0x3)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ST_ODD(_x)           (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ST_ODD_of(_x)        (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_CTRL_ENA_EVEN        BIT(10)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_EVEN(_x)             (((_x) & 0x3) << 8)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_EVEN_of(_x)          (((_x) >> 8) & 0x3)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ST_EVEN(_x)          (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMA_STAG_TPH_ST_EVEN_of(_x)       (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMAAllocCtrl - Packet Mode DMA Allocatoin Control CSR
    Bits: 22    muPtrOffsetCtrl(rw) - During Split packets - this bit determines the address offset to start DMAing the packet to the Memory unit buffer. This bit must be set to the value used in the NBI NbiCtrl Register for proper operation.
    Bits: 21:20 AllocLookaheadNeg256bCredit(rw) - Threshold to control the number of 256B credits a CTM can use after the buffer credit is negative.
    Bits: 19:18 AllocLookaheadNegBufCredit(rw) - Controls how much the buffer credit can go negative by.
    Bits: 17    AllocLookaheadEna(rw) - Enables the support for packet allocation lookahead.
    Bits: 16    PacketColorEnable(rw) - When set, the DMA engine adds 2-bit packet color in packet mode DMA metadata based on the CTM's credit level.
    Bits: 15    ResetDMAState(rw) - Set this bit to reset DMA Context State registers used in packet mode DMA. This bit will only have an effect after all FromPcie DMA Stop bits are set by software. Software should only set this bit after any inflight DMAs have completed
    Bits: 14    PollRespNoWaitEna(rw) - When set, CTM Polling command responses are processed as they arrive. When cleared, CTM Polling command responses are processed after all outstanding responses have arrived
    Bits: 12    NonDepWrBeatsReadEna(rw) - Allows non dependent writes to pass reads in the CTM bulk Engine. Copied to bit 30 of the CPP address field during Packet Mode DMAs to the CTM
    Bits: 11    DisBdRamErr(rw) - Controls how the BLQ logic handles multi-bit ECC errors received from the Buffer Descriptor RAM
    Bits: 10    DisRxPushLastErr(rw) - Controls how the hardware responds to a push bus input protocol error for allocation response transactions
    Bits:  9    DisRxAllocInErr(rw) - Controls how the hardware responds to a push bus input error for allocation response transactions.
    Bits:  8    DisRxBlqWrInErr(rw) - Controls how the hardware responds to a push bus input error for BLQ writes transactions.
    Bits:  7:5  PCIeNum(rw) - This field is placed in the 3 lsbits of the Packet Allocation Command Address field. It is used by the CTM to identify the source of the command. It must be a different value for each source.
    Bits:  4    CtmPollEna(rw) - Configures whether the polling function is enabled or disabled.
    Bits:  3:2  CtmPollIntvl(rw) - Configures the minimum amount of time between packet allocation poll commands in clock cycles.
    Bits:  1:0  PollCmdIssueRate(rw) - Configures the space between CPP Polling commands issues after the polling interval has expired
*/
#define NFP3800_PCIE_DMA_DMA_ALLOC_CTRL                      0x00000120
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_MU_PTR_OFFSET_CTRL BIT(22)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_MU_PTR_OFFSET_CTRL_SPLITOFFSET (0 << 22)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_MU_PTR_OFFSET_CTRL_NOOFFSET BIT(22)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT(_x) (((_x) & 0x3) << 20)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT_of(_x) (((_x) >> 20) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT_16 (0)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT_32 (1)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT_48 (2)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG256B_CREDIT_64 (3)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT_of(_x) (((_x) >> 18) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT_NONE (0)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT__1 (1)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT__2 (2)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_NEG_BUF_CREDIT__3 (3)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_ALLOC_LOOKAHEAD_ENA BIT(17)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_PACKET_COLOR_ENABLE BIT(16)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_RESET_DMA_STATE    BIT(15)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_RESP_NO_WAIT_ENA BIT(14)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_NON_DEPWR_BEAT_READS_ENA BIT(12)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_BDRAM_ERR      BIT(11)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_BDRAM_ERR_ENABLE (0 << 11)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_BDRAM_ERR_DISABLE BIT(11)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXPUSH_LAST_ERR BIT(10)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXPUSH_LAST_ERR_ENABLE (0 << 10)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXPUSH_LAST_ERR_DISABLE BIT(10)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXALLOC_IN_ERR BIT(9)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXALLOC_IN_ERR_ENABLE (0 << 9)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXALLOC_IN_ERR_DISABLE BIT(9)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXBLQWR_IN_ERR BIT(8)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXBLQWR_IN_ERR_ENABLE (0 << 8)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_DIS_RXBLQWR_IN_ERR_DISABLE BIT(8)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_PCIE_NUM(_x)       (((_x) & 0x7) << 5)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_PCIE_NUM_of(_x)    (((_x) >> 5) & 0x7)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_ENA       BIT(4)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_ENA_DISABLE (0 << 4)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_ENA_ENABLE BIT(4)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL_128 (0)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL_256 (1)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL_512 (2)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_CTM_POLL_INTVL_1024 (3)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE_4 (0)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE_8 (1)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE_12 (2)
#define     NFP3800_PCIE_DMA_DMA_ALLOC_CTRL_POLL_CMD_ISSUE_RATE_16 (3)
/*----------------------------------------------------------------
  Register: DMABlqEvent - DMA Buffer List Queue Event Control
    Bits: 22    ReducedThresh(rw) - If set lowers the blq event thresholds to 4, 8, 16 and 32.
    Bits: 20    DisBLQEventFifoFullAssert(rw) - Set this bit to disable the BLQ Event FIFO overflow assertion
    Bits: 19:18 BLQEventThreshold3(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 17:16 BLQEventThreshold2(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 15:14 BLQEventThreshold1(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 13:12 BLQEventThreshold0(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits:  7:4  BLQEventNotFullEnable(rw) - One bit per buffer list queue. Enables the generation of BLQ Events when the queue transitions from full to not full. Disabled when clear. The event type value used is 0x1 (event_type_fifo_not_full)
    Bits:  3:0  BLQEventStatusEnable(rw) - One bit per buffer list queue. Enables BLQ Status Events when set. Disabled when clear. A Status Event is sent when the number of entries read from the queue reaches the programmed value in the BLQEventThreshold register. The event type value used is 0x5 (event_type_value_update)
*/
#define NFP3800_PCIE_DMA_DMA_BLQ_EVENT                       0x00000124
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_REDUCED_THRESH      BIT(22)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_DIS_BLQ_EVENT_FIFO_FULL_ASSERT BIT(20)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3_of(_x) (((_x) >> 18) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3_16_OR_4 (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3_32_OR_8 (1)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3_64_OR_16 (2)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD3_128_OR_32 (3)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2_of(_x) (((_x) >> 16) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2_16_OR_4 (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2_32_OR_8 (1)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2_64_OR_16 (2)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD2_128_OR_32 (3)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1_of(_x) (((_x) >> 14) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1_16_OR_4 (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1_32_OR_8 (1)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1_64_OR_16 (2)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD1_128_OR_32 (3)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0_of(_x) (((_x) >> 12) & 0x3)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0_16_OR_4 (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0_32_OR_8 (1)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0_64_OR_16 (2)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQEVENT_THRESHOLD0_128_OR_32 (3)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_NOT_FULL_ENABLE(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_NOT_FULL_ENABLE_of(_x) (((_x) >> 4) & 0xf)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_NOT_FULL_ENABLE_DISABLE (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_NOT_FULL_ENABLE_ENABLE (1)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_STATUS_ENABLE(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_STATUS_ENABLE_of(_x) (((_x) >> 0) & 0xf)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_STATUS_ENABLE_DISABLE (0)
#define     NFP3800_PCIE_DMA_DMA_BLQ_EVENT_BLQ_EVENT_STATUS_ENABLE_ENABLE (1)
/*----------------------------------------------------------------
  Register: DMABpeChainEnd - DMA BPE Chain End Register
    Bits: 31:0  BpeChainEnd(rw) - Configures BPE module 'n' as the end of the buffer pool entry chain, where 'n' = 0 to 31.
*/
#define NFP3800_PCIE_DMA_BPE_CHAIN_END                       0x00000128
#define   NFP3800_PCIE_DMA_BPE_CHAIN_END_BPE_CHAIN_END(_x)   (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_BPE_CHAIN_END_BPE_CHAIN_END_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DMABP[8]Cfg - DMA Buffer Pool X Configuration
    Bits: 24    BlqBypassEna(rw) - When set, selects to use a null buffer descriptor if the packet is not split.
    Bits: 23    BPRsvd(rw) - Reserved, Write to 0
    Bits: 22:19 CtmBufPad(rw) - Selects the number of 32 bytes to add to the allocation size of the packet. Allows padding to the allocated space in the CTM for smaller packets in increments of 32B. 0=32B, 1=64B, 0xf=512B.
    Bits: 18    CtmBufPadEna(rw) - Enables adding CtmBufPad bytes to the allocation size of the packet.
    Bits: 17:15 CtmOffsetMsb(rw) - This field represents the MSbits of CtmOffset and defines the offset to add to the data reference when starting to write packet data to the CTM. The space in front of the packet is for the rewrite script used by the packet modifier. Encoding of {CtmOffsetMsb[3;0],CtmOffset} are: 0000 = 32B, 0001=64B, 0010=96B, 0011 = 128B, 0100 = 160B, ... 1111 = 512B
    Bits: 13    CtmOffset(rw) - This field contains the LSbit of CtmOffset. See description of CtmOffsetMsb.
    Bits: 12:11 PriBList(rw) - Primary Buffer list number associated. There are 4 buffer lists available, which contain buffer descriptors that are used to store packet data in internal/external MUs.
    Bits: 10:9  SecBList(rw) - Secondary Buffer list number associated. There are 4 buffer lists available, which contain buffer descriptors that are used to store packet data in internal/external MUs.
    Bits:  8:5  SplitLength(rw) - Encoded packet size used when deciding to split packets between CTM and internal/external MUs. Values 7,12-15 are reserved
    Bits:  4:0  BpeHead(rw) - Pointer to the first Buffer Pool Entry register in the list associated with this buffer pool.
*/
#define NFP3800_PCIE_DMA_DMA_BP_CFG(_x)                      (0x00000130 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_BLQ_BYPASS_ENA         BIT(24)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_BP_RSVD                BIT(23)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_BUF_PAD(_x)        (((_x) & 0xf) << 19)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_BUF_PAD_of(_x)     (((_x) >> 19) & 0xf)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_BUF_PAD_ENA        BIT(18)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_OFFSET_MSB(_x)     (((_x) & 0x7) << 15)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_OFFSET_MSB_of(_x)  (((_x) >> 15) & 0x7)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_CTM_OFFSET             BIT(13)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_PRI_BP_LIST(_x)        (((_x) & 0x3) << 11)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_PRI_BP_LIST_of(_x)     (((_x) >> 11) & 0x3)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_SEC_BP_LIST(_x)        (((_x) & 0x3) << 9)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_SEC_BP_LIST_of(_x)     (((_x) >> 9) & 0x3)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH(_x)       (((_x) & 0xf) << 5)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_of(_x)    (((_x) >> 5) & 0xf)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_256     (0)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_512     (1)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_1K      (2)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_2K      (3)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_4K      (4)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_8K      (5)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_16K     (6)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_6K      (8)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_10K     (9)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_12K     (10)
#define     NFP3800_PCIE_DMA_DMA_BP_CFG_SPLIT_LENGTH_14K     (11)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_BPE_HEAD(_x)           (((_x) & 0x1f) << 0)
#define   NFP3800_PCIE_DMA_DMA_BP_CFG_BPE_HEAD_of(_x)        (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: BLQueCtrl0Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO                     0x00000150
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_ENTRY_CNT(_x)  (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_ENTRY_CNT_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_HEAD_PTR(_x)   (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_HEAD_PTR_of(_x) (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_TAIL_PTR(_x)   (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_LO_BL_TAIL_PTR_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl0Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI                     0x00000154
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BLQ_EVENT_FULL_CNT(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BLQ_EVENT_FULL_CNT_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BD_FIFO_ENTRY_CNT(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BD_FIFO_ENTRY_CNT_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_FULL       BIT(7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_EMPTY      BIT(6)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE(_x)   (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE_256 (0)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE_512 (1)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE_1K  (2)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_QUE_SIZE_2K  (3)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_ENTRY_CNT(_x)  (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL0_HI_BL_ENTRY_CNT_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl1Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO                     0x00000158
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_ENTRY_CNT_LO(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_ENTRY_CNT_LO_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_HEAD_PTR(_x)   (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_HEAD_PTR_of(_x) (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_TAIL_PTR(_x)   (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_LO_BL_TAIL_PTR_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl1Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI                     0x0000015c
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BLQ_EVENT_FULL_CNT(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BLQ_EVENT_FULL_CNT_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BD_FIFO_ENTRY_CNT(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BD_FIFO_ENTRY_CNT_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_FULL       BIT(7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_EMPTY      BIT(6)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE(_x)   (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE_256 (0)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE_512 (1)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE_1K  (2)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_QUE_SIZE_2K  (3)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_ENTRY_CNT_HI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL1_HI_BL_ENTRY_CNT_HI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl2Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO                     0x00000160
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_ENTRY_CNT_LO(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_ENTRY_CNT_LO_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_HEAD_PTR(_x)   (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_HEAD_PTR_of(_x) (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_TAIL_PTR(_x)   (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_LO_BL_TAIL_PTR_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl2Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI                     0x00000164
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BLQ_EVENT_FULL_CNT(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BLQ_EVENT_FULL_CNT_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BD_FIFO_ENTRY_CNT(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BD_FIFO_ENTRY_CNT_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_FULL       BIT(7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_EMPTY      BIT(6)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE(_x)   (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE_256 (0)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE_512 (1)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE_1K  (2)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_QUE_SIZE_2K  (3)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_ENTRY_CNT_HI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL2_HI_BL_ENTRY_CNT_HI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl3Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO                     0x00000168
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_ENTRY_CNT_LO(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_ENTRY_CNT_LO_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_HEAD_PTR(_x)   (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_HEAD_PTR_of(_x) (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_TAIL_PTR(_x)   (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_LO_BL_TAIL_PTR_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl3Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI                     0x0000016c
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BLQ_EVENT_FULL_CNT(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BLQ_EVENT_FULL_CNT_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BD_FIFO_ENTRY_CNT(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BD_FIFO_ENTRY_CNT_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_FULL       BIT(7)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_EMPTY      BIT(6)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE(_x)   (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE_256 (0)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE_512 (1)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE_1K  (2)
#define     NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_QUE_SIZE_2K  (3)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_ENTRY_CNT_HI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BL_QUE_CTRL3_HI_BL_ENTRY_CNT_HI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BlqNullMuPtr - Value to use in MuPtr field when bypassing the BLQ in packet mode DMAs
    Bits: 28:0  BlqNullMuPtr(rw) - Programmable Null Memory Buffer Pointer.
*/
#define NFP3800_PCIE_DMA_BLQ_NULL_MU_PTR                     0x00000174
#define   NFP3800_PCIE_DMA_BLQ_NULL_MU_PTR_BLQ_NULL_MU_PTR(_x) (((_x) & 0x1fffffff) << 0)
#define   NFP3800_PCIE_DMA_BLQ_NULL_MU_PTR_BLQ_NULL_MU_PTR_of(_x) (((_x) >> 0) & 0x1fffffff)
/*----------------------------------------------------------------
  Register: PcieDmaRsvd[2] - Reserved
*/
#define NFP3800_PCIE_DMA_PCIE_DMA_RSVD(_x)                   (0x00000178 + (0x4 * ((_x) & 0x1)))
/*----------------------------------------------------------------
  Register: DMABpe[32]Cfg - DMA Buffer Pool Entry X Configuration
    Bits: 31:27 BpeNum(rwl) - Buffer Pool Entry Number. When the register is written this value is the latched version of the buffer pool register number 0-31. Used for debug purposes.
    Bits: 26:21 Ctm(rw) - CTM number to use
    Bits: 20:10 PktCredit(rw) - Configures the number of packets allocated to the CTM
    Bits:  9:0  BufCredit(rw) - Configures the number of buffer credits in 2K byte increments associated with the CTM. The msbit is the sign bit and must be cleared during configuration.
*/
#define NFP3800_PCIE_DMA_DMA_BPE_CFG(_x)                     (0x00000180 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_BPE_NUM(_x)           (((_x) & 0x1f) << 27)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_BPE_NUM_of(_x)        (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_CTM(_x)               (((_x) & 0x3f) << 21)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_CTM_of(_x)            (((_x) >> 21) & 0x3f)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_PKT_CREDIT(_x)        (((_x) & 0x7ff) << 10)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_PKT_CREDIT_of(_x)     (((_x) >> 10) & 0x7ff)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_BUF_CREDIT(_x)        (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_DMA_DMA_BPE_CFG_BUF_CREDIT_of(_x)     (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: DMAPmHeader[16]_DMAPMHeaderLo - Used to populate various packet mode meta-data fields
    Bits: 31:0  PMHeaderDataLo(rw) - Used to populate various packet mode meta-data fields
*/
#define NFP3800_PCIE_DMA_DMAPmHeader_PM_HEADER_DATA_LO(_x)   (0x00000200 + (0x8 * ((_x) & 0xf)))
#define   NFP3800_PCIE_DMA_DMAPMHEADER_PM_HEADER_DATA_LO_PM_HEADER_DATA_LO(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMAPMHEADER_PM_HEADER_DATA_LO_PM_HEADER_DATA_LO_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DMAPmHeader[16]_DMAPMHeaderHi - Used to populate various packet mode meta-data fields
    Bits: 31:0  PMHeaderDataHi(rw) - Used to populate various packet mode meta-data fields
*/
#define NFP3800_PCIE_DMA_DMAPmHeader_PM_HEADER_DATA_HI(_x)   (0x00000204 + (0x8 * ((_x) & 0xf)))
#define   NFP3800_PCIE_DMA_DMAPMHEADER_PM_HEADER_DATA_HI_PM_HEADER_DATA_HI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMAPMHEADER_PM_HEADER_DATA_HI_PM_HEADER_DATA_HI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: AbortStatus[8] - DMA Packet Mode Abort Status Register for DMA Context N and N + 1 where N = X
    Bits: 31:23 PckNumOdd(ro) - Latched packet number of an aborted packet. Only valid when the Valid field is set in this register.
    Bits: 22:17 CtmOdd(ro) - Latched CTM number of an aborted packet, Only valid when the Valid field is set in this register.
    Bits: 16    ValidOdd(rw1c) - When set the contents of this register contain the MuPtr, CTM number and packet number of an aborted packet.
    Bits: 15:7  PckNumEven(ro) - Latched packet number of an aborted packet. Only valid when the Valid field is set in this register.
    Bits:  6:1  CtmEven(ro) - Latched CTM number of an aborted packet, Only valid when the Valid field is set in this register.
    Bits:  0    ValidEven(rw1c) - When set the contents of this register contain the MuPtr, CTM number and packet number of an aborted packet.
*/
#define NFP3800_PCIE_DMA_ABORT_STATUS(_x)                    (0x00000280 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_ABORT_STATUS_PCK_NUM_ODD(_x)      (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_PCK_NUM_ODD_of(_x)   (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_CTM_ODD(_x)          (((_x) & 0x3f) << 17)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_CTM_ODD_of(_x)       (((_x) >> 17) & 0x3f)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_VALID_ODD            BIT(16)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_PCK_NUM_EVEN(_x)     (((_x) & 0x1ff) << 7)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_PCK_NUM_EVEN_of(_x)  (((_x) >> 7) & 0x1ff)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_CTM_EVEN(_x)         (((_x) & 0x3f) << 1)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_CTM_EVEN_of(_x)      (((_x) >> 1) & 0x3f)
#define   NFP3800_PCIE_DMA_ABORT_STATUS_VALID_EVEN           BIT(0)
/*----------------------------------------------------------------
  Register: DMABP[8]CtmCrThresh - NBI DMA Buffer Pool CTM Credit Thresholds.
    Bits: 29:20 Threshold2(rw) - Configures Threshold2 for the CTM credits. The packet color value is 2b11 if: credit < Threshold2. Only lower 9 bits are used, the top bit should be cleared.
    Bits: 19:10 Threshold1(rw) - Configures Threshold1 for the CTM credits. The packet color value is 2b10 if: Threshold2 <= credit < Threshold1. Only lower 9 bits are used, the top bit should be cleared.
    Bits:  9:0  Threshold0(rw) - Configures Threshold0 for the CTM credits. The packet color value is 2b01 if : Threshold1 <= credit < Threshold0, else it remains 2b00 if credit >= Threshold0. Only lower 9 bits are used, the top bit should be cleared.
*/
#define NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH(_x)             (0x000002a0 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD2(_x) (((_x) & 0x3ff) << 20)
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD2_of(_x) (((_x) >> 20) & 0x3ff)
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD1(_x) (((_x) & 0x3ff) << 10)
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD1_of(_x) (((_x) >> 10) & 0x3ff)
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD0(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_DMA_DMA_BP_CTMCR_THRESH_THRESHOLD0_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: DMATotalCreditCnt - Buffer Allocation Total Packet and Buffer Credits in use counters
    Bits: 31:16 TotalPktCredit(rw1c) - Contains the total number of packet credits in use by the DMA buffer allocation logic
    Bits: 15:0  TotalBufCredit(rw1c) - Contains the total number of buffer credits in use by the DMA buffer allocation logic
*/
#define NFP3800_PCIE_DMA_DMA_TOTAL_CREDIT_CNT                0x000002c0
#define   NFP3800_PCIE_DMA_DMA_TOTAL_CREDIT_CNT_TOTAL_PKT_CREDIT(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIE_DMA_DMA_TOTAL_CREDIT_CNT_TOTAL_PKT_CREDIT_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIE_DMA_DMA_TOTAL_CREDIT_CNT_TOTAL_BUF_CREDIT(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_DMA_DMA_TOTAL_CREDIT_CNT_TOTAL_BUF_CREDIT_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: DMAChksSumEna - Enable per Packet Mode DMA Context to calculate packet checksum
    Bits: 15:0  DMAChksumEna(rw) - There are 16-bits of DMAChksumEna, selected by the DMA Context of the Packet mode DMA. Set this bit to enable calculation of packet checksum. Clear this bit to disable checksum calculation
*/
#define NFP3800_PCIE_DMA_DMA_CHKSUM_ENA                      0x000002c4
#define   NFP3800_PCIE_DMA_DMA_CHKSUM_ENA_DMA_CHKSUM_ENA(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_DMA_DMA_CHKSUM_ENA_DMA_CHKSUM_ENA_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeCompConfig0 - Configures operation mode for PCIe component
    Bits: 30    QctlOneShotEnable(rw) - Automatically disable all notifications after the first event or RingPut, i.e. a one-shot mode
    Bits: 29    QctlCppCmdBusPrefDis(rw) - Disable the Qctl CLS Ring selection of the CPP Master Command Bus preference. When enabled, even CLS Ring Put requests will go out on Cmd Bus A/0, odd uses Cmd Bus B/1.
    Bits: 28    PCIeTargetComplIdEn(rw) - When set PCIe Target overrides Completer ID
    Bits: 25    PcietCppCmdBusPrefDis(rw) - Disable the PCIe Target Expansion BAR selection of the CPP Master Command Bus preference. When enabled, even Expansion BAR requests will go out on Cmd Bus A/0, odd uses Cmd Bus B/1.
    Bits: 24    ClrPciemHalmAriError(w1c) - Write 1 to clear the VF ARI Error status reg in PCIe Master
    Bits: 23    ClrDmaAriError(w1c) - Write 1 to clear the VF ARI Error status reg in DMA
    Bits: 22:20 PciemDMASramReadCredit(rw) - Sets the outstanding number of DMA reads to SRAM in increments of 8 with a starting offset of 7. Setting the value above 3 has no effect as the hardware limit of the credit tracker is set to 32. The minimum value of 0 equates to a credit limit of 7 requests.
    Bits: 19:12 PciemPciReadCredit(rw) - Controls the amout of outstanding PCIe read requests that can be issued. Value is in increments of 256 bytes. The minimum value that should be used is 4KB or 16(dec).
    Bits: 10    RC_mode_IO_CFG_write_CPL_rec(rw1c) - Pcie completed IO or Config Write operation.
    Bits:  9    Pcie_Msix_Pba_Debug(rw) - Provide ability to override read only behavior and temporarily allow write access of MSI-X PBA structure from the PCIe link for debug purpose only
    Bits:  7    PcieTrapDropped(w1c) - Indicates a trap request has been dropped due to exceeding size of targeted WorkQ spec'd by selected ExpBAR LengthSelect field.
    Bits:  6    PcieTrapTimeout(w1c) - Indicates that a trap read request has not completed in the amount of time spec'd by PcieTrapTypeTimeout register.
    Bits:  5:4  PcieTagCtrl(rw) - Controls the number of tags used for Master requests.
    Bits:  3    PciemWriteStatsEn(rw) - Enables the PCIe Master to count write data transmit cycles
    Bits:  2    PciemReadStatsEn(rw) - Enables the PCIe Master to count read data receive cycles
    Bits:  1    PcieCompConfig0Rsvd(rw) - Reserved. Software must write this bit to 0.
    Bits:  0    CPPAddrMode(rw) - Configure whether to interpret the CPP address bits as 32-bit or 40-bit.
*/
#define NFP3800_PCIEX_COMPCFG_CFG0                           0x00000000
#define   NFP3800_PCIEX_COMPCFG_CFG0_QCTL_ONE_SHOT_EN        BIT(30)
#define   NFP3800_PCIEX_COMPCFG_CFG0_QCTL_CMD_BUS_PREF_DIS   BIT(29)
#define   NFP3800_PCIEX_COMPCFG_CFG0_COMPL_ID_EN             BIT(28)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIET_CMD_BUS_PREF_DIS  BIT(25)
#define   NFP3800_PCIEX_COMPCFG_CFG0_CLR_PCIEM_ARI_ERR       BIT(24)
#define   NFP3800_PCIEX_COMPCFG_CFG0_CLR_DMA_ARI_ERR         BIT(23)
#define   NFP3800_PCIEX_COMPCFG_CFG0_DMA_SRAM_RD_CREDIT(_x)  (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_COMPCFG_CFG0_DMA_SRAM_RD_CREDIT_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIEM_RD_CREDIT(_x)     (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIEM_RD_CREDIT_of(_x)  (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_CFG0_RC_MODE_IO_CFG_WRITE_CPL_REC BIT(10)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_MSIX_PBA_DEBUG     BIT(9)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TRAP_DROPPED       BIT(7)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TRAP_TIMEOUT       BIT(6)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TAG_CTRL(_x)       (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TAG_CTRL_of(_x)    (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TAG_CTRL_DEFAULT (0)
#define     NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TAG_CTRL_32TAGS  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG0_PCIE_TAG_CTRL_16TAGS  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIEM_WR_STAT_EN        BIT(3)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIEM_RD_STAT_EN        BIT(2)
#define   NFP3800_PCIEX_COMPCFG_CFG0_PCIE_COMP_CFG0_RSVD     BIT(1)
#define   NFP3800_PCIEX_COMPCFG_CFG0_CPP_ADDR_MODE           BIT(0)
#define     NFP3800_PCIEX_COMPCFG_CFG0_CPP_ADDR_MODE_40      (0 << 0)
#define     NFP3800_PCIEX_COMPCFG_CFG0_CPP_ADDR_MODE_32      BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCompConfig1 - Configures operation mode for PCIe component
    Bits: 31:24 PCIeTargetComplIdBus(rw) - Sets the Completer ID Bus number to be used when in RC Mode or when override set
    Bits: 23:16 PCIeTargetComplIdDevFunc(rw) - Sets the Completer ID Dev and Function numbers to be used when in RC Mode or when override set
    Bits: 15:8  PCIeMasterReqIdBus(rw) - Sets the Requester ID Bus number to be used when PCIe Master generates requests in RC Mode
    Bits:  7:0  PCIeMasterReqIdFunc(rw) - Sets the Requester ID Function number to be used when PCIe Master generates requests in RC Mode
*/
#define NFP3800_PCIEX_COMPCFG_CFG1                           0x00000004
#define   NFP3800_PCIEX_COMPCFG_CFG1_COMPL_ID_BUS(_x)        (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_CFG1_COMPL_ID_BUS_of(_x)     (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_CFG1_COMPL_ID_DEV_FUNC(_x)   (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_COMPCFG_CFG1_COMPL_ID_DEV_FUNC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_CFG1_REQ_ID_BUS(_x)          (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_CFG1_REQ_ID_BUS_of(_x)       (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_CFG1_REQ_ID_FUNC(_x)         (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_CFG1_REQ_ID_FUNC_of(_x)      (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCompConfig2 - Configures operation mode for PCIe component
    Bits: 28:24 CppTargetSramReadCredit(rw) - Sets the number of outstanding read requests the CPP Target can make to the shared SRAM
    Bits: 10    CpptDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the CPP Target push data bus.
    Bits:  9    CpptDisPullDataError(rw) - When set data errors received from the CPP Target Pull Data bus are not forwarded to the internal target or PCIE Master Interface.
    Bits:  8    PciemDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the PCIE Master Interface.
    Bits:  7    PciemDisHalDataError(rw) - When set data errors received from the HAL interface are not forwarded to the internal target or CPP Target.
    Bits:  6    PcietDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the PCIE Target HAL interface.
    Bits:  5    PcietDisHalDataError(rw) - When set data errors received from the HAL interface are not forwarded to the CPP Master interface or internal target
    Bits:  4:0  PcieTargetSramReadCredit(rw) - Sets the number of outstanding read requests the PCIe Target can make to the shared SRAM
*/
#define NFP3800_PCIEX_COMPCFG_CFG2                           0x00000008
#define   NFP3800_PCIEX_COMPCFG_CFG2_CPPT_SRAM_CREDIT(_x)    (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_COMPCFG_CFG2_CPPT_SRAM_CREDIT_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_CFG2_CPPT_DIS_INT_DAT_ERR    BIT(10)
#define   NFP3800_PCIEX_COMPCFG_CFG2_CPPT_DIS_PULL_DAT_ERR   BIT(9)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIEM_DIS_INT_DAT_ERR   BIT(8)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIEM_DIS_HAL_DAT_ERR   BIT(7)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIET_DIS_INT_DAT_ERR   BIT(6)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIET_DIS_HAL_DAT_ERR   BIT(5)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIET_SRAM_CREDIT(_x)   (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_CFG2_PCIET_SRAM_CREDIT_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeCompConfig3 - Configures operation mode for PCIe component
    Bits: 31:24 DmaAriInError(ro) - DMA ARI number that last had an error
    Bits: 23:21 PciemHalComplCode(ro) - PCIe Master HAL Completion code that is latched when PciemAccessError is asserted
    Bits: 20    DmaFromAccessErrorVf(ro) - DMA FromPCIe Virtual Function Access Error.
    Bits: 19    DmaFromAccessErrorPf(ro) - DMA FromPCIe Physical Function Access Error.
    Bits: 18    DmaFromDescrOvflHi(ro) - DMA FromPcie High Priority Descriptor Queue Overflow.
    Bits: 17    DmaFromDescrOvflMed(ro) - DMA FromPcie Medium Priority Descriptor Queue Overflow.
    Bits: 16    DmaFromDescrOvflLo(ro) - DMA FromPcie Low Priority Descriptor Queue Overflow.
    Bits: 15    CppmIoArbMode(rw) - When set, changes arb scheme for granting internal IO device requests btwn CPP Target and PCIe Target from 75/25 to 50/50.
    Bits: 14    DmaToAccessErrorVf(ro) - DMA ToPCIe Virtual Function Access Error.
    Bits: 13    DmaToAccessErrorPf(ro) - DMA ToPCIe Physical Function Access Error.
    Bits: 12    DmaToDescrOvflHi(ro) - DMA ToPcie High Priority Descriptor Queue Overflow.
    Bits: 11    DmaToDescrOvflMed(ro) - DMA ToPcie Medium Priority Descriptor Queue Overflow.
    Bits: 10    DmaToDescrOvflLo(ro) - DMA ToPcie Low Priority Descriptor Queue Overflow.
    Bits:  9    PcietVfQctlRangeErr(rw1c) - PCIE Target VF Qctl access Que Out of Range w.r.t. CfgLUT entry.
    Bits:  8    CpptAccessError(rw1c) - Cpp Target Access Error Status bit indicates error received over the CPP intf.
    Bits:  7    MsixPfMaskChanged(rw1c) - Indicates that a PF MSI-X mask bit changed. SW should check the MSI-X PF Mask Changed Status register.
    Bits:  6    CpptPullDataError(rw1c) - Cpp Target Pull Data Error status bit indicates an error was received on the CPP Pull data interface
    Bits:  5    PciemAccessError(rw1c) - Pcie Master Access Error Status bit indicates access error received from the link.
    Bits:  4    PcietVfCfgLutInitErr(rw1c) - PCIE Target VF access through uninitialized CfgLUT Entry.
    Bits:  3    PciemHalDataError(rw1c) - PCIE Master detected a data error from the HAL interface.
    Bits:  2    PcietAccessError(rw1c) - Pcie Target Access Error Status bit indicates access error received from the link.
    Bits:  1    MsixVectorChangeStatus(rw1c) - Indicates that the MSI-X Vector Table has been updated. SW should check the MSI-X Vector Change Summary register.
    Bits:  0    PcietHalDataError(rw1c) - PCIE Target detected a data error from the HAL interface
*/
#define NFP3800_PCIEX_COMPCFG_CFG3                           0x0000000c
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_ARI_IN_ERROR(_x)    (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_ARI_IN_ERROR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIEM_HAL_COMPL_CODE(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIEM_HAL_COMPL_CODE_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_FROM_ACC_ERR_VF     BIT(20)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_FROM_ACC_ERR_PF     BIT(19)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_FRM_OVFL_HI         BIT(18)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_FRM_OVFL_MED        BIT(17)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_FRM_OVFL_LO         BIT(16)
#define   NFP3800_PCIEX_COMPCFG_CFG3_CPPM_IO_ARB_MODE        BIT(15)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_TO_ACC_ERR_VF       BIT(14)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_TO_ACC_ERR_PF       BIT(13)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_TO_OVFL_HI          BIT(12)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_TO_OVFL_MED         BIT(11)
#define   NFP3800_PCIEX_COMPCFG_CFG3_DMA_TO_OVFL_LO          BIT(10)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIET_VF_QCTL_ERR       BIT(9)
#define   NFP3800_PCIEX_COMPCFG_CFG3_CPPT_ACC_ERR            BIT(8)
#define   NFP3800_PCIEX_COMPCFG_CFG3_MSIX_PF_MASK_CHG        BIT(7)
#define   NFP3800_PCIEX_COMPCFG_CFG3_CPPT_PULL_DATA_ERR      BIT(6)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIEM_ACC_ERR           BIT(5)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIET_CFG_LUT_ERR       BIT(4)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIEM_HAL_DATA_ERR      BIT(3)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIET_ACC_ERR           BIT(2)
#define   NFP3800_PCIEX_COMPCFG_CFG3_MSIX_VECTOR_CHG_STAT    BIT(1)
#define   NFP3800_PCIEX_COMPCFG_CFG3_PCIET_HAL_DATA_ERR      BIT(0)
/*----------------------------------------------------------------
  Register: PcieRxMsgInt - PCIe Received Message Interrupts and Masks.
    Bits: 18    PcieSSPwrMsgIntMask(rw) - Set to mask PcieSSPwrMsgValid Interrupt.
    Bits: 17    PciePMEMsgIntMask(rw) - Set to mask PciePMEPwrMsgValid Interrupt.
    Bits: 16    PcieVMsgIntMask(rw) - Set to mask PciePwrVMsgValid Interrupt.
    Bits:  2    PcieSSPwrMsgValid(rw1c) - Interrupt status bit that indicates a PCIe Set Slot Power message has been received. The message is stored in the PcieSSPwrMsgHeader0-3 and PcieSSPwrMsgData CSRs.
    Bits:  1    PciePMEMsgValid(rw1c) - Interrupt status bit that indicates a PCIe PME message has been received. The message is stored in the PciePMEMsgHeader0-3 CSRs.
    Bits:  0    PcieVMsgValid(rw1c) - Interrupt status bit that indicates a PCIe vendor defined message has been received. The message is stored in the PcieVendorMsgHeader and PcieVendorMsgData CSRs.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT                0x00000010
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_SS_PWR_MSG_INT_MASK BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_PME_MSG_INT_MASK BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_VMSG_INT_MASK BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_SS_PWR_MSG_VALID BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_PME_MSG_VALID BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIE_RX_MSG_INT_PCIE_VMSG_VALID BIT(0)
/*----------------------------------------------------------------
  Register: PCIePciemStatTotal - Status of total cycle count since stats enable in PCIe Master interface
  Register: PCIePciemStatWrite - Status of write data cycle count since stats enable in PCIe Master interface
  Register: PCIePciemStatRead - Status of read data cycle count since stats enable in PCIe Master interface
    Bits: 31:0  PCIePciemStat(ro) - General use register.
*/
#define NFP3800_PCIEX_COMPCFG_PCIEMTOTAL                     0x00000018
#define NFP3800_PCIEX_COMPCFG_PCIEMWRITE                     0x0000001c
#define NFP3800_PCIEX_COMPCFG_PCIEMREAD                      0x00000020
#define   NFP3800_PCIEX_COMPCFG_PCIEPCIEMSTAT_PCIE_PCIEM_STAT(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEPCIEMSTAT_PCIE_PCIEM_STAT_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeFrmPcieDwrrArbCtrl - Control of From PCIe DMA DWRR Arbitration for selection of CPP port and Bus
    Bits: 28    BusGteArbDis(rw) - Set to disable selection of bus with greatest credit value
    Bits: 27    BusSelect(rw) - Controls which bus DWRR arbiter is selected when writing to configure DWRR weights. There are two Bus DWRR arbiters, one per port. Each port's bus DWRR arbiter selects between bus a/b for that port.
    Bits: 26    BusDwrrDisable(rw) - When set, the DWRR arbitration is disabled for both bus A and B selection. When clear, the DWRR weights are used to proportionaly control the arbitration process. This bit controls the disable for both port's bus select DWRR arbiters.
    Bits: 25    BusDwrrLoad(w1c) - When set the value of BusDwrrWrData is loaded into the selected credit allotment register. This bit self clears.
    Bits: 24    BusDwrrSelect(rw) - Used to select 1 of the 2 credit allotment registers
    Bits: 23:16 BusDwrrWrData(rw) - Controls the value written to the selected credit allotment register in the Bus select DWRR arbiter.
    Bits: 14    PortGteArbDis(rw) - Set to disable selection of port with greatest or equal credit value
    Bits: 13    PortDwrrDisable(rw) - When set, the DWRR arbitration is disabled for CPP port selection. When clear, the DWRR weights are used to proportionaly control the arbitration process.
    Bits: 12    PortDwrrLoad(w1c) - When set the value of BusDwrrWrData is loaded into the selected credit allotment register. This bit self clears.
    Bits: 11    PortDwrrSelect(rw) - Used to select 1 of the 2 credit allotment registers
    Bits: 10:0  PortDwrrWrData(rw) - Controls the value written to the selected credit allotment register in the Port select DWRR arbiter.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL     0x00000024
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_GTE_ARB_DIS BIT(28)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_SELECT BIT(27)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_DWRR_DISABLE BIT(26)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_DWRR_LOAD BIT(25)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_DWRR_SELECT BIT(24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_DWRR_CONFIG_WR_DATA(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_BUS_DWRR_CONFIG_WR_DATA_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_GTE_ARB_DIS BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_DWRR_DISABLE BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_DWRR_LOAD BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_DWRR_SELECT BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_DWRR_CONFIG_WR_DATA(_x) (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_FRMPCIE_DWRR_ARB_CTRL_PORT_DWRR_CONFIG_WR_DATA_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: PCIeARIError0 - Status of Virtual Functions that had errors
  Register: PCIeARIError1 - Status of Virtual Functions that had errors
  Register: PCIeARIError2 - Status of Virtual Functions that had errors
  Register: PCIeARIError3 - Status of Virtual Functions that had errors
  Register: PCIeARIError4 - Status of Virtual Functions that had errors
  Register: PCIeARIError5 - Status of Virtual Functions that had errors
  Register: PCIeARIError6 - Status of Virtual Functions that had errors
  Register: PCIeARIError7 - Status of Virtual Functions that had errors
    Bits: 31:0  PCIeAriErr(rw1c) - ARI Error status.
*/
#define NFP3800_PCIEX_COMPCFG_ARIERR0                        0x00000028
#define NFP3800_PCIEX_COMPCFG_ARIERR1                        0x0000002c
#define NFP3800_PCIEX_COMPCFG_ARIERR2                        0x00000030
#define NFP3800_PCIEX_COMPCFG_ARIERR3                        0x00000034
#define NFP3800_PCIEX_COMPCFG_ARIERR4                        0x00000038
#define NFP3800_PCIEX_COMPCFG_ARIERR5                        0x0000003c
#define NFP3800_PCIEX_COMPCFG_ARIERR6                        0x00000040
#define NFP3800_PCIEX_COMPCFG_ARIERR7                        0x00000044
#define   NFP3800_PCIEX_COMPCFG_PCIEARIERR_PCIE_ARI_ERR(_x)  (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEARIERR_PCIE_ARI_ERR_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcietVFerror - Pcie target VF access error
    Bits:  7:0  PcietVFerror(ro) - Pcie target VF access error function number
*/
#define NFP3800_PCIEX_COMPCFG_VF_ERR                         0x0000005c
#define   NFP3800_PCIEX_COMPCFG_VF_ERR_VF_ERR(_x)            (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_VF_ERR_VF_ERR_of(_x)         (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCntrlrConfig0 - Selects operation mode for PCIe DMA controller and PCIe Master Interface
    Bits: 31:26 DmaSplitWrite512Thresh(rw) - When DmaSplitWrite512Addr=0, and DMA Length > (DmaSplitWrite512Thresh*64B + 64B), split the DMA write requests when the PCIe address crosses a 512 byte address boundary, else split write requests when the PCIe address crosses a 4K address boundary (max transfer size is 512B). If this field is 0, then DMA write splitting is controlled by DmaSplitWrite512Addr.
    Bits: 25:20 DmaSplitReadMrrsThresh(rw) - When DmaSplitReadMrrsAddr=0, and DMA Length > (DmaSplitReadMrrsThresh*64B + 64B), split the DMA read requests when the PCIe address crosses a max read request sized address boundary, else split read requests when the PCIe address crosses a 4K address boundary (max read request is controlled by MRRS). If this field is 0, then DMA read splitting is controlled by DmaSplitReadMrrsAddr.
    Bits: 19    DmaSplitWrite512Addr(rw) - Setting this bit forces the ToPCIe DMA engine to split write requests when the PCIe Address crosses a 512 byte address boundary. When clear the ToPCIe DMA engine splits write requests when the PCIe address crosses a 4K address boundry else the size is a max of 512 bytes. Note: The PCIe controller splits 512B writes into MPS sized writes.
    Bits: 18    DmaSplitReadMrrsAddr(rw) - Setting this bit forces the FromPCIe DMA engine to split read requests when the PCIe address crosses a max read request sized address boundary. When clear the FromPCIe DMA engine splits read requests when the PCIe address crosses a 4K address boundary.
    Bits: 17    DmaDisBpCreditChk(rw) - Setting this bit disabled the DMA logic from checking a buffer pools credits prior to allowing a DMA Packet Mode Start Stage Descriptor from being processed. Normally this bit should be cleared as this check prevents buffer pools with low credits from blocking non packet mode DMAs from higher priority queues from being processed. This bit only effects the FromPCIe DMA engine
    Bits: 16    DmaFragSize2kOvrd(rw) - Setting this bit enables 2KB fragment size with DmaFragThreshold = 2KB or 3KB
    Bits: 15    DmaFragDisAlignFrmPcie(rw) - Setting this bit disables aligning FromPCIe 1st DMA Fragments PCIe address to the DmaFragSize address boundary.
    Bits: 14    DmaFragDisAlignToPcie(rw) - Setting this bit disables aligning ToPCIe 1st DMA Fragments PCIe address to the DmaFragSize address boundary.
    Bits: 13:12 DmaFragThreshold(rw) - Threshold at which DMAs are fragmented.
    Bits: 11    DmaFragSize(rw) - Sets the fragment size of the DMA.
    Bits: 10    DmaFragEnableFrmPcie(rw) - Setting this bit enabled the DMA engine to fragment FrmPCIe (Reads) DMAs larger than the DmaMaxFragSize setting.
    Bits:  9    DmaFragEnableToPcie(rw) - Setting this bit enabled the DMA engine to fragment ToPCIe (Writes) DMAs larger than the DmaMaxFragSize setting.
    Bits:  8    DmaFragEnablePacketMode(rw) - Setting this bit along with the DmaFragEnableFrmPcie bit enables FromPcie Packet Mode DMAs to be fragmented. Clearing this bit disables packet mode DMAs from being fragmented.
    Bits:  6    MasterHoldIfDisabled(rw) - When in Endpoint mode, the PCIe Master logic hold back all PCIe Master transactions when this bit is set and the FUNCTION_STATUS bit 2 from the PCIe core indicates the Bus Master is not enabled. The MasterDropIfDisabled must also be cleared.
    Bits:  4    MasterDropIfDisabled(rw) - When in Endpoint mode, the PCIe Master logic drops all PCIe Master transactions when this bit is set and the FUNCTION_STATUS bit 2 from the PCIe core indicates the Bus Master is not enabled. This bit has no effect in Root Complex mode.
    Bits:  0    ChksumByteSwapEn(rw) - Set this bit to byte swap the checksum data
*/
#define NFP3800_PCIEX_COMPCFG_CNTRLR0                        0x00000060
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_WRITE_512_THRESH(_x) (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_WRITE_512_THRESH_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_READ_MRRS_THRESH(_x) (((_x) & 0x3f) << 20)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_READ_MRRS_THRESH_of(_x) (((_x) >> 20) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_WRITE_512B_ADDR BIT(19)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_SPLIT_READ_MRRS_ADDR BIT(18)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_DIS_BP_CREDIT_CHK BIT(17)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_SIZE_2K_OVRD BIT(16)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_DIS_ALIGN_FRMPCIE BIT(15)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_DIS_ALIGN_TOPCIE BIT(14)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_THRESHOLD(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_THRESHOLD_of(_x) (((_x) >> 12) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_THRESHOLD_1KB (0)
#define     NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_THRESHOLD_2KB (1)
#define     NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_THRESHOLD_3KB (2)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_SIZE        BIT(11)
#define     NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_SIZE_512  (0 << 11)
#define     NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_SIZE_1K   BIT(11)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_ENABLE_FRM_PCIE BIT(10)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_ENABLE_TO_PCIE BIT(9)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_DMA_FRAG_ENABLE_PKT_MODE BIT(8)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_MASTER_HOLD_IF_DISABLED BIT(6)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_MASTER_DROP_IF_DISABLED BIT(4)
#define   NFP3800_PCIEX_COMPCFG_CNTRLR0_CHKSUM_BYTE_SWAP_EN  BIT(0)
/*----------------------------------------------------------------
  Register: QueueRingCfg_[8] - Queue Controller registers to define RingPut operation upon queue status change
    Bits: 31:26 RingClsIsl(rw) - CLS Island ID for Ring Op
    Bits: 25:22 RingSigMaster(rw) - CPP Signal Master to send for CLS Ring Op
    Bits: 21:15 RingSigRef(rw) - CPP Signal Ref to send for CLS Ring Op
    Bits: 14:13 RingToken(rw) - CPP Token to send for CLS Ring Op
    Bits: 12:9  RingTarget(rw) - CPP Target ID to send for CLS Ring Op
    Bits:  8:4  RingAction(rw) - CPP Action to send for CLS Ring Op
    Bits:  3:0  RingIndex(rw) - Ring index determines which ring
*/
#define NFP3800_PCIEX_COMPCFG_QUE_RING_CFG(_x)               (0x00000064 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_CLS_ISLE(_x) (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_CLS_ISLE_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_SIG_MASTER(_x) (((_x) & 0xf) << 22)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_SIG_MASTER_of(_x) (((_x) >> 22) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_SIG_REF(_x) (((_x) & 0x7f) << 15)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_SIG_REF_of(_x) (((_x) >> 15) & 0x7f)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_TOKEN(_x)  (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_TOKEN_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_TARGET(_x) (((_x) & 0xf) << 9)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_TARGET_of(_x) (((_x) >> 9) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_ACTION(_x) (((_x) & 0x1f) << 4)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_ACTION_of(_x) (((_x) >> 4) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_INDEX(_x)  (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_COMPCFG_QUE_RING_CFG_RING_INDEX_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeCompConfig4 - Configures operation mode for PCIe component, Expansion ROM Expansion BAR access
    Bits: 15:14 Pf7_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits: 13:12 Pf6_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits: 11:10 Pf5_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  9:8  Pf4_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  7:6  Pf3_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  5:4  Pf2_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  3:2  Pf1_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  1:0  Pf0_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
*/
#define NFP3800_PCIEX_COMPCFG_CFG4                           0x00000084
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF7_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF7_EXP_ROM_SEL_of(_x)  (((_x) >> 14) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF7_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF7_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF7_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF6_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF6_EXP_ROM_SEL_of(_x)  (((_x) >> 12) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF6_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF6_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF6_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF5_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF5_EXP_ROM_SEL_of(_x)  (((_x) >> 10) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF5_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF5_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF5_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF4_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF4_EXP_ROM_SEL_of(_x)  (((_x) >> 8) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF4_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF4_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF4_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF3_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF3_EXP_ROM_SEL_of(_x)  (((_x) >> 6) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF3_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF3_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF3_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF2_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF2_EXP_ROM_SEL_of(_x)  (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF2_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF2_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF2_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF1_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF1_EXP_ROM_SEL_of(_x)  (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF1_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF1_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF1_EXP_ROM_SEL_BAR4  (2)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF0_EXP_ROM_SEL(_x)     (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_CFG4_PF0_EXP_ROM_SEL_of(_x)  (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF0_EXP_ROM_SEL_BAR0  (0)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF0_EXP_ROM_SEL_BAR2  (1)
#define     NFP3800_PCIEX_COMPCFG_CFG4_PF0_EXP_ROM_SEL_BAR4  (2)
/*----------------------------------------------------------------
  Register: PcieTrapTypeTimeout - 32-bit Cycle counter used to detect when trapped PCIe mem read request has been lost and completion should be aborted
    Bits:  9:8  TrapTimeoutRange(rw) - A timeout granularity setting used as a multiplier with the TrapTimeout field value for all Trap VirtIO read requests, programmed by SW, represented in microseconds. Read requests that timeout will complete with an error.
    Bits:  4:0  TrapTimeout(rw) - The count value for Trap VirtIO read requests, programmed by SW, multiplied by the TrapTimeoutRange used to calculate the approx number of microseconds for a timeout. NOTE: Valid values are 0x0 through 0x1e. A value of 0 disables the timeout check. NOTE: Read requests that timeout will complete with a Completer Abort.
*/
#define NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT                   0x00000088
#define   NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_RANGE(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_RANGE_of(_x) (((_x) >> 8) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_RANGE_1US (0)
#define     NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_RANGE_8US (1)
#define     NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_RANGE_128US (2)
#define   NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_TRAP_TIMEOUT_TRAP_TIMEOUT_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIePerfCfg - Performance Mux Control Register
    Bits: 20:18 AuxSelect(None) - Module select for module 3.
    Bits: 17:14 HiMuxSelect(None) - High 16 to 1 mux select
    Bits: 13:10 MidMuxSelect(None) - Middle 16 to 1 mux select.
    Bits:  9:6  LowMuxSelect(None) - Low 16 to 1 mux select.
    Bits:  5:4  LaneSelectHi(None) - Lane select for bits [32;64]
    Bits:  3:2  LaneSelectMid(None) - Lane select for bits [32;32]
    Bits:  1:0  LaneSelectLo(None) - Lane select for bits [32;0]
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG                  0x00000100
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_AUX_SELECT(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_AUX_SELECT_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_HI_MUX_SELECT(_x) (((_x) & 0xf) << 14)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_HI_MUX_SELECT_of(_x) (((_x) >> 14) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_MID_MUX_SELECT(_x) (((_x) & 0xf) << 10)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_MID_MUX_SELECT_of(_x) (((_x) >> 10) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LOW_MUX_SELECT(_x) (((_x) & 0xf) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LOW_MUX_SELECT_of(_x) (((_x) >> 6) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI_DESELECT (0)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI_LOWSELECT (1)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI_MIDSELECT (2)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_HI_HISELECT (3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID_DESELECT (0)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID_LOWSELECT (1)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID_MIDSELECT (2)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_MID_HISELECT (3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO_DESELECT (0)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO_LOWSELECT (1)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO_MIDSELECT (2)
#define     NFP3800_PCIEX_COMPCFG_PCIE_PERF_CFG_LANE_SELECT_LO_HISELECT (3)
/*----------------------------------------------------------------
  Register: PCIeSpare2[2] - Spare register address, no hw implemented
  Register: PCIeSpare3[6] - Spare register address, no hw implemented
  Register: PCIeSpare41 - Spare register address, no hw implemented
  Register: PCIeSpare4 - Spare register address, no hw implemented
*/
#define NFP3800_PCIEX_COMPCFG_PCIESPARE2(_x)                 (0x00000108 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_COMPCFG_PCIESPARE3(_x)                 (0x000001c0 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_COMPCFG_PCIESPARE41                    0x000001dc
#define NFP3800_PCIEX_COMPCFG_PCIESPARE4                     0x000001e0
/*----------------------------------------------------------------
  Register: PcieEventIntFuncMap_[32] - Defines the MSI/MSIX/Legacy function number and message attributes for event filter X
    Bits: 31:9  Reserved(rw) - Reserved.
    Bits:  8    MaskEvent(rw) - Specifies to mask the event from generating an MSI.
    Bits:  7:0  FunctionNumber(rw) - Specifies the function number to be sent as ReqID with MSI/MSIX/Legacy message or when used with Legacy interrupts the physical function number associated with the Interrupt request. Physical Functions are in the range of 0x0-0x3. Only physical functions allowed for MSIX and Legacy
*/
#define NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP(_x)              (0x00000110 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP_RESERVED(_x)   (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP_RESERVED_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP_MASK           BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP_FUNCTION(_x)   (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCI_EVENT_MAP_FUNCTION_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxPendBitArray_[8] - Shows the status of 32 of the 256 MSI-X interrupt vectors Pending Bit Array, PBA
    Bits: 31:0  MsixPba(ro) - Status of the MSI-X Pending Bit Array.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PBA(_x)                   (0x00000190 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_PCIE_PBA_MSIX_PBA(_x)        (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PBA_MSIX_PBA_of(_x)     (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieVendorMsgCtrl - PCIe Vendor Message Control Register
    Bits: 31    Full(ro) - When set all 32 buffers are occupied with vendor defined messages. When clear the SRAM buffer is not full
    Bits: 30    Empty(ro) - When set no vendor defined messages are currently stored in SRAM,. When clear there is at least one message stored in the SRAM buffer
    Bits: 28:24 AddToRdPtr(wo) - Software writes a value to this field to increment the read pointer by n+1 and free up SRAM buffers. The write will also update the EntryCnt, Full and Empty flags. Software should not write a value larger than the number of entries currently in the buffer or an underflow error assertion will fire and the read pointer increment will be limted by the current EntryCnt value. Software should only update the read pointer after the vendor defined messages have been read from SRAM.
    Bits: 21:16 EntryCnt(ro) - Indicates the number of vendor defined messages currently stored in SRAM
    Bits: 12:8  WrPtr(ro) - Write Pointer increments when a Vendor Defined Message has been written in the SRAM buffer
    Bits:  4:0  RdPtr(ro) - Read pointer. Software increments this pointer by writing to the RdPtrInc Field
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL           0x000001b0
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_FULL    BIT(31)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_EMPTY   BIT(30)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_ADD_TO_RD_PTR(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_ADD_TO_RD_PTR_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_ENTRY_CNT(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_ENTRY_CNT_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_WR_PTR(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_WR_PTR_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_RD_PTR(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_CTRL_RD_PTR_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PcieVendorMsgStat - PCIe Vendor Message Statistic Register
    Bits: 31:24 DropCnt(rc) - Vendor Defined Message Drop Counter. Increments when a vendor defined message is dropped due to lack of SRAM buffers. This counter saturates at all 1's and clears on reads
    Bits: 23:0  RxCnt(rc) - Vendor Defined Message receive counter. Increments after a vendor defined message is received and stored in SRAM. This counter clears on reads.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_STAT           0x000001b4
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_STAT_DROP_CNT(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_STAT_DROP_CNT_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_STAT_RX_CNT(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VENDOR_MSG_STAT_RX_CNT_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: PcieMasterSwCreditLimit - PCIe Master Sw Credit Limit Register
    Bits: 12:9  pciem_compl_cppt_fifo_sw_credit_limit(rw) - Software credit limit for the pcie master compl cppt fifo
    Bits:  8:6  pciem_compl_dma_sw_credit_limit(rw) - Software credit limit for the pcie master compl dma fifo
    Bits:  5:3  pciem_compl_aligned_sw_credit_limit(rw) - Software credit limit for the pcie master compl aligned fifo
    Bits:  2:0  pciem_halm_req_fifo_sw_credit_limit(rw) - Software credit limit for the pcie master hal master req fifo
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT    0x000001bc
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_CPPT_FIFO_SW_CREDIT_LIMIT(_x) (((_x) & 0xf) << 9)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_CPPT_FIFO_SW_CREDIT_LIMIT_of(_x) (((_x) >> 9) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_DMA_FIFO_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_DMA_FIFO_SW_CREDIT_LIMIT_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_ALIGNED_FIFO_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_COMPL_ALIGNED_FIFO_SW_CREDIT_LIMIT_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_HALM_REQ_FIFO_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MASTER_SW_CREDIT_LIMIT_PCIEM_HALM_REQ_FIFO_SW_CREDIT_LIMIT_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieRoceCounters - Pcie Roce doorbell statistics
    Bits: 31:16 PcieDoorbellDropCount(rc) - Counter that keeps a track of the dropped doorbells. Saturates if not read
    Bits: 15:0  PcieDoorBellCount(rc) - Counter that keeps a track of the number of doorbells. Saturates if not read
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_ROCE_COUNTERS             0x000001e4
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_COUNTERS_PCIE_DOORBELL_DROP_COUNT(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_COUNTERS_PCIE_DOORBELL_DROP_COUNT_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_COUNTERS_PCIE_DOORBELL_COUNT(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_COUNTERS_PCIE_DOORBELL_COUNT_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PcieRoceAutoPushInterval - Waiting time before sending second cycle autopush with zeros
    Bits: 25:23 PcieRoceDoorbellFifoSWCredits(rw) - Software credit limit for the Roce Doorbell FIFO.
    Bits: 21:16 PcieRoceWorkqFifoSWCredits(rw) - Software credit limit for the Roce workq FIFO.
    Bits:  7:0  PcieRoceAutoPushInterval(rw) - Number of cycles to wait for the second doorbell after the first one, before sending sending zeroes on second autopush cycle
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL    0x000001e8
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_DOORBELL_FIFO_SW_CREDITS(_x) (((_x) & 0x7) << 23)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_DOORBELL_FIFO_SW_CREDITS_of(_x) (((_x) >> 23) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_WORKQ_FIFO_SW_CREDITS(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_WORKQ_FIFO_SW_CREDITS_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_AUTO_PUSH_INTERVAL(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_AUTOPUSH_INTERVAL_PCIE_ROCE_AUTO_PUSH_INTERVAL_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PcieRoceInterruptStatus - Information regarding the event
    Bits: 15    PcieRoceWorkqState(ro) - 0 -> Workq FIFO stores Threads. 1 -> Workq FIFO stores doorbells
    Bits: 14:8  PcieRoceWorkqFifoStatus(ro) - Indicates the level of the WorkQ FIFO.
    Bits:  7    PcieRoceEventMaskDropDoorbells(rw) - Mask bit for Dropping Doorbells event.
    Bits:  6    PcieRoceEventMaskDropThreads(rw) - Mask bit for Dropping Threads event.
    Bits:  5    PcieRoceEventMaskFull(rw) - Mask bit for WorkQ FIFO Full event.
    Bits:  4    PcieRoceEventMask34Full(rw) - Mask bit for WorkQ FIFO 3/4th Full event.
    Bits:  3    PcieRoceDropDoorbells(rw1c) - Indicates that the WorkQ FIFO is Full of doorbells and the doorbells are being dropped. Write 1 to clear.
    Bits:  2    PcieRoceDropThreads(rw1c) - Indicates that the WorkQ FIFO is Full and the incoming threads is being dropped. Write 1 to clear.
    Bits:  1    PcieRoceWorkqFull(rw1c) - Indicates that the WorkQ FIFO is Full. Write 1 to clear.
    Bits:  0    PcieRoceWorkq34Full(rw1c) - Indicates that the WorkQ FIFO is 3/4th Full. Write 1 to clear.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS     0x000001ec
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_WORKQ_STATE BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_WORKQ_FIFO_STATUS(_x) (((_x) & 0x7f) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_WORKQ_FIFO_STATUS_of(_x) (((_x) >> 8) & 0x7f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_EVENT_MASK_DROP_DOORBELLSS BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_EVENT_MASK_DROP_THREADS BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_EVENT_MASK_FULL BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_EVENT_MASK_34_FULL BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_DROP_DOORBELLS BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_DROP_THREADS BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_WORKQ_FULL BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIE_ROCE_INTERRUPT_STATUS_PCIE_ROCE_WORKQ_34_FULL BIT(0)
/*----------------------------------------------------------------
  Register: PCIePfMSIxMaskChange - Summary register of the change in the PF MSI-X mask
    Bits:  7:0  MsixPfMaskChngStatus(rc) - Status of the MSI-X PF Mask Change, where each bit represents a PF Mask change state, NOTE: changed status not the actual mask value. These bits are clear-on-read.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PF_MSIX_MASK_CHANGE       0x000001f8
#define   NFP3800_PCIEX_COMPCFG_PCIE_PF_MSIX_MASK_CHANGE_MSIX_PF_MASK_CHG_STAT(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PF_MSIX_MASK_CHANGE_MSIX_PF_MASK_CHG_STAT_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxSummary - Summary register where each bit is a wire-OR of 32 of the 256 status bits as a hint to SW for which register(s) to read
    Bits: 15:8  MsixPbaIdx(ro) - Indirect status summary of the MSI-X PBA registers, where 1 bit represents 32 PBA status bits. Bit 0 being set would indicate that at least 1 bit is set for PBA bits 0 thru 31. Bit 1 represents PBA 32 thru 63, and so on.
    Bits:  7:0  MsixVectorChngIdx(ro) - Indirect status summary of the MSI-X Vector Change registers, where 1 bit represents 32 mask change status bits. Bit 0 being set would indicate that at least 1 bit is set for MSI-X Vector Change bits 0 thru 31. Bit 1 represents Vectors 32 thru 63, and so on.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_MSIX_SUMMARY              0x000001fc
#define   NFP3800_PCIEX_COMPCFG_PCIE_MSIX_SUMMARY_MSIX_PBA_IDX(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MSIX_SUMMARY_MSIX_PBA_IDX_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MSIX_SUMMARY_MSIX_VECTOR_CHG_IDX(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_MSIX_SUMMARY_MSIX_VECTOR_CHG_IDX_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxVectorMaskChange_[8] - Status of 32 of the 256 MSI-X Vector Mask bits that have recently changed
    Bits: 31:0  MsixMaskChng(rc) - Status of the MSI-X Vector Mask Change. Clear on read.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_VMCHNG(_x)                (0x00000200 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_PCIE_VMCHNG_MSIX_MASK_CHNG(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_VMCHNG_MSIX_MASK_CHNG_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader0 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader0 - The TLP Header of the received Set Slot Power message
    Bits: 31:16 ReqId(ro) - Received message header, Requestor ID field.
    Bits: 15:8  Tag(ro) - Received message header, Tag field
    Bits:  7:0  MsgCode(ro) - Received message header Message, Code field
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_MSG_HDR0              0x00000240
#define NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_HDR0            0x00000250
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_REQ_ID(_x)    (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_REQ_ID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_TAG(_x)       (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_TAG_of(_x)    (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_MSG_CODE(_x)  (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER0_MSG_CODE_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader1 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader1 - The TLP Header of the received Set Slot Power message
    Bits: 20:18 Type(ro) - Received message header, Transaction Type field
    Bits: 17:15 Tclass(ro) - Received message header, Traffic Class field.
    Bits: 14:12 Attr(ro) - Received message header, Attribute field.
    Bits:  9:0  Length(ro) - Received message header length field. Length is in bytes.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_MSG_HDR1              0x00000244
#define NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_HDR1            0x00000254
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_TYPE(_x)      (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_TYPE_of(_x)   (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_TCLASS(_x)    (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_TCLASS_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_ATTR(_x)      (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_ATTR_of(_x)   (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_LENGTH(_x)    (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER1_LENGTH_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader2 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader2 - The TLP Header of the received Set Slot Power message
    Bits: 31:0  HeaderBytes12_15(ro) - Received message header bytes {12,13,14,15}
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_MSG_HDR2              0x00000248
#define NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_HDR2            0x00000258
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER2_HB_12_15(_x)  (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER2_HB_12_15_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader3 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader3 - The TLP Header of the received Set Slot Power message
    Bits: 31:0  HeaderBytes8_11(ro) - Received message header bytes {8,9,10,11}
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_MSG_HDR3              0x0000024c
#define NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_HDR3            0x0000025c
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER3_HB_8_11(_x)   (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEMSGHEADER3_HB_8_11_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieSSPwrMsgData - The Data portion of the set slot power message data.
    Bits: 31:0  PcieMsgData(ro) - The data payload of the received message
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_DATA            0x00000260
#define   NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_DATA_PCIE_MSG_DATA(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_SSPWR_MSG_DATA_PCIE_MSG_DATA_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePmeRegister0 - Indicates the activity in pcie. A value of zero indicate everything is idle.
    Bits: 31    DmaItpStateFsmBusy(ro) - dma_itp_state_fsm_busy
    Bits: 30    DmaRtpStateFsmBusy(ro) - dma_rtp_state_fsm_busy
    Bits: 29    DmaIfpStateFsmBusy(ro) - dma_ifp_state_fsm_busy
    Bits: 28    DmaRfpStateFsmBusy(ro) - dma_rfp_state_fsm_busy
    Bits: 27    DmaRfpCStateFsmBusy(ro) - dma_rfp_c_state_fsm_busy
    Bits: 26    DmaRtpCStateFsmBusy(ro) - dma_rtp_c_state_fsm_busy
    Bits: 25    AllTokensFree(ro) - all_tokens_free
    Bits: 24    AllContextsFree(ro) - all_contexts_free
    Bits: 23    FrmPcieFifoEmpty(ro) - frm_pcie_fifo_empty
    Bits: 22    ToPcieFifoEmpty(ro) - to_pcie_fifo_empty
    Bits: 21    ToPcieCompletionFifoEmpty(ro) - to_pcie_completion_fifo_empty
    Bits: 20    FrmPcieCompletionFifoEmpty(ro) - frm_pcie_completion_fifo_empty
    Bits: 19    FrmPciePmCmdFifoEmpty(ro) - frm_pcie_pm_cmd_fifo_empty
    Bits: 18    PciemPcieMasterHalmComplReorderFifoArrayValid(ro) - pciem_pcie_master_halm_compl_reorder_fifo_array_valid
    Bits: 17    PciemPciemHalmReqFifoValid(ro) - pciem_pciem_halm_req_fifo_valid
    Bits: 16    PciemSharedMemReqFifoValid(ro) - pciem_shared_mem_req_fifo_valid
    Bits: 15    PciemPciemCpptReqFifoValid(ro) - pciem_pciem_cppt_req_fifo_valid
    Bits: 14    PciemPciemHalmReqStateIdle(ro) - pciem_pciem_halm_req_state_idle
    Bits: 13    CpptCommandHandlerCmdValid(ro) - cppt_command_handler_cmd_valid
    Bits: 12    CpptPush2targetInletFifoValid(ro) - cppt_push2target_inlet_fifo_valid
    Bits: 11    CpptCpptDequeuedCmdFifoValid(ro) - cppt_cppt_dequeued_cmd_fifo_valid
    Bits: 10    CpptSharedMemReqFifoValid(ro) - cppt_shared_mem_req_fifo_valid
    Bits:  9    CpptSmPushIdFifoValid(ro) - cppt_sm_push_id_fifo_valid
    Bits:  8    CpptSmPushDataFifoValid(ro) - cppt_sm_push_data_fifo_valid
    Bits:  7    CpptIoselSmPushDataFifoValid(ro) - cppt_iosel_sm_push_data_fifo_valid
    Bits:  6    CpptPciemPushDataFifoValid(ro) - cppt_pciem_push_data_fifo_valid
    Bits:  5    CpptCpptComplStateIdle(ro) - cppt_cppt_compl_state_idle
    Bits:  4    PcietWriteSharedMemBusy(ro) - pciet_write_shared_mem_busy
    Bits:  3    PcietPcieReqStateFsmBusy(ro) - pciet_pcie_req_state_fsm_busy
    Bits:  2    PcietPcietSramReadStateFsmBusy(ro) - pciet_pciet_sram_read_state_fsm_busy
    Bits:  1    PcietPcietReadComplStateFsmBusy(ro) - pciet_pciet_read_compl_state_fsm_busy
    Bits:  0    PcietHalComplCstateBusy(ro) - pciet_hal_compl_cstate_busy
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0             0x00000270
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_ITP_STATE_FSM_BUSY BIT(31)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_RTP_STATE_FSM_BUSY BIT(30)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_IFP_STATE_FSM_BUSY BIT(29)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_RFP_STATE_FSM_BUSY BIT(28)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_RFP_C_STATE_FSM_BUSY BIT(27)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_DMA_RTP_C_STATE_FSM_BUSY BIT(26)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_ALL_TOKENS_FREE BIT(25)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_ALL_CONTEXTS_FREE BIT(24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_FRM_PCIE_FIFO_EMPTY BIT(23)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_TO_PCIE_FIFO_EMPTY BIT(22)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_TO_PCIE_COMPLETION_FIFO_EMPTY BIT(21)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_FRM_PCIE_COMPLETION_FIFO_EMPTY BIT(20)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_FRM_PCIE_PM_CMD_FIFO_EMPTY BIT(19)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIEM_PCIE_MASTER_HALM_COMPL_REORDER_FIFO_ARRAY_VALID BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIEM_PCIEM_HALM_REQ_FIFO_VALID BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIEM_SHARED_MEM_REQ_FIFO_VALID BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIEM_PCIEM_CPPT_REQ_FIFO_VALID BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIEM_PCIEM_HALM_REQ_STATE_IDLE BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_COMMAND_HANDLER_CMD_VALID BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_PUSH2TARGET_INLET_FIFO_VALID BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_CPPT_DEQUEUED_CMD_FIFO_VALID BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_SHARED_MEM_REQ_FIFO_VALID BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_SM_PUSH_ID_FIFO_VALID BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_SM_PUSH_DATA_FIFO_VALID BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_IOSEL_SM_PUSH_DATA_FIFO_VALID BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_PCIEM_PUSH_DATA_FIFO_VALID BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_CPPT_CPPT_COMPL_STATE_IDLE BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIET_WRITE_SHARED_MEM_BUSY BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIET_PCIE_REQ_STATE_FSM_BUSY BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIET_PCIET_SRAM_READ_STATE_FSM_BUSY BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIET_PCIET_READ_COMPL_STATE_FSM_BUSY BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER0_PCIET_HAL_COMPL_CSTATE_BUSY BIT(0)
/*----------------------------------------------------------------
  Register: PciePmeRegister1 - Indicates the activity in pcie. A value of zero indicate everything is idle.
    Bits: 17    HaltPcietReqFifoValid(ro) - halt_pciet_req_fifo_valid
    Bits: 16    HaltPcietReqCaFifoValid(ro) - halt_pciet_req_ca_fifo_valid
    Bits: 15    HalComplDescrFifoValid(ro) - hal_compl_descr_fifo_valid
    Bits: 14    HalComplReadyFifoValid(ro) - hal_compl_ready_fifo_valid
    Bits: 13    HalRequestReadyFifoValid(ro) - HAL_REQUEST_READY_FIFO_VALID
    Bits: 12    SharedMemReqFifoValid(ro) - shared_mem_req_fifo_valid
    Bits: 11    SharedMemRdReqFifoValid(ro) - shared_mem_rd_req_fifo_valid
    Bits: 10    SharedMemWrReqFifoValid(ro) - shared_mem_wr_req_fifo_valid
    Bits:  9    HaltPcietReqInletFifoValid(ro) - halt_pciet_req_inlet_fifo_valid
    Bits:  8    IntIoReadDataFifoValid(ro) - int_io_read_data_fifo_valid
    Bits:  7    SramReadDataFifoValid(ro) - sram_read_data_fifo_valid
    Bits:  6    ReadComplOrderFifoValid(ro) - read_compl_order_fifo_valid
    Bits:  5    CppMasterReqFifoValid(ro) - cpp_master_req_fifo_valid
    Bits:  4    IntReadReqFifoValid(ro) - int_read_req_fifo_valid
    Bits:  3    PcieReqState(ro) - pcie_req_state
    Bits:  2    PcietSramReadState(ro) - pciet_sram_read_state
    Bits:  1    PcietReadComplState(ro) - pciet_read_compl_state
    Bits:  0    IntDummy(ro) - int_dummy
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1             0x00000274
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HALT_PCIET_REQ_FIFO_VALID BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HALT_PCIET_REQ_CA_FIFO_VALID BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HAL_COMPL_DESCR_FIFO_VALID BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HAL_COMPL_READY_FIFO_VALID BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HAL_REQUEST_READY_FIFO_VALID BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_SHARED_MEM_REQ_FIFO_VALID BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_SHARED_MEM_RD_REQ_FIFO_VALID BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_SHARED_MEM_WR_REQ_FIFO_VALID BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_HALT_PCIET_REQ_INLET_FIFO_VALID BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_INT_IO_READ_DATA_FIFO_VALID BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_SRAM_READ_DATA_FIFO_VALID BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_READ_COMPL_ORDER_FIFO_VALID BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_CPP_MASTER_REQ_FIFO_VALID BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_INT_READ_REQ_FIFO_VALID BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_PCIE_REQ_STATE BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_PCIET_SRAM_READ_STATE BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_PCIET_READ_COMPL_STATE BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PME_REGISTER1_INT_DUMMY BIT(0)
/*----------------------------------------------------------------
  Register: PcieCppMstrSwCreditLimit - Programmable Credit limit control for the CPP Master Abiter logic
    Bits: 27:24 BlqWrCmdSwCreditLimit(rw) - Controls the software credit limit value for the BLQWR Command output interface of the CPP Master Arbiter Block
    Bits: 21:16 AllocRespSwCreditLimit(rw) - Controls the software credit limit value for the Allocation Response output interface of the CPP Master Arbiter block.
    Bits: 14:12 P7CmdSwCreditLimit(rw) - Controls the software credit limit value for Command Bus B output of the CPP Master Arbiter block.
    Bits: 10:8  P6CmdSwCreditLimit(rw) - Controls the software credit limit value for Command Bus A output of the CPP Master Arbiter block.
    Bits:  7:6  P7BSmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P7B Credit Tracker.
    Bits:  5:4  P7ASmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P7A Credit Tracker
    Bits:  3:2  P6BSmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P6B Credit Tracker
    Bits:  1:0  P6ASmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P6A Credit Tracker
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT  0x00000278
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_BLQWRCMD_SW_CREDIT_LIMIT(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_BLQWRCMD_SW_CREDIT_LIMIT_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_ALLOC_RESP_SW_CREDIT_LIMIT(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_ALLOC_RESP_SW_CREDIT_LIMIT_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7_CMD_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7_CMD_SW_CREDIT_LIMIT_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6_CMD_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6_CMD_SW_CREDIT_LIMIT_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7B_SMCPPDATA_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7B_SMCPPDATA_SW_CREDIT_LIMIT_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7A_SMCPPDATA_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P7A_SMCPPDATA_SW_CREDIT_LIMIT_of(_x) (((_x) >> 4) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6B_SMCPPDATA_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6B_SMCPPDATA_SW_CREDIT_LIMIT_of(_x) (((_x) >> 2) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6A_SMCPPDATA_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_CPP_MSTR_SW_CREDIT_LIMIT_P6A_SMCPPDATA_SW_CREDIT_LIMIT_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: PciePmDmaSwCreditLimit - Programmable Credit limit control for the DMA engine
    Bits: 29:27 PmCreditChkSwCreditLimit(rw) - Controls the software credit limit for the DMA Descriptor Packet Mode Credit Check Credit Tracker.
    Bits: 26:24 P2DSwCreditLimit(rw) - Controls the software credit limit for the P2D Command interface between the FromPCIe DMA engine and buffer allocation logic
    Bits: 23:20 ToPcieBufferSwCreditLimit(rw) - Controls the software credit limit for the toPcie DMA SRAM allocation space in increments of 8 buffers
    Bits: 19:16 FrmPcieBufferSwCreditLimit(rw) - Controls the software credit limit for the fromPcie DMA SRAM allocation space in increments of 8 buffers
    Bits: 13    AllocCmdSwCreditLimit(rw) - Controls the software credit limit for the allocation command interface within the buffer allocation logic
    Bits: 12    AllocMstrCmdSwCreditLimit(rw) - Controls the software credit limit for the allocation master command interface between the buffer allocation logic and the CPP Master Arbiter block
    Bits: 11    DmaCmdSwCreditLimit(rw) - Controls software credit limit for the DMA command interface between the buffer allocation logic and the PCIe Master Interface.
    Bits: 10    BufRetCreditSwCreditLimit(rw) - Controls the Buffer Credit Return interface software credit limit within the Buffer allocation logic
    Bits:  9:8  BdFifoSwCreditLimit(rw) - Controls BLQ buffer descriptor FIFO credit limit value
    Bits:  7:6  McrRespSwCreditLimit(rw) - Controls the software credit limit for the MCR response interface between the buffer allocation BLQ logic and the DMA CSR block
    Bits:  5:4  DmaPmAddToWrkQSwCreditLimit(rw) - Controls the software credit limit for the packet mode add to workQ and read completion command from the DMA engine to the CPP Master Arbiter block
    Bits:  1:0  DmaFreePktSwCreditLimit(rw) - Controls the software credit limit value for the free pkt command i/f from the DMA engine to the CPP Master Arbiter block.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT    0x0000027c
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_PM_CREDIT_CHK_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_PM_CREDIT_CHK_SW_CREDIT_LIMIT_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_P2D_SW_CREDIT_LIMIT(_x) (((_x) & 0x7) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_P2D_SW_CREDIT_LIMIT_of(_x) (((_x) >> 24) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_TOPCIE_BUFFER_SW_CREDIT_LIMIT(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_TOPCIE_BUFFER_SW_CREDIT_LIMIT_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_FRMPCIE_BUFFER_SW_CREDIT_LIMIT(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_FRMPCIE_BUFFER_SW_CREDIT_LIMIT_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_ALLOC_CMD_SW_CREDIT_LIMIT BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_ALLOC_MSTRCMD_SW_CREDIT_LIMIT BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_DMACMD_SW_CREDIT_LIMIT BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_BUF_RET_CREDIT_SW_CREDIT_LIMIT BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_BDFIFO_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_BDFIFO_SW_CREDIT_LIMIT_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_MCR_RESP_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_MCR_RESP_SW_CREDIT_LIMIT_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_DMA_PMADDTOWRKQ_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_DMA_PMADDTOWRKQ_SW_CREDIT_LIMIT_of(_x) (((_x) >> 4) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_DMA_FREEPKT_SW_CREDIT_LIMIT(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIE_PM_DMA_SW_CREDIT_LIMIT_DMA_FREEPKT_SW_CREDIT_LIMIT_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: DMAPacketAllocationActiveStat - Active Packet Allocation Status
    Bits: 31:0  Active(rc) - When a packet allocation context becomes active the bit that corresponds to the packet allocation context is set. Clears on read
*/
#define NFP3800_PCIEX_COMPCFG_DMA_PA_ACT_STAT                0x00000288
#define   NFP3800_PCIEX_COMPCFG_DMA_PA_ACT_STAT_ACTIVE(_x)   (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_DMA_PA_ACT_STAT_ACTIVE_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaRateMeterCtrl - DMA Rate Meter Control and status
    Bits: 31:16 RateMeterRdData(ro) - Measured rate from selected DMA rate meter. Value/(32768*(CLK PERIOD in secs)*(10**6)) = Millions of packets/sec or bit rate. If selecting FrmPcieBitRate or ToPcieBitRate multiply the value by the (DmaPcieCredit+1)*8*8, where the DmaPcieCredit is either the DmaToPcieCredit or DmaToPcieCredit from the DMACntrlCfg2 register.
    Bits:  7    DisSigOnlyCnt(rw) - When set, signal only DMAs are not counted for pkt rate meter measurements and packet count increments.
    Bits:  6:5  DmaRateMeterRdSel(rw) - Selects the DMA Rate meter to read from
    Bits:  4    DmaPktRateMuxSel(rw) - Used to select the increment signal for rate meter measurements and packet/byte count increments.
    Bits:  3:1  DmaRateResolution(rw) - When programmed to a value of N, the rate meters will have a resolution of 1/(2**(15-N)*(CLK PERIOD in secs)*(10**6)) Million Packets Per Sec
    Bits:  0    DmaRateMeterEna(rw) - When programmed to 1, enables the rate meters. Disabling the rate meters will freeze the values so that they can be read one at a time, but represent a snapshot in time.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL       0x0000028c
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_RATE_METER_RD_DATA(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_RATE_METER_RD_DATA_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DIS_SIG_ONLY_CNT BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL(_x) (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL_of(_x) (((_x) >> 5) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL_FRMPCIEPKTRATE (0)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL_FRMPCIEBITRATE (1)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL_TOPCIEPKTRATE (2)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_RATE_METER_RDSEL_TOPCIEBITRATE (3)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_PKT_RATE_MUX_SEL BIT(4)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_PKT_RATE_MUX_SEL_DMADESCFRAGPOST (0 << 4)
#define     NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMA_PKT_RATE_MUX_SEL_DMADESCRFRAGPRE BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_PCIE_DMARATE_RES(_x) (((_x) & 0x7) << 1)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_PCIE_DMARATE_RES_of(_x) (((_x) >> 1) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIE_DMA_RATE_METER_CTRL_DMARATE_METER_EN BIT(0)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktCntLo - DMA ToPCIe (Writes) packet counter low 32-bits. Software should read this register follwed by the PCIeDmaToPciePktCntHi register to get the 48-bit counter value.
  Register: PCIeDmaFrmPciePktCntLo - DMA ToPCIe (Writes) packet counter low 32-bits. Software should read this register follwed by the PCIeDmaFrmPciePktCntHi register to get the 48-bit counter value.
    Bits: 31:0  PCIeDmaPktCntLo(rc) - DMA Packet Counter Low 32-bits. SW should read this register followed by the high packet count regiser. Increments when a DMA Descriptor is popped from the DMA queue.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_TOPCIE_PKT_CNT_LO     0x00000290
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_FRMPCIE_PKT_CNT_LO    0x000002a0
#define   NFP3800_PCIEX_COMPCFG_PCIEDMAPKTCNTLO_PCIE_DMA_PKT_CNT_LO(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEDMAPKTCNTLO_PCIE_DMA_PKT_CNT_LO_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktCntHi - DMA ToPCIe (Writes) packet counter high 16-bits.
  Register: PCIeDmaFrmPciePktCntHi - DMA ToPCIe (Writes) packet counter high 16-bits.
    Bits: 15:0  PCIeDmaPktCntHi(ro) - DMA Packet Counter High Latched 16-bits. SW should read this register after reading the low packet count regiser.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_TOPCIE_PKT_CNT_HI     0x00000294
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_FRMPCIE_PKT_CNT_HI    0x000002a4
#define   NFP3800_PCIEX_COMPCFG_PCIEDMAPKTCNTHI_PCIE_DMA_PKT_CNT_HI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEDMAPKTCNTHI_PCIE_DMA_PKT_CNT_HI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktByteCntLo - DMA ToPCIe (Writes) packet byte counter low 32-bits. Software should read this register follwed by the PCIeDmaToPciePktCntHi register to get the 48-bit counter value.
  Register: PCIeDmaFrmPciePktByteCntLo - DMA ToPCIe (Writes) packet byte counter low 32-bits. Software should read this register follwed by the PCIeDmaFromPciePktCntHi register to get the 48-bit counter value.
    Bits: 31:0  PCIeDmaByteCntLo(rc) - DMA Packet Byte Counter Low 32-bits. SW should read this register followed by the high packet count regiser. Increments by the size of the DMA Descriptor when popped from the DMA queue.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_TOPCIE_PKT_BYTE_CNT_LO 0x00000298
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_FRMPCIE_PKT_BYTE_CNT_LO 0x000002a8
#define   NFP3800_PCIEX_COMPCFG_PCIEDMABYTECNTLO_PCIE_DMA_BYTE_CNT_LO(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEDMABYTECNTLO_PCIE_DMA_BYTE_CNT_LO_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktByteCntHi - DMA ToPCIe (Writes) packet byte counter high 16-bits.
  Register: PCIeDmaFrmPciePktByteCntHi - DMA ToPCIe (Writes) packet byte counter high 16-bits.
    Bits: 15:0  PCIeDmaByteCntHi(ro) - DMA Packet Byte Counter High Latched 16-bits. SW should read this register after reading the low byte count regiser.
*/
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_TOPCIE_PKT_BYTE_CNT_HI 0x0000029c
#define NFP3800_PCIEX_COMPCFG_PCIE_DMA_FRMPCIE_PKT_BYTE_CNT_HI 0x000002ac
#define   NFP3800_PCIEX_COMPCFG_PCIEDMABYTECNTHI_PCIE_DMA_BYTE_CNT_HI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIEDMABYTECNTHI_PCIE_DMA_BYTE_CNT_HI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_vendor_id_device_id -
    Bits: 31:16 DID(rw) - Device ID: Device ID assigned by the manufacturer of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
    Bits: 15:0  VID(rw) - Vendor ID: This is the Vendor ID assigned by PCI SIG to the manufacturer of the device.On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_VENDOR_ID_DEVICE_ID   0x00000000
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_DID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_DID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_VID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_VID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_command_status -
    Bits: 31    DPE(w1c) - Detected Parity Error: This bit is set when the Controller has received a poisoned TLP. The Parity Error Response enable bit (bit 6) has no effect on the setting of this bit. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 30    SSE(w1c) - Signaled System Error: If the SERR enable bit is 1, this bit is set when the Controller has sent out a fatal or non-fatal error message on the link to the Root Complex. If the SERR enable bit is 0, this bit remains 0. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 29    RMA(w1c) - Received Master Abort: This bit is set when the Controller has received a completion from the link with the Unsupported Request status. This field can also be cleared from the local management bus by writing a 1 into this bit position
    Bits: 28    RTA(w1c) - Received Target Abort: This bit is set when the Controller has received a completion from the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position
    Bits: 27    STA(w1c) - Signaled Target Abort: This bit is set when the Controller has sent a completion to the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 26:25 R6(ro) - Reserved: Reserved
    Bits: 24    MDPE(w1c) - Master Data Parity Error: When the Parity Error Response enable bit is 1, the Controller sets this bit when it detects the following error conditions: (i) The Controller receives a poisoned completion from the link in response to a request. (ii) The Controller sends out a poisoned write request on the link (this may be because an underflow occurred during the packet transfer at the host interface of the Controller.). This bit remains 0 when the Parity Error Response enable bit is 0. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 23:21 R5(ro) - Reserved: Reserved
    Bits: 20    CL(ro) - Capabilities List: Indicates the presence of PCI Extended Capabilities registers. This bit is hardwired to 1.
    Bits: 19    IS(ro) - Interrupt Status: This bit is valid only when the Controller is configured to support legacy interrupts. Indicates that the Controller has a pending interrupt, that is, the Controller has sent an Assert_INTx message but has not transmitted a corresponding Deassert_INTx message.
    Bits: 18:16 R4(ro) - Reserved: Reserved
    Bits: 15:11 R3(ro) - Reserved: Reserved
    Bits: 10    IMD(rw) - INTx Message Disabled: Enables or disables the transmission of INTx Assert and De-assert messages from the Controller. Setting this bit to 1 disables generation of INTx assert/de-assert messages in the Controller. This field can be written from the local management bus.
    Bits:  9    R2(ro) - Reserved: Reserved
    Bits:  8    SE(rw) - SERR Enable: Enables the reporting of fatal and non-fatal errors detected by the Controller to the Root Complex. This field can be written from the local management bus.
    Bits:  7    R1(ro) - Reserved: Reserved
    Bits:  6    PERE(rw) - Parity Error Response Enable: When this bit is 1, the Controller sets the Master Data Parity Error status bit when it detects the following error conditions: (i) The Controller receives a poisoned completion from the link in response to a request. (ii) The Controller sends out a poisoned write request on the link (this may be because an underflow occurred during the packet transfer at the host interface of the Controller.). When this bit is 0, the Master Data Parity Error status bit is never set. This field can be written from the local management bus.
    Bits:  5:3  R0(ro) - Reserved: Reserved
    Bits:  2    BE(rw) - Bus-Master Enable: Enables the device to issue memory and I/O requests from this Function. This field can be written from the local management bus.
    Bits:  1    MSE(rw) - Mem-Space Enable: Enables memory accesses through the Controller for this PCI Function. This field can be written from the local management bus.
    Bits:  0    ISE(rw) - IO-Space Enable: Enables IO accesses through the Controller for this PCI Function. This field can be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_COMMAND_STATUS        0x00000004
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_DPE  BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_SSE  BIT(30)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_RMA  BIT(29)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_RTA  BIT(28)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_STA  BIT(27)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R6(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R6_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_MDPE BIT(24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R5(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R5_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_CL   BIT(20)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_IS   BIT(19)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R4(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R4_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R3(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R3_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_IMD  BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R2   BIT(9)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_SE   BIT(8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R1   BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_PERE BIT(6)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R0(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_R0_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_BE   BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_MSE  BIT(1)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_COMMAND_STATUS_ISE  BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_revision_id_class_code -
    Bits: 31:24 CC(rw) - Class Code: Identifies the function of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus
    Bits: 23:16 SCC(rw) - Sub-Class Code: Identifies a sub-category within the selected function. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits: 15:8  PIB(rw) - Programming Interface Byte: Identifies the register set layout of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  RID(rw) - Revision ID: Assigned by the manufacturer of the device to identify the revision number of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_REVISION_ID_CLASS_CODE 0x00000008
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_CC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_CC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_SCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_SCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_PIB(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_PIB_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_RID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_REVISION_ID_CLASS_CODE_RID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_bist_header_latency_cache_line -
    Bits: 31:24 BR(rw) - BIST Register: BIST control register.It can be accessed using local management bus. This is a sticky field.
    Bits: 23    DT(ro) - Device Type: Identifies whether the device supports a single Function or multiple Functions. This bit is read as 0 when only Function 0 has been enabled in the Physical Function Configuration Register (in the local management block), and as 1 when more than one Function has been enabled.
    Bits: 22:16 HT(ro) - Header Type: Identifies format of header. This field is hardwired to 0.
    Bits: 15:8  LT(ro) - Latency Timer: This is an unused field and is hardwired to 0.
    Bits:  7:0  CLS(rw) - Cache Line Size: Cache Line Size Register defined in PCI Specifications 3.0. This field can be read or written, both from the link and from the local management bus, but its value is not used.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BIST_HEADER_LATENCY_CACHE_LINE 0x0000000c
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_BR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_BR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_DT BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_HT(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_HT_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_LT(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_LT_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_CLS(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_CLS_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_0 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 1 is treated as a continuation of the base address in BAR 0. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_0           0x00000010
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_P0      BIT(3)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_S0      BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_R7      BIT(1)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_0_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_1 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_1           0x00000014
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_1_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_1_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_2 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 3 is treated as a continuation of the base address in BAR 2. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_2           0x00000018
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_P0      BIT(3)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_S0      BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_R7      BIT(1)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_2_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_3 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_3           0x0000001c
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_3_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_3_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_4 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 5 is treated as a continuation of the base address in BAR 4. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_4           0x00000020
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_P0      BIT(3)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_S0      BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_R7      BIT(1)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_4_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_5 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_BASE_ADDR_5           0x00000024
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_5_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_BASE_ADDR_5_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_rsvd_0A -
  Register: i_pcie_base_rsvd_0E -
  Register: i_MSI_cap_struct_rsvd_02A_02B_[2] -
  Register: i_MSIX_cap_struct_rsvd_02F -
  Register: i_PCIE_cap_struct_rsvd_035 -
  Register: i_PCIE_cap_struct_rsvd_036 -
  Register: i_PCIE_cap_struct_rsvd_037_038_[2] -
  Register: i_PCIE_cap_struct_rsvd_03D_03F_[3] -
  Register: i_AER_cap_struct_rsvd_04B_04D_[3] -
  Register: i_ARI_cap_struct_rsvd_052_053_[2] -
  Register: i_device_serial_num_cap_struct_rsvd_057 -
  Register: i_power_budgeting_cap_struct_rsvd_05C_05F_[4] -
  Register: i_SRIOV_cap_struct_rsvd_090_09C_[13] -
    Bits: 31:0  RSVD(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_pcie_base_RSVD_0A                 0x00000028
#define NFP3800_PCIEX_PF_i_pcie_base_RSVD_0E                 0x00000038
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_RSVD_02A_02B(_x)   (0x000000a8 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_RSVD_02F          0x000000bc
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_RSVD_035          0x000000d4
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_RSVD_036          0x000000d8
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_RSVD_037_038(_x)  (0x000000dc + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_RSVD_03D_03F(_x)  (0x000000f4 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_AER_cap_struct_RSVD_04B_04D(_x)   (0x0000012c + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_RSVD_052_053(_x)   (0x00000148 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_RSVD_057 0x0000015c
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_RSVD_05C_05F(_x) (0x00000170 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_RSVD_090_09C(_x) (0x00000240 + (0x4 * ((_x) & 0xf)))
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_PF_GENERIC_RESERVED_REG_CL_RSVD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_PF_GENERIC_RESERVED_REG_CL_RSVD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_subsystem_vendor_id_subsystem_i -
    Bits: 31:16 SID(rw) - Subsystem ID: Specifies the Subsystem ID assigned by the manufacturer of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits: 15:0  SVID(rw) - Subsystem Vendor ID: Specifies the Subsystem Vendor ID assigned by the PCI SIG to the manufacturer of the device.On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I 0x0000002c
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SVID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SVID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_expan_rom_base_addr -
    Bits: 31:12 RBARW(rw) - ROM Base Address: Defines the base address and range of the expansion ROM address space. The number of writeable bits in this field determines the size of the range (BAR aperture). All other bits are not writeable, and are read as 0's.
    Bits: 11    RBARO(ro) - ROM Base Address: Defines the base address and range of the expansion ROM address space. The number of writeable bits in this field determines the size of the range (BAR aperture). All other bits are not writeable, and are read as 0's.
    Bits:  7:1  R14(ro) - Reserved: Reserved
    Bits:  0    ADE(rw) - Address Decode Enable: This bit must be set to 1 by the configuration software to enable the expansion ROM. This bit can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_EXPAN_ROM_BASE_ADDR   0x00000030
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_RBARW(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_RBARW_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_RBARO BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_R14(_x) (((_x) & 0x7f) << 1)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_R14_of(_x) (((_x) >> 1) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_EXPAN_ROM_BASE_ADDR_ADE BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_capabilities_pointer -
    Bits: 31:8  R15(ro) - Reserved: Reserved
    Bits:  7:0  CP(rw) - Capabilities Pointer: Contains pointer to the first PCI Capability Structure. This field is set by default to the value defined in the RTL file reg_defaults.h. It can be re-written independently for every Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_CAPABILITIES_POINTER  0x00000034
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_CAPABILITIES_POINTER_R15(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_CAPABILITIES_POINTER_R15_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_CAPABILITIES_POINTER_CP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_CAPABILITIES_POINTER_CP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_intrpt_line_intrpt_pin -
    Bits: 31:11 R16(ro) - Reserved: Reserved
    Bits: 10:8  IPR(rw) - Interrupt Pin Register: Identifies the interrupt input (A, B, C, D) to which this Functions interrupt output is connected to (01 = INTA, 02 = INTB, 03 = INTC, 04 = INTD). The assignment of interrupt inputs to Functions is fixed when the Controller is configured. This field can be re-written independently for each Function from the local management bus. Please see the `define macros den_db_Fx_INTR_PIN values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  7:0  ILR(rw) - Interrupt Line Register: Identifies the IRQx input of the interrupt controller at the Root Complex that is activated by this Functions interrupt (00 = IRQ0, ... , 0F = IRQ15, FF = unknown or not connected). This field is writable from the local management bus. Please see the `define macros den_db_Fx_INTR_LINE values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_I_INTRPT_LINE_INTRPT_PIN 0x0000003c
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_R16(_x) (((_x) & 0x1fffff) << 11)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_R16_of(_x) (((_x) >> 11) & 0x1fffff)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_IPR(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_IPR_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_ILR(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_ILR_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_mgmt_cap_struct_i_pwr_mgmt_cap -
    Bits: 31    PSDCS(ro) - PME Support for D3(cold) State: Indicates whether the Function is capable of sending PME messages when in the D3cold state. Because the device does not have aux power, this bit is hardwired to 0.
    Bits: 30    PSDHS(rw) - PME Support for D3(hot) Statue: Indicates whether the Function is capable of sending PME messages when in the D3hot state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 29    PSD2S(ro) - PME Support for D2 State: Indicates whether the Function is capable of sending PME messages when in the D2 state. This bit is hardwired to 0 because D2 state is not supported.
    Bits: 28    PSD1S(rw) - PME Support for D1 State: Indicates whether the Function is capable of sending PME messages when in the D1 state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 27    PSD0S(rw) - PME Support for D0 State: Indicates whether the Function is capable of sending PME messages when in the D0 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 26    D2S(ro) - D2 Support: Set if the Function supports the D2 power state. Currently hardwired to 0.
    Bits: 25    D1S(rw) - D1 Support: Set if the Function supports the D1 power state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 24:22 MCRAPS(ro) - Max Current Required from Aux Power Supply: Specifies the maximum current drawn by the device from the aux power source in the D3cold state. This field is not implemented in devices not supporting PME notification when in the D3cold state, and is therefore hardwired to 0.
    Bits: 21    DSI(ro) - Device Specific Initialization Bit: This bit, when set, indicates that the device requires additional configuration steps beyond setting up its PCI configuration space, to bring it to the D0 active state from the D0 uninitialized state. This bit is hardwired to 0.
    Bits: 20    R0(ro) - Reserved: Reserved
    Bits: 19    PC(ro) - PME Clock: Not applicable to PCI Express. This bit is hardwired to 0.
    Bits: 18:16 VID(rw) - Version ID: Indicates the version of the PCI Bus Power Management Specifications that the Function implements. This field is set by default to 011 (Version 1.2). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(rw) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. The Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  CID(rw) - Capability ID: Identifies that the capability structure is for Power Management. This field is set by default to 01 hex. It can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_I_PWR_MGMT_CAP 0x00000088
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSDCS BIT(31)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSDHS BIT(30)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD2S BIT(29)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD1S BIT(28)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD0S BIT(27)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_D2S BIT(26)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_D1S BIT(25)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_MCRAPS(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_MCRAPS_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_DSI BIT(21)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_R0 BIT(20)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PC BIT(19)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_VID(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_VID_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep -
    Bits: 31:24 DR(ro) - Data Register: This optional register is not implemented in the Cadence PCIe Controller. This field is hardwired to 0.
    Bits: 23:16 R1(ro) - Reserved: Reserved
    Bits: 15    PMES(rw) - PME Status: When PME notification is enabled, writing a 1 into this bit position from the local management bus sets this bit and causes the Controller to send a PME message from the associated Function. When the Root Complex processes this message, it will turn off this bit by writing a 1 into this bit position through a Config Write. This bit can be set or cleared from the local management bus, by writing a 1 or 0, respectively. It can only be cleared from the configuration path (by writing a 1). This is a sticky field.
    Bits: 14:9  R2(ro) - Reserved: Reserved
    Bits:  8    PE(rw) - PME Enable: Setting this bit enables the notification of PME events from the associated Function. This bit can be set also by writing into this register from the local management bus. This is a sticky field.
    Bits:  7:4  R3(ro) - Reserved: Reserved
    Bits:  3    NSR(rw) - No Soft Reset: When this bit is set to 1, the Function will maintain all its state in the PM state D3hot. The software is not required to re-initialize the Function registers on the transition back to D0. This bit is set to 1 by default, but can be modified independently for each PF from the local management bus.
    Bits:  2    R4(ro) - Reserved: Reserved
    Bits:  1:0  PS(rw) - Power State: Indicates the power state this Function is currently in. This field can be read by the software to monitor the current power state, or can be written to cause a transition to a new state. The valid settings are 00 (state D0), 01 (state D1) and 11 (state D3hot). The software should not write any other value into this field. This field can also be written from the local management bus independently for each Function.
*/
#define NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_I_PWR_MGMT_CTRL_STAT_REP 0x0000008c
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_DR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_DR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PMES BIT(15)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R2(_x) (((_x) & 0x3f) << 9)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R2_of(_x) (((_x) >> 9) & 0x3f)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PE BIT(8)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R3(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R3_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_NSR BIT(3)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R4 BIT(2)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PS(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_I_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PS_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_ctrl_reg -
    Bits: 31:25 R0(ro) - Reserved: Reserved
    Bits: 24    MC(rw) - MSI masking capable: can be modified using localmanagement interface
    Bits: 23    BAC64(rw) - 64-Bit Address Capable: Set to 1 to indicate that the device is capable of generating 64-bit addresses for MSI messages.Can be modified using local management interface
    Bits: 22:20 MME(rw) - Multiple Message Enable: Encodes the number of distinct messages that the Controller is programmed to generate for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). This setting must be based on the number of interrupt inputs of the Controller that are actually used by this Function. This field can be written from the local management bus.
    Bits: 19:17 MMC(rw) - Multiple Message Capable: Encodes the number of distinct messages that the Controller is capable of generating for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). Thus, this field defines the number of the interrupt vectors for this Function. The Controller allows up to 32 distinct messages, but the setting of this field must be based on the number of interrupt inputs of the Controller that are actually used by the client. For example, if the client logic uses 8 of the 32 distinct MSI interrupt inputs of the Controller for this Function, then the value of this field must be set to 011. This field can be written from the local management bus. Please see the `define den_db_Fx_MSI_MULTIPLE_MSG_CAPABLE values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 16    ME(rw) - MSI Enable: Set by the configuration program to enable the MSI feature. This field can also be written from the local management bus.
    Bits: 15:8  CP1(rw) - Capabilities Pointer: Pointer to the next PCI Capability Structure. This can be modified from the local management bus. This field can be written from the local management bus.
    Bits:  7:0  CID1(ro) - Capability ID: Specifies that the capability structure is for MSI. Hardwired to 05 hex.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_CTRL_REG     0x00000090
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_R0(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_R0_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MC BIT(24)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_BAC64 BIT(23)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MME(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MME_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MMC(_x) (((_x) & 0x7) << 17)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MMC_of(_x) (((_x) >> 17) & 0x7)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_ME BIT(16)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CP1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CP1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CID1(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CID1_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_low_addr -
    Bits: 31:2  MAL(rw) - Message Address Low: Lower bits of the address to be used in MSI messages. This field can also be written from the local management bus.
    Bits:  1:0  R1(ro) - Reserved: The two lower bits of the address are hardwired to 0 to align the address on a double-word boundary.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_MSG_LOW_ADDR 0x00000094
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_MAL(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_MAL_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_R1(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_R1_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_hi_addr -
    Bits: 31:0  MAH(rw) - Message Address High: Contains bits 63:32 of the 64-bit address to be used in MSI Messages. A value of 0 specifies that 32-bit addresses are to be used in the messages. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_MSG_HI_ADDR  0x00000098
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_HI_ADDR_MAH(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_HI_ADDR_MAH_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_data -
    Bits: 31:16 R2(ro) - Reserved: Hardwired to 0
    Bits: 15:0  MD(rw) - Message Data: Message data to be used for this Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_MSG_DATA     0x0000009c
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_DATA_R2(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_DATA_R2_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_DATA_MD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MSG_DATA_MD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_mask -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MM(rw) - MSI Mask: Mask bits for MSI interrupts. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid mask bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Mask field also changes correspondingly
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_MASK         0x000000a0
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MASK_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MASK_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_MASK_MM    BIT(0)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_pending_bits -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MP(ro) - MSI Pending Bits: Pending bits for MSI interrupts. A read from the location returns the state of the MSI_PENDING_STATUS_IN inputs of the Controller. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid pending bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Pending Bits field also changes correspondingly
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_I_MSI_PENDING_BITS 0x000000a4
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_I_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_MP BIT(0)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_ctrl -
    Bits: 31    MSIXE(rw) - MSI-X Enable: Set by the configuration program to enable the MSI-X feature. This field can also be written from the local management bus.
    Bits: 30    FM(rw) - Function Mask: This bit serves as a global mask to all the interrupt conditions associated with this Function. When this bit is set, the Controller will not send out MSI-X messages from this Function. This field can also be written from the local management bus.
    Bits: 29:27 R0(ro) - Reserved: Reserved
    Bits: 26:16 MSIXTS(rw) - MSI-X Table Size: Specifies the size of the MSI-X Table, that is, the number of interrupt vectors defined for the Function. The programmed value is 1 minus the size of the table (that is, this field is set to 0 if the table size is 1.). It can be re-written independently for each Function from the local management bus. Please see the `define den_db_Fx_MSIX_TABLE_SIZE values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 15:8  CP(rw) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. This is set to point to the PCI Express Capability Structure at 30 hex. This can be rewritten independently for each Function from the local management bus.
    Bits:  7:0  CID(rw) - Capability ID: Identifies that the capability structure is for MSI-X. This field is set by default to 11 hex. It can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_I_MSIX_CTRL       0x000000b0
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXE BIT(31)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_FM  BIT(30)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_R0(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_R0_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_CTRL_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_tbl_offset -
    Bits: 31:3  TO(rw) - Table Offset: Offset of the memory address where the MSI-X Table is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned. Please see the `define den_db_Fx_MSIX_TABLE_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the MSI-X Table is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). Please see the `define den_db_Fx_MSIX_TABLE_BIR values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_I_MSIX_TBL_OFFSET 0x000000b4
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_TO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_TO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_pending_intrpt -
    Bits: 31:3  PBAO(rw) - PBA Offset: Offset of the memory address where the PBA is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned. Please see the `define den_db_Fx_MSIX_PBA_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  2:0  BARI1(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register. Please see the `define den_db_Fx_MSIX_PBA_BIR values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_I_MSIX_PENDING_INTRPT 0x000000b8
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_PBAO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_PBAO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_BARI1(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_BARI1_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_cap_list -
    Bits: 31    R0(ro) - Reserved: Reserved
    Bits: 30    TRS(ro) - TCS Routing Supported: When set to 1, this bit indicates that the device supports routing of Trusted Configuration Requests. Not valid for Endpoints. Hardwired to 0.
    Bits: 29:25 IMN(ro) - Interrupt Message Number: Identifies the MSI or MSI-X interrupt vector for the interrupt message generated corresponding to the status bits in the Slot Status Register, Root Status Register, or this capability structure. This field must be defined based on the chosen interrupt mode - MSI or MSI-X. This field is hardwired to 0.
    Bits: 24    SS(ro) - Slot Status: Set to 1 when the link connected to a slot. Hardwired to 0.
    Bits: 23:20 DT(ro) - Device Type: Indicates the type of device implementing this Function. This field is hardwired to 0 in the EP mode.
    Bits: 19:16 PCV(rw) - Capability Version: Identifies the version number of the capability structure. This field is set to 2 by default to indicate that the Controller is compatible to PCI Express Base Specification Revision 3.0. This field can be modified through local management interface.
    Bits: 15:8  NCP(ro) - Next Capability Pointer: Points to the next PCI capability structure. Set to 0 because this is the last capability structure.
    Bits:  7:0  CID(ro) - Capability ID: Specifies Capability ID assigned by PCI SIG for this structure. This field is hardwired to 10 hex.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_PCIE_CAP_LIST   0x000000c0
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_R0 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_TRS BIT(30)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_IMN(_x) (((_x) & 0x1f) << 25)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_IMN_of(_x) (((_x) >> 25) & 0x1f)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_SS BIT(24)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_DT(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_DT_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_PCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_PCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_NCP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_NCP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_cap -
    Bits: 31:29 R3(ro) - Reserved: Reserved
    Bits: 28    FC(rw) - FLR Capable: Set when device has Function-Level Reset capability. It is set by default to 1. It can be re-written independently for each Function from the local management bus.
    Bits: 27:26 CPLS(rw) - Captured Power Limit Scale: Specifies the scale used by Slot Power Limit Value. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 25:18 CSPLV(rw) - Captured Slot Power Limit Value: Specifies upper limit on power supplied by slot. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 17:16 R2(ro) - Reserved: Reserved
    Bits: 15    RBER(rw) - Role-Based Error Reporting: Enables role-based error reporting. It is hardwired to 1.It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 R1(ro) - Reserved: Reserved
    Bits: 11:9  AL1SL(rw) - Acceptable L1 Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L1 to L0. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits:  8:6  AL0SL(rw) - Acceptable L0S Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L0S to L0. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits:  5    ETFS(rw) - Extended Tag Field Supported: Set when device allows the tag field to be extended from 5 to 8 bits. It can be rewritten independently for each Function from the local management bus.
    Bits:  4:3  PFS(ro) - Phantom Functions Supported: This field is used to extend the tag field by combining unused Function bits with the tag bits. This field is hardwired to 00 to disable this feature.
    Bits:  2:0  MPS(rw) - Max Payload Size: Specifies maximum payload size supported by the device.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_PCIE_DEV_CAP    0x000000c4
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R3(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R3_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_FC BIT(28)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CPLS(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CPLS_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CSPLV(_x) (((_x) & 0xff) << 18)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CSPLV_of(_x) (((_x) >> 18) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R2_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_RBER BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R1(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R1_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL1SL(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL1SL_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL0SL(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL0SL_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_ETFS BIT(5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_PFS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_PFS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_MPS(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_MPS_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_ctrl_status -
    Bits: 31:22 R4(ro) - Reserved: Reserved
    Bits: 21    TP(ro) - Transaction Pending: Indicates if any of the Non-Posted requests issued by the Function are still pending.
    Bits: 20    APD(ro) - Aux Power Detected: Set when auxiliary power is detected by the device. This is an unused field.
    Bits: 19    URD(w1c) - Unsupported Request Detected: Set to 1 by the Controller when it receives an unsupported request, regardless of whether its reporting is enabled or not.
    Bits: 18    FED(w1c) - Fatal Error Detected: Set to 1 by the Controller when it detects a fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 17    NFED(w1c) - Non-Fatal Error Detected: Set to 1 by the Controller when it detects a non-fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 16    CED(w1c) - Correctable Error Detected: Set to 1 by the Controller when it detects a correctable error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 15    FLR(rw) - Function-Level Reset: Writing a 1 into this bit position generates a Function-Level Reset for the selected Function. This bit reads as 0.
    Bits: 14:12 MRRS(rw) - Max Read Request Size: Specifies the maximum size allowed in read requests generated by the device.
    Bits: 11    ENS(rw) - Enable No Snoop: When set to 1, the device is allowed to set the No Snoop bit in initiated transactions in which cache coherency is not needed.
    Bits: 10    EAP(ro) - Enable Aux Power: Used only when device used aux power. This field is hardwired to 0.
    Bits:  9    EPH(ro) - Enable Phantom Functions: This field is hardwired to 0 as the Controller does not support this feature.
    Bits:  8    ETFE(rw) - Extended Tag Field Enable: Enables the extension of the tag field from 5 to 8 bits.
    Bits:  7:5  MPS(rw) - Max Payload Size: Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLPs larger than this value. The configuration program sets this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side.
    Bits:  4    ERO(rw) - Enable Relaxed Ordering: When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it, when the transactions do not require Strong Ordering.
    Bits:  3    EURR(rw) - Enable Unsupported Request Reporting: Enables the sending of error messages by the Controller on receiving unsupported requests.
    Bits:  2    EFER(rw) - Enable Fatal Error Reporting: Enables the sending of ERR_FATAL messages by the Controller on the detection of fatal errors.
    Bits:  1    ENFER(rw) - Enable Non-Fatal Error Reporting: Enables the sending of ERR_NONFATAL messages by the Controller on the detection of non-fatal errors.
    Bits:  0    ECER(rw) - Enable Correctable Error Reporting: Enables the sending of ERR_COR messages by the Controller on the detection of correctable errors.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_PCIE_DEV_CTRL_STATUS 0x000000c8
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_R4(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_R4_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_TP BIT(21)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_APD BIT(20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_URD BIT(19)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_FED BIT(18)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_NFED BIT(17)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_CED BIT(16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_FLR BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MRRS(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MRRS_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ENS BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EAP BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EPH BIT(9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ETFE BIT(8)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MPS(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MPS_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ERO BIT(4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EURR BIT(3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EFER BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ENFER BIT(1)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ECER BIT(0)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_cap -
    Bits: 31:24 PN(ro) - Port Number: Specifies the port number assigned to the PCI Express link connected to this device.
    Bits: 23    R5(ro) - Reserved: Reserved
    Bits: 22    AOC(rw) - ASPM Optionality Compliance: Setting this bit indicates that the device supports the ASPM Optionality feature. It can be turned off by writing a 0 to this bit position through the local management bus.
    Bits: 21    LBNC(ro) - Link Bandwidth Notification Capability: A value of 1b indicates support for the Link Bandwidth Notification status and interrupt mechanisms. Reserved for Endpoint.
    Bits: 20    DLLARC(ro) - Data Link Layer Active Reporting Capability: Set to 1 if the device is capable of reporting that the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0, as this version of the Controller does not support the feature.
    Bits: 19    SDERC(ro) - Surprise Down Error Reporting Capability: Indicates the capability of the device to report a Surprise Down error condition. This bit is hardwired to 0, as this version of the Controller does not support the feature.
    Bits: 18    CPM(rw) - Clock Power Management: Indicates that the device supports removal of referenc clocks. It is set by default to the value of the define in reg_defaults.h. It can be re-written independently for each function from the local management bus.
    Bits: 17:15 L1EL(rw) - L1 Exit Latency: Specifies the exit latency from L1 state. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 L0SEL(rw) - L0S Exit Latency: Specifies the time required for the device to transition from L0S to L0. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 11:10 ASPM(rw) - Active State Power Management: Indicates the level of ASPM support provided by the device. This field can be re-written independently for each Function from the local management bus. When SRIS is enabled in local management register bit, L0s capability is not supported and is forced low.
    Bits:  9:4  MLW(ro) - Maximum Link Width: Indicates the maximum number of lanes supported by the device. This field is hardwired based on the setting of the LANE_COUNT_IN strap input.
    Bits:  3:0  MLS(ro) - Maximum Link Speed: Indicates the maximum speed supported by the link. (2.5 GT/s, 5 GT/s, 8 GT/s per lane). This field is hardwired to 0001 (2.5GT/s) when the strap input PCIE_GENERATION_SEL is set to 0, to 0010 (5 GT/s) when the strap is set to 1, and to 0011 (8 GT/s) when the strap input is set to 10.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_LINK_CAP        0x000000cc
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_PN(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_PN_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_R5   BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_AOC  BIT(22)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_LBNC BIT(21)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_DLLARC BIT(20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_SDERC BIT(19)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_CPM  BIT(18)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_L1EL(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_L1EL_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_L0SEL(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_L0SEL_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_ASPM(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_ASPM_of(_x) (((_x) >> 10) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_MLW(_x) (((_x) & 0x3f) << 4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_MLW_of(_x) (((_x) >> 4) & 0x3f)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_MLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_MLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_ctrl_status -
    Bits: 31    LABS(w1c) - Link Autonomous Bandwidth Status: This bit is Set by hardware to indicate that hardware has autonomously changed Link speed or width, without the Port transitioning through DL_Down status, for reasons other than to attempt to correct unreliable Link operation. This triggers an interrupt to be generated through PHY_INTERRUPT_OUT if enabled. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 30    LBMS(w1c) - Link Bandwidth Management Status: This bit is Set by hardware to indicate that either link training has completed following write to retrain link bit, or when HW has changed link speed or width to attempt to correct unreliable link operation. This triggers an interrupt to be generated through PHY_INTERRUPT_OUT if enabled. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 29    DLLA(ro) - Data Link Layer Active: Indicates the status of the Data Link Layer. Set to 1 when the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0 in this version of the Controller.
    Bits: 28    SCC(rw) - Slot Clock Configuration: This bit indicates that the component uses the same physical reference clock that the platform provides on the connector. If the device uses an independent clock irrespective of the presence of a reference clock on the connector, this bit must be clear. For PF0, this bit can also be written from the local management bus.
    Bits: 27    LTS(ro) - Link Training Status: This read-only bit indicates that the Physical Layer LTSSM is in the Configuration or Recovery state, or that 1b was written to the Retrain Link bit but Link training has not yet begun. Hardware clears this bit when the LTSSM exits the Configuration/Recovery state. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 26    R8(ro) - Reserved: Reserved
    Bits: 25:20 NLW(ro) - Negotiated Link Width: Set at the end of link training to the actual link width negotiated between the two sides. Value is undefined if this regsiters is accessed before link training.
    Bits: 19:16 NLS(ro) - Negotiated Link Speed: Negotiated link speed of the device. The only supported speed ids are 2.5 GT/s per lane (0001),5 GT/s per lane (0010),8 GT/s per lane (0011).
    Bits: 15:12 R15_12(ro) - Reserved: Reserved
    Bits: 11    LABIE(ro) - Link Autonomous Bandwidth Interrupt Enable: When Set, this bit enables the generation of an interrupt to indicate that the Link Autonomous Bandwidth Status bit has been Set. This enables an interrupt to be generated through PHY_INTERRUPT_OUT if triggered. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 10    LBMIE(ro) - Link Bandwidth Management Interrupt Enable: When Set, this bit enables the generation of an interrupt to indicate that the Link Bandwidth Management Status bit has been Set. This enables an interrupt to be generated through PHY_INTERRUPT_OUT if triggered. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits:  9    HAWD(rw) - Hardware Autonomous Width Disable: When this bit is set, the local application must not request to change the operating width of the link, other than attempting to correct unreliable Link operation by reducing Link width.
    Bits:  8    ECPM(ro) - Enable Clock Power Management: When this bit is set to 1, the device may use the CLKREQ# pin on the PCIe connector to power manage the Link clock. This bit is writeable only when the Clock Power Management bit in the Link Capability Register is set to 1.
    Bits:  7    ES(rw) - Extended Synch: Set to 1 to extend the sequence of ordered sets transmitted while exiting from the L0S state.
    Bits:  6    CCC(rw) - Common Clock Configuration: A value of 0 indicates that the reference clock of this device is asynchronous to that of the upstream device. A value of 1 indicates that the reference clock is common.
    Bits:  5    RL(ro) - Retrain Link: Setting this bit to 1 causes the LTSSM to initiate link training. Reserved for Endpoint mode. This bit always reads as 0
    Bits:  4    LD(ro) - Link Disable: Writing a 1 to this bit position causes the LTSSM to go to the Disable Link state. The LTSSM stays in the Disable Link state while this bit is set.Reserved for Endpoint mode.
    Bits:  3    RCB(rw) - Read Completion Boundary: Indicates the Read Completion Boundary of the Root Port connected to this Endpoint (0 = 64 bytes, 1 = 128 bytes). This field can be written from the local management bus with the input signal MGMT_TYPE1_CONFIG_REG_ACCESS high.
    Bits:  2    R6(ro) - Reserved: Reserved
    Bits:  1:0  ASPMC(rw) - Active State Power Management Control: Controls the level of ASPM support on the PCI Express link associated with this Function. The valid setting are 00: ASPM disabled 01: L0s entry enabled, L1 disabled 10: L1 entry enabled, L0s disabled 11: Both L0s and L1 enabled.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_LINK_CTRL_STATUS 0x000000d0
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LABS BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LBMS BIT(30)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_DLLA BIT(29)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_SCC BIT(28)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LTS BIT(27)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_R8 BIT(26)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_NLW(_x) (((_x) & 0x3f) << 20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_NLW_of(_x) (((_x) >> 20) & 0x3f)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_NLS(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_NLS_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_R15_12(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_R15_12_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LABIE BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LBMIE BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_HAWD BIT(9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_ECPM BIT(8)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_ES BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_CCC BIT(6)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_RL BIT(5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_LD BIT(4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_RCB BIT(3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_R6 BIT(2)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_ASPMC(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_ASPMC_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_cap_2 -
    Bits: 31:24 R14(ro) - Reserved: Reserved
    Bits: 23:22 MEEP(ro) - Max End-End TLP Prefixes: Indicates the maximum number of End-End TLP Prefixes supported by the Function. The supported values are: 01b 1 End-End TLP Prefix 10b 2 End-End TLP Prefixes
    Bits: 21    EEPS(ro) - End-End TLP Prefix Supported: Indicates whether the Function supports End-End TLP Prefixes. A 1 in this field indicates that the Function supports receiving TLPs containing End-End TLP Prefixes.
    Bits: 20    EXFS(ro) - Extended Format Field Supported: Indicates that the Function supports the 3-bit definition of the Fmt field in the TLP header. This bit is hardwired to 1 for all Functions.
    Bits: 19:18 OPFFS(ro) - OBFF Supported: A 1 in this bit position indicates that the Function supports the Optimized Buffer Flush/Fill (OBFF) capability using message signaling.
    Bits: 15:14 R13(ro) - Reserved: Reserved
    Bits: 12    TCS(rw) - TPH Completer Supported: These bits, when set, indicate that the Function is capable of serving as a completer for requests with Transaction Processing Hints (TPH). It can be turned off for all Physical Functions by writing into PF 0. Defined Encodings are: 00b TPH and Extended TPH Completer not supported. 01b TPH Completer supported Extended TPH Completer not supported. 10b Reserved. 11b Both TPH and Extended TPH Completer supported. Extended Streering tag is not selected in this configuration. only bit 0 is writtable from client side.
    Bits: 11    LMS(rw) - LTR Mechanism Supported: A 1 in this bit position indicates that the Function supports the Latency Tolerance Reporting (LTR) Capability. This bit is set to 1 by default, but can be turned off for all Physical Functions by writing into PF 0.
    Bits: 10    R12(ro) - Reserved: Reserved
    Bits:  9    BAOCS128(rw) - 128-Bit CAS Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for the Compare-and- Swap (CAS) Atomic Operation with 128-bit operands. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  8    BAOCS64(rw) - 64-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 64-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  7    BAOCS32(rw) - 32-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 32-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  6    OPRS(ro) - OP routing supported: Atomic OP routing supported.
    Bits:  5    AFS(ro) - ARI forwarding support: ARI forwarding supported. This field is hard coded to zero
    Bits:  4    CTDS(rw) - Completion Timeout Disable Supported: A 1 in this field indicates that the associated Function supports the capability to turn off its Completion timeout. This bit is set to 1 by default, but can be re-written independently for each Function from the local management bus.
    Bits:  3:0  CTR(rw) - Completion Timeout Ranges: Specifies the Completion Timeout values supported by the device. This field is set by default to 0010 (10 ms - 250 ms). The actual timeout values are in two programmable local management registers, which allow the timeout settings of the two sub-ranges within Range B to be programmed independently.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_PCIE_DEV_CAP_2  0x000000e4
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R14(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R14_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_MEEP(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_MEEP_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_EEPS BIT(21)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_EXFS BIT(20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPFFS(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPFFS_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R13(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R13_of(_x) (((_x) >> 14) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_TCS BIT(12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_LMS BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R12 BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS128 BIT(9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS64 BIT(8)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS32 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPRS BIT(6)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_AFS BIT(5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTDS BIT(4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2 -
    Bits: 31:15 R18(ro) - Reserved: Reserved
    Bits: 14:13 OBFFE(ro) - OBFF Enable: Enables the Optimized Buffer Flush/Fill (OBFF) capability in the device. This field is implemented only in PF 0. Valid settings are 00 (disabled), 01 (Variation A) and 10 (Variation B). This field can also be written from the local management bus. RW if OBFF capability is supported, RO otherwise.
    Bits: 11    R17(ro) - Reserved: Reserved
    Bits: 10    LTRME(rw) - LTR Mechanism Enable: This must be set to 1 to enable the Latency Tolerance Reporting Mechanism. This bit is implemented only in PF 0. Its default value is 1, but can be modified from the local management bus. This bit is read-only in PF 1.
    Bits:  9    IDOCE(rw) - IDO Completion Enable: When this bit is 1, the Function is allowed to set the ID-based Ordering (IDO) Attribute bit in the Completions it generates.
    Bits:  8    IDORE(rw) - IDO Request Enable: When this bit is 1, the Function is allowed to set the ID-based Ordering (IDO) Attribute bit in the requests it generates.
    Bits:  7    R16(ro) - Reserved: Reserved
    Bits:  6    AORE(rw) - Atomic Op Requester Enable: This bit must be set to enable the generation of Atomic Op Requests from the Function. If the client logic attempts to send an Atomic Op for a Function for which this bit is not set, logic in the Controller will nullify the TLP on its way to the link. This bit can also be written from the local management bus.
    Bits:  5    AFE(ro) - ARI forwarding enable: ARI forwarding enable
    Bits:  4    CTD(rw) - Completion Timeout Disable: Setting this bit disables Completion Timeout in the device. This bit can also be written from the local management bus.
    Bits:  3:0  CTV(rw) - Completion Timeout Value: Specifies the Completion Timeout value for the device. Allowable values are 0101 (sub-range 1) and 0110 (sub-range 2). The corresponding timeout values are stored in the local management registers Completion Timeout Interval Registers 0 and 1, respectively. Value of 0selects completion timeout from Completion-Timeout-Interval-Registers-0 in local managementregister.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_PCIE_DEV_CTRL_STATUS_2 0x000000e8
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_R18(_x) (((_x) & 0x1ffff) << 15)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_R18_of(_x) (((_x) >> 15) & 0x1ffff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_OBFFE(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_OBFFE_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_R17 BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_LTRME BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_IDOCE BIT(9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_IDORE BIT(8)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_R16 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_AORE BIT(6)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_AFE BIT(5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_CTD BIT(4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_CTV(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_2_CTV_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_cap_2_reg -
    Bits: 31    R31(ro) - DRS Supported: Indicates support for the optional Device Readiness Status (DRS) capability. This capability is currently not supported in the Controller.
    Bits: 30:25 R25(ro) - Reserved: Reserved
    Bits: 24:23 R23(ro) - Reserved: Reserved
    Bits: 22:20 R3(ro) - Reserved: Reserved
    Bits: 18:16 LSORSSV(rw) - Lower SKP OS Reception Supported Speeds Vector: If this field is non-zero, it indicates that the Port, when operating at the indicated speed(s) supports SRIS and also supports receiving SKP OS at the rate defined for SRNS while running in SRIS.
    Bits: 15:12 R2(ro) - Reserved: Reserved
    Bits: 11:9  LSOGSSV(rw) - Lower SKP OS Generation Supported Speeds Vector: If this field is non-zero, it indicates that the Port, when operating at the indicated speed(s) supports SRIS and also supports software control of the SKP Ordered Set transmission scheduling rate.
    Bits:  8:5  R1(ro) - Reserved: Reserved
    Bits:  3:1  SLSV(rw) - Supported Link Speeds Vector: This field indicates the supported link speeds of the Controller. For each bit, a value of 1 indicates that the corresponding link speed is supported, while a value of 0 indicates that the corresponding speed is not supported. The bits corresponding to various link speeds are: Bit 1 = Link Speed 2.5 GT/s, Bit 2 = Link Speed 5 GT/s, Bit 3 = Link Speed 8 GT/s. This field is hardwired to 0001 (2.5 GT/s) when the PCIE_GENERATION_SEL strap pins of the Controller are set to 0, 0011 (2.5 and 5 GT/s) when the strap is set to 1 , and 0111 (2.5, 5, and 8 GT/s) when the strap pin is set to 10 For PF0, this field can be written through the LM interface.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_LINK_CAP_2_REG  0x000000ec
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R31 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R25(_x) (((_x) & 0x3f) << 25)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R25_of(_x) (((_x) >> 25) & 0x3f)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R23(_x) (((_x) & 0x3) << 23)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R23_of(_x) (((_x) >> 23) & 0x3)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R3(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R3_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_LSORSSV(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_LSORSSV_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R2(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R2_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_LSOGSSV(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_LSOGSSV_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R1(_x) (((_x) & 0xf) << 5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_R1_of(_x) (((_x) >> 5) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_SLSV(_x) (((_x) & 0x7) << 1)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CAP_2_REG_SLSV_of(_x) (((_x) >> 1) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_ctrl_status_2 -
    Bits: 31:22 R21(ro) - Reserved: Reserved
    Bits: 21    LE(rw) - Link Equalization Request 8.0 GT/s: This bit can be set by the software running on the EndPoint to force the Endpoint to perform link equalization for 8.0 GT/s. Setting this bit causes the LTSSM of the Controller to enter the Recovery state and request its link partner to perform equalization. This bit is cleared when the LTSSM enters the Recovery.Equalization state. It can also be cleared by writing a 1 to this bit position by the host, or writing a 0 from the LMI. STICKY.
    Bits: 20    EP3S(ro) - Equalization 8.0 GT/s Phase 3 Successful: This bit, when set to 1, indicates that the Phase 3 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 19    EP2S(ro) - Equalization 8.0 GT/s Phase 2 Successful: This bit, when set to 1, indicates that the Phase 2 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 18    EP1S(ro) - Equalization 8.0 GT/s Phase 1 Successful: This bit, when set to 1, indicates that the Phase 1 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 17    EQC(ro) - Equalization 8.0 GT/s Complete: This bit, when set to 1, indicates that the Transmitter Equalization procedure has completed for 8.0 GT/s. STICKY.
    Bits: 16    CDEL(ro) - Current De-Emphasis Level: This status bit indicates the current operating de-emphasis level of the transmitter (0 = -6 dB, 1 = -3.5 dB).This field is undefined when link is not at Gen2 speed.
    Bits: 15:12 CDE(rw) - Compliance De-Emphasis: This bit sets the de-emphasis level (for 5 GT/s operation) or the Transmitter Preset level (for 8 GT/s operation) when the LTSSM enters the Polling.Compliance state because of software setting the Enter Compliance bit in this register. It is used only when the link is running at 5 GT/s or 8 GT/s. At 5 GT/s, the only valid setting are 0 (-6 dB) and 1 (-3.5 dB). STICKY.
    Bits: 11    CS(rw) - Compliance SOS: When this bit is set to 1, the device will transmit SKP ordered sets between compliance patterns. STICKY.
    Bits: 10    EMC(rw) - Enter Modified Compliance: This field is intended for debug and compliance testing purposes only. If this bit is set to 1, the device will transmit the Modified Compliance Pattern when the LTSSM enters the Polling. Compliance substate. Note: Setting this bit alone will not cause the LTSSM to enter Polling.Compliance. The Enter Compliance bit must also be set and a Hot Reset needs to be initiated by Host to enter Polling.Compliance. STICKY.
    Bits:  9:7  TM(rw) - Transmit Margin: This field is intended for debug and compliance testing purposes only. It controls the non-de-emphasized voltage level at the transmitter outputs. Its encodings are: 000: Normal operating range. 001: 800 - 1200 mV for full swing and 400 - 700 mV for half swing. 010 - 111: See PCI Express Base Specification 2.0. This field is reset to 0 when the LTSSM enters the Polling.Configuration substate during link training. STICKY.
    Bits:  6    SDE(ro) - Selectable De-emphasis: This bit selects the de-emphasis level when the Controller is operating at 5 GT/s (0 = -6 dB, 1 = -3.5 dB). This is reserved for Endpoints.
    Bits:  5    HASD(rw) - Hardware Autonomous Speed Disable: When this bit is set, the LTSSM is prevented from changing the operating speed of the link, other than reducing the speed to correct unreliable operation of the link. STICKY
    Bits:  4    EC(rw) - Enter Compliance: This bit is used to force the Endpoint device to enter the Compliance mode. Software sets this bit to 1 and initiates a hot reset to force the device into the Compliance mode. The target speed for the Compliance mode is determined by the Target Link Speed field of this register. STICKY.
    Bits:  3:0  TLS(rw) - Target Link Speed: For an upstream component, this field sets an upper limit on Link operational speed during reconfiguration. Additionally for both upstream and downstream components, this field sets the target speed when the software forces the link into Compliance mode by setting the Enter Compliance bit in this register (0001 = 2.5 GT/s, 0010 = 5 GT/s, 0011 = 8 GT/s). The default value of this field is 0001 (2.5 GT/s) when the PCIE_GENERATION_SEL strap pins of the Controller are set to 0, 0010 (5 GT/s) when the strap is set to 1, 0011 (8 GT/s) when the strap pin is set to 10. These bits are STICKY.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_I_LINK_CTRL_STATUS_2 0x000000f0
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_R21(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_R21_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_LE BIT(21)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EP3S BIT(20)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EP2S BIT(19)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EP1S BIT(18)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EQC BIT(17)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_CDEL BIT(16)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_CDE(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_CDE_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_CS BIT(11)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EMC BIT(10)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_TM(_x) (((_x) & 0x7) << 7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_TM_of(_x) (((_x) >> 7) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_SDE BIT(6)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_HASD BIT(5)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_EC BIT(4)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_TLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_CAP_STRUCT_I_LINK_CTRL_STATUS_2_TLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_AER_enhanced_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 4'h2, but can be modified from the local management bus.
    Bits: 15:0  PEECI(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express AER Extended Capability Structure (0001 hex).
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_AER_ENHANCED_CAP_HDR 0x00000100
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_PEECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_PEECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_status -
    Bits: 31:23 R3(ro) - Reserved:
    Bits: 22    UIE(w1c) - Uncorrectable Internal Error Status: This bit is set when the Controller has detected an internal uncorrectable error (HAL parity error or an uncorrectable ECC error while reading from any of the RAMs). This bit is also set in response to the client signaling an internal error through the input UNCORRECTABLE_ERROR_IN. This error is not Function-specific. This error is considered fatal by default, and is reported by sending an ERR_FATAL message. STICKY.
    Bits: 21    R2(ro) - Reserved: Reserved
    Bits: 20    URES(w1c) - Unsupported Request Error Status: This bit is set when the Controller has received a request from the link that it does not support. This error is not Function-specific. This error is considered non-fatal by default. In the special case described in Sections 6.2.3.2.4.1 of the PCI Express Specifications, the error is reported by sending an ERR_COR message. In all other cases, the error is reported by sending an ERR_NONFATAL message. The header of the received request that caused the error is logged in the Header Log Registers. STICKY.
    Bits: 19    EES(w1c) - ECRC Error Status: This bit is set when the Controller has detected an ECRC error in a received TLP. This error is not Function-specific. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 18    MTS(w1c) - Malformed TLP Status: This bit is set when the Controller receives a malformed TLP from the link. This error is not Function-specific. This error is considered fatal by default, and is reported by sending an ERR_FATAL message. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 17    ROS(w1c) - Receiver Overflow Status: This bit is set when the Controller receives a TLP in violation of the receive credit currently available. This error is not Function-specific. STICKY.
    Bits: 16    UCS(w1c) - Unexpected Completion Status: This bit is set when the Controller has received an unexpected Completion packet from the link. This error is not Function-specific. STICKY.
    Bits: 15    CAS(w1c) - Completer Abort Status: This bit is set when the Controller has returned the Completer Abort (CA) status to a request received from the link. This error is Function-specific. The header of the received request that caused the error is logged in the Header Log Registers. STICKY.
    Bits: 14    CTS(w1c) - Completion Timeout Status: This bit is set when the completion timer associated with an outstanding request times out. This error is Function-specific. This error is considered non-fatal by default. STICKY.
    Bits: 13    FCPES(w1c) - Flow Control Protocol Error Status: This bit is set when certain violations of the flow control protocol are detected by the Controller. Controller reports FCPE upon the following conditions: (i) InitFC/UpdateFC DLLP received which issues more than 2047 cumulative outstanding unused credits to the Transmitter for data payload or 127 for header. (ii) InitFC_P is received with Payload Credits less than 128B, Or (iii)InitFC_CPL is received with Payload Credits less than 128B. This error is not Function-specific STICKY.
    Bits: 12    PTS(w1c) - Poisoned TLP Status: This bit is set when the Controller receives a poisoned TLP from the link. This error is Function-specific. This error is considered non-fatal by default. The error is reported by sending an ERR_NONFATAL message. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 11:5  R1(ro) - Reserved: Reserved
    Bits:  4    DLPES(w1c) - Data Link Protocol Error Status: This bit is set when the Controller receives an Ack or Nak DLLP whose sequence number does not correspond to that of an unacknowledged TLP or that of the last acknowledged TLP (for details, refer to PCI Express Base Specification 1.1, Section 3.5.2). This error is not Function-specific, and is reported by Function 0. STICKY.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_UNCORR_ERR_STATUS 0x00000104
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R3(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R3_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_UIE BIT(22)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R2 BIT(21)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_URES BIT(20)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_EES BIT(19)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_MTS BIT(18)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_ROS BIT(17)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_UCS BIT(16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_CAS BIT(15)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_CTS BIT(14)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_FCPES BIT(13)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_PTS BIT(12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R1(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R1_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_DLPES BIT(4)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_mask -
    Bits: 31:23 R7(ro) - Reserved: Reserved
    Bits: 22    UIEM(rw) - Uncorrectable Internal Error Mask: This bit is set to mask the reporting of internal errors. STICKY.
    Bits: 21    R6(ro) - Reserved: Reserved
    Bits: 20    UREM(rw) - Unsupported Request Error Mask: This bit is set to mask the reporting of unexpected requests received from the link. STICKY.
    Bits: 19    EEM(rw) - ECRC Error Mask: This bit is set to mask the reporting of ECRC errors. STICKY.
    Bits: 18    MTM(rw) - Malformed TLP Mask: This bit is set to mask the reporting of malformed TLPs received from the link. STICKY.
    Bits: 17    ROM(rw) - Receiver Overflow Mask: This bit is set to mask the reporting of violations of receive credit. STICKY.
    Bits: 16    UCM(rw) - Unexpected Completion Mask: This bit is set to mask the reporting of unexpected Completions received by the Controller. STICKY.
    Bits: 15    CAM(rw) - Completer Abort Mask: This bit is set to mask the reporting of the Controller sending a Completer Abort. STICKY.
    Bits: 14    CTM(rw) - Completion Timeout Mask: This bit is set to mask the reporting of Completion Timeouts. STICKY.
    Bits: 13    FCPEM(rw) - Flow Control Protocol Error Mask: This bit is set to mask the reporting of Flow Control Protocol Errors. STICKY.
    Bits: 12    PTM(rw) - Poisoned TLP Mask: This bit is set to mask the reporting of a Poisoned TLP. STICKY.
    Bits: 11:5  R5(ro) - Reserved: Reserved
    Bits:  4    DLPEM(rw) - Data Link Protocol Error Mask: This bit is set to mask the reporting of Data Link Protocol Errors. STICKY.
    Bits:  3:0  R4(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_UNCORR_ERR_MASK  0x00000108
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R7(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R7_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_UIEM BIT(22)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R6 BIT(21)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_UREM BIT(20)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_EEM BIT(19)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_MTM BIT(18)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_ROM BIT(17)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_UCM BIT(16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_CAM BIT(15)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_CTM BIT(14)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_FCPEM BIT(13)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_PTM BIT(12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R5(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R5_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_DLPEM BIT(4)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R4(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R4_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_severity -
    Bits: 31:23 R12(ro) - Reserved: Reserved
    Bits: 22    UIES(rw) - Uncorrectable Internal Error Severity: Severity of internal errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 21    R11(ro) - Reserved: Reserved
    Bits: 20    URES(rw) - Unsupported Requeset Error Severity: Severity of unexpected requests received from the link (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 19    EES(rw) - ECRC Error Severity: Severity of ECRC errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 18    MTS(rw) - Malformed TLP Severity: Severity of malformed TLPs received from the link (0 = Non- Fatal, 1 = Fatal). STICKY.
    Bits: 17    ROS(rw) - Receiver Overflow Severity: Severity of receive credit violations (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 16    UCS(rw) - Unexpected Completion Severity: Severity of unexpected Completions received by the Controller (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 15    CAS(rw) - Completer Abort Severity: Severity of sending a Completer Abort (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 14    CTS(rw) - Completion Timeout Severity: Severity of Completion Timeouts (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 13    FCPES(rw) - Flow Control Protocol Error Severity: Severity of Flow Control Protocol Errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 12    PTS(rw) - Poisoned TLP Severity: Severity of a Poisoned TLP error (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 11:6  R10(ro) - Reserved: Reserved
    Bits:  5    SDES(ro) - Surprise Down Error Severity: hard coded to 1
    Bits:  4    DLPER(rw) - Data Link Protocol Error Severity: Severity of Data Link Protocol Errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits:  3:0  R8(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_UNCORR_ERR_SEVERITY 0x0000010c
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R12(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R12_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_UIES BIT(22)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R11 BIT(21)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_URES BIT(20)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_EES BIT(19)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_MTS BIT(18)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_ROS BIT(17)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_UCS BIT(16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_CAS BIT(15)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_CTS BIT(14)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_FCPES BIT(13)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_PTS BIT(12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R10(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R10_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_SDES BIT(5)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_DLPER BIT(4)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R8(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R8_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_corr_err_status -
    Bits: 31:16 R14(ro) - Reserved: Reserved
    Bits: 15    HLOS(w1c) - Header Log Overflow Status: This bit is set on a Header Log Register overflow, that is, when the header could not be logged in the Header Log Register because it is occupied by a previous header. STICKY.
    Bits: 14    CIES(w1c) - Corrected Internal Error Status: This bit is set when the Controller has detected an internal correctable error condition (a correctable ECC error while reading from any of the RAMs). This bit is also set in response to the client signaling an internal error through the input CORRECTABLE_ERROR_IN. This error is not Function-specific. STICKY.
    Bits: 13    ANFES(w1c) - Advisory Non-Fatal Error Status: This bit is set when an uncorrectable error occurs, which is determined to belong to one of the special cases described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications. This causes the Controller to generate an ERR_COR message in place of an ERR_NONFATAL message. STICKY.
    Bits: 12    RTTS(w1c) - Replay Timer Timeout Status: This bit is set when the replay timer in the Data Link Layer of the Controller times out, causing the Controller to retransmit a TLP. This error is not Function-specific. STICKY.
    Bits: 11:9  R13(ro) - Reserved: Reserved
    Bits:  8    RNRS(w1c) - Replay Number Rollover Status: This bit is set when the replay count rolls over after three re-transmissions of a TLP at the Data Link Layer of the Controller. This error is not Function-specific STICKY.
    Bits:  7    BDS(w1c) - Bad DLLP Status: This bit is set when an LCRC error is detected in a received DLLP, and no errors were detected by the Physical Layer. This error is not Function-specific. STICKY.
    Bits:  6    BTS(w1c) - Bad TP Status: This bit is set when an error is detected in a received TLP by the Data Link Layer of the Controller. The conditions causing this error are: (i) An LCRC error (ii) The packet terminates with EDB symbol, but its LCRC field does not equal the inverted value of the calculated CRC. This error is not Function-specific. STICKY.
    Bits:  5:1  R12(ro) - Reserved: Reserved
    Bits:  0    RES(w1c) - Receiver Error Status: This bit is set when an error is detected in the receive side of the Physical Layer of the Controller (e.g. a bit error or coding violation). This bit is set upon any of the following errors: (1) PHY reported 8B10B error, Disparity Error, Elastic Buffer Overflow Error, Underflow Error (2) GEN3 TLP, DLLP Framing Errors (3) OS Block Received Without EDS (4) Data Block Received After EDS (5) Illegal OS Block After EDS (6) OS Block Received After SKIP OS (7) OS Block Received After SDS (8) Sync Header Error (9) Loss of Gen3 Block Alignment This error is not Function-specific. STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_CORR_ERR_STATUS  0x00000110
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R14(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R14_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_HLOS BIT(15)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_CIES BIT(14)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_ANFES BIT(13)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RTTS BIT(12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R13(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R13_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RNRS BIT(8)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_BDS BIT(7)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_BTS BIT(6)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R12(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R12_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RES BIT(0)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_corr_err_mask -
    Bits: 31:16 R17(ro) - Reserved: Reserved
    Bits: 15    HLOM(rw) - Header Log Overflow Mask: This bit, when set, masks the generation of error messages in response to a Header Log register overflow. STICKY.
    Bits: 14    CIEM(rw) - Corrected Internal Error Mask: This bit, when set, masks the generation of error messages in response to a corrected internal error condition. STICKY.
    Bits: 13    ANFEM(rw) - Advisory Non-Fatal Error Mask: This bit, when set, masks the generation of error messages in response to an uncorrectable error occur, which is determined to belong to one of the special cases (as described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications). STICKY.
    Bits: 12    RTTM(rw) - Replay Timer Timeout Mask: This bit, when set, masks the generation of error messages in response to a Replay Timer timeout event. STICKY.
    Bits: 11:9  R16(ro) - Reserved: Reserved
    Bits:  8    RNRM(rw) - Replay Number Rollover Mask: This bit, when set, masks the generation of error messages in response to a Replay Number Rollover event. STICKY.
    Bits:  7    BDM(rw) - Bad DLLP Mask: This bit, when set, masks the generation of error messages in response to a 'Bad DLLP' received. STICKY.
    Bits:  6    BTM(rw) - Bad TLP Mask: This bit, when set, masks the generation of error messages in response to a 'Bad TLP' received. STICKY.
    Bits:  5:1  R15(ro) - Reserved: Reserved
    Bits:  0    REM(rw) - Receiver Error Mask: This bit, when set, masks the generation of error messages in response to the Physical Layer errors STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_CORR_ERR_MASK    0x00000114
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R17(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R17_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_HLOM BIT(15)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_CIEM BIT(14)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_ANFEM BIT(13)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_RTTM BIT(12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R16(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R16_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_RNRM BIT(8)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_BDM BIT(7)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_BTM BIT(6)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R15(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_R15_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_CORR_ERR_MASK_REM BIT(0)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_advcd_err_cap_ctrl -
    Bits: 31:12 R18(ro) - Reserved: Reserved
    Bits: 11    R11(ro) - Reserved: Reserved
    Bits: 10    MHRE(ro) - Multiple Header Recording Enable: Setting this bit enables the Function to log multiple error headers in its Header Log Registers. It is hardwired to 0
    Bits:  9    MHRC(ro) - Multiple Header Recording Capable: This bit is set when the Function has the capability to log more than one error header in its Header Log Registers. It is hardwired to 0.
    Bits:  8    EEC(rw) - Enable ECRC Check: Setting this bit enables ECRC checking on the receive side of the Controller. This bit is writable from the local management bus. STICKY.
    Bits:  7    ECC(rw) - ECRC Check Capability: This read-only bit indicates to the software that the device is capable of checking ECRC in packets received from the link. This bit is writable from the local management bus.
    Bits:  6    EEG(rw) - Enable ECRC Generation: Setting this bit enables the ECRC generation on the transmit side of the Controller. This bit is writable from the local management bus. STICKY.
    Bits:  5    EGC(rw) - ECRC Generation Capability: This read-only bit indicates to the software that the device is capable of generating ECRC in packets transmitted on the link. This bit is writable from the local management bus.
    Bits:  4:0  FER(ro) - First Error Pointer: This is a 5-bit pointer to the bit position in the Uncorrectable Error Status Register corresponding to the error that was detected first. When there are multiple bits set in the Uncorrectable Error Status Register, this field informs the software which error was observed first. To prevent the field from being overwritten before software was able to read it, this field is not updated while the status bit pointed by it in the Uncorrectable Error Status Register remains set. After the software clears this status bit, a subsequent error condition that sets any bit in the Uncorrectable Error Status Register will update the First Error Pointer. Any uncorrectable error type, including the special cases where the error is reported using an ERR_COR message, will set the First Error Pointer (assuming the software has reset the error pointed by it in the Uncorrectable Error Status Register). STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_ADVCD_ERR_CAP_CTRL 0x00000118
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_R18(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_R18_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_R11 BIT(11)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_MHRE BIT(10)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_MHRC BIT(9)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_EEC BIT(8)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_ECC BIT(7)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_EEG BIT(6)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_EGC BIT(5)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_FER(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_FER_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_0 -
    Bits: 31:0  HD0(ro) - Header DWORD 0: First DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_HDR_LOG_0        0x0000011c
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_0_HD0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_0_HD0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_1 -
    Bits: 31:0  HD1(ro) - Header DWORD 1: Second DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_HDR_LOG_1        0x00000120
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_1_HD1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_1_HD1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_2 -
    Bits: 31:0  HD2(ro) - Header DWORD 2: Third DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_HDR_LOG_2        0x00000124
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_2_HD2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_2_HD2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_3 -
    Bits: 31:0  HD3(ro) - Header DWORD 3: Fourth DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_I_HDR_LOG_3        0x00000128
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_3_HD3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_AER_CAP_STRUCT_I_HDR_LOG_3_HD3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_ARI_cap_struct_i_ARI_ext_cap_hdr -
    Bits: 31:20 ARINCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 ARICV(rw) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is set to 1 by default, but can be modified independently for each Function from the local management bus
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the ARI Extended Capability (000E hex).
*/
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_I_ARI_EXT_CAP_HDR  0x00000140
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_ARINCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_ARINCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_ARICV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_ARICV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_ARI_cap_struct_i_ARI_cap_and_ctrl -
    Bits: 31:16 ACR(ro) - ARI Control Register: ARI Control Register not implemented in this Controller. This field is hardwired to 0.
    Bits: 15:8  NF(rw) - Next Function: Points to the next Physical Function in the device. This field is set by default to point to the next Physical Function, 0 for last Function. It can be rewritten from the local management bus.
    Bits:  1    AFGC(ro) - ACS Function Groups Capability: Relevant only when ACS Capability is supported. This field is hardwired to 0.
    Bits:  0    MFGC(ro) - MFVC Function Groups Capability: Set when device supports arbitration at the Function Group-level. This field is hardwired to 0.
*/
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_I_ARI_CAP_AND_CTRL 0x00000144
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_ACR(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_ACR_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_NF(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_NF_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_AFGC BIT(1)
#define   NFP3800_PCIEX_PF_I_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_MFGC BIT(0)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr -
    Bits: 31:20 SNNCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 DSNCV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus by writing into Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express Device Serial Number Capability (0001 hex).
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_I_DEV_SER_NUM_CAP_HDR 0x00000150
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_SNNCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_SNNCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_DSNCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_DSNCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_0 -
    Bits: 31:0  DSND0(rw) - Device Serial Number, Doubleword 0: This field contains the first 32 bits of the device's serial number.
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_I_DEV_SER_NUM_0 0x00000154
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_0_DSND0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_0_DSND0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_1 -
    Bits: 31:0  DSND1(rw) - Device Serial Number, Doubleword 1: This field contains the last 32 bits of the device's serial number.
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_I_DEV_SER_NUM_1 0x00000158
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_1_DSND1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_DEVICE_SERIAL_NUM_CAP_STRUCT_I_DEV_SER_NUM_1_DSND1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr -
    Bits: 31:20 PBNCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 PCV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus by writing into Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express Power Budgeting Capability (0004 hex).
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_I_PWR_BDGTG_ENHC_CAP_HDR 0x00000160
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PBNCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PBNCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_ENHC_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel -
    Bits: 31:8  R0(ro) - Reserved:
    Bits:  7:0  PBDN(rw) - Power Budgeting Data Index: This field selects the power budgeting data read from the Power Budgeting Data Register. Its settings are: 00: Selects power budgeting data for power state D0 MAX for the associated PF. 01: Selects power budgeting data for power state D0 SUSTAINED for the associated PF. 10: Selects power budgeting data for power state D3hot for the associated PF. 11: Selects power budgeting data for power state D1 for the associated PF. Others: Not a valid setting. A read from the Power Budgeting Data Register returns all zeroes.
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_I_PWR_BDGTG_DATA_SEL 0x00000164
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_SEL_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_SEL_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_SEL_PBDN(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_SEL_PBDN_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register -
    Bits: 31:21 R1(ro) - Reserved: Reserved
    Bits: 20:18 PR(rw) - Power Rail: Specifies the power rail corresponding to the power management data in this register.
    Bits: 17:15 TYPE(rw) - Type: Specifies the operation condition for which the data applies.
    Bits: 14:13 PS(rw) - PM State: Specifies the power management state of the Function, for which this power management data applies.
    Bits: 12:10 PSS(rw) - PM Sub-State: Specifies the power management sub-state of the selected power state
    Bits:  9:8  DS(rw) - Data Scale: Scale factor applicable to the Base Power field.
    Bits:  7:0  BP(rw) - Base Power: Specifies base power(in watts) of the selected power state
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_I_PWR_BDGTG_DATA_REGISTER 0x00000168
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_R1(_x) (((_x) & 0x7ff) << 21)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_R1_of(_x) (((_x) >> 21) & 0x7ff)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PR(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PR_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_TYPE(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_TYPE_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PS(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PS_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PSS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_PSS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_DS(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_DS_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_BP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGTG_DATA_REGISTER_BP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgt_cap -
    Bits: 31:1  R4(ro) - Reserved: Reserved
    Bits:  0    SA(rw) - System Allocated: This bit is set to indicate that the device power specified by this Power Management Capability Structure is included in the system power budget. When this bit set, the software must exclude the device power reported by this Capability Structure from power calculations, when making power budgeting decisions. This bit is set to 0 by default, but its setting can be modified individually for each PF from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_I_PWR_BDGT_CAP 0x0000016c
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGT_CAP_R4(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGT_CAP_R4_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_I_POWER_BUDGETING_CAP_STRUCT_I_PWR_BDGT_CAP_SA BIT(0)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Resizable BAR Capability (0015 hex).
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_EXT_CAP_HDR 0x00000180
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_EXT_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_0 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_0 0x00000184
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_0_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_0 0x00000188
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_0_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_1 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_1 0x0000018c
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_1_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_1 0x00000190
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_1_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_2 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_2 0x00000194
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_2_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_2 0x00000198
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_2_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_3 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_3 0x0000019c
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_3_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_3 0x000001a0
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_3_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_4 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_4 0x000001a4
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_4_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_4 0x000001a8
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_4_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_5 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CAP_5 0x000001ac
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A512G BIT(23)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A256G BIT(22)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A128G BIT(21)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A64G BIT(20)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A32G BIT(19)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A16G BIT(18)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A8G BIT(17)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A4G BIT(16)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A2G BIT(15)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A1G BIT(14)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A512M BIT(13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A256M BIT(12)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A128M BIT(11)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A64M BIT(10)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A32M BIT(9)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A16M BIT(8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A8M BIT(7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A4M BIT(6)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A2M BIT(5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_A1M BIT(4)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CAP_5_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_I_RESIZE_BAR_CTRL_5 0x000001b0
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_RESIZABLE_BAR_CAP_STRUCT_I_RESIZE_BAR_CTRL_5_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_LTR_cap_struct_i_LTR_ext_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Latency Tolerance Reporting Capability (0018 hex).
*/
#define NFP3800_PCIEX_PF_i_LTR_cap_struct_I_LTR_EXT_CAP_HDR  0x000001b8
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_EXT_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_LTR_cap_struct_i_LTR_snoop_lat -
    Bits: 31:29 R1(ro) - Reserved: Reserved
    Bits: 28:26 MNSLS(rw) - Max No-Snoop Latency Scale: Specifies the scale value for the Max No-Snoop Latency. When the setting of this field is non-zero, the actual snoop latency is determined by multiplying the Max No-Snoop Latency by the following scale factors: 001: 32 ns, 010: 1024 ns, 011: 32,768 ns, 100: 1,047,576 ns, 101: 33,554,432 ns, 110-111: Reserved
    Bits: 25:16 MNSL(rw) - Max No-Snoop Latency: When multiplied by the value of the Max No-Snoop Latency Scale, this field defines the maximum no-snoop value the device is permitted to request in an LTR message. This field can be written independently for each Physical Function from the local management bus.
    Bits: 15:13 R0(ro) - Reserved: Reserved
    Bits: 12:10 MSLS(rw) - Max Snoop Latency Scale: Specifies the scale value for the Max Snoop Latency. When the setting of this field is non-zero, the actual snoop latency is determined by multiplying the Max Snoop Latency by the following scale factors: 001: 32 ns, 010: 1024 ns, 011: 32,768 ns, 100: 1,047,576 ns, 101: 33,554,432 ns, 110-111: Reserved
    Bits:  9:0  MSL(rw) - Max Snoop Latency: When multiplied by the value of the Max Snoop Latency Scale, this field defines the maximum snoop value the device is permitted to request in an LTR message. This field can be written independently for each Physical Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_LTR_cap_struct_I_LTR_SNOOP_LAT    0x000001bc
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_R1(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_R1_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MNSLS(_x) (((_x) & 0x7) << 26)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MNSLS_of(_x) (((_x) >> 26) & 0x7)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MNSL(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MNSL_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_R0(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_R0_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MSLS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MSLS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MSL(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_PF_I_LTR_CAP_STRUCT_I_LTR_SNOOP_LAT_MSL_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each Function from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the SR-IOV Extended Capability Structure (0010 hex).
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_SRIOV_EXT_CAP_HEADER_REG 0x00000200
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_EXT_CAP_HEADER_REG_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_cap_reg -
    Bits: 31:3  R31(ro) - Reserved: Reserved
    Bits:  2    R2(ro) - Reserved: Reserved
    Bits:  1    ACHP(rw) - ARI Capable Hierarchy Preserved: A 1 in this bit position indicates that the ARI Capable Hierarchy bit in the SR-IOV Control Register is preserved across certain power state transitions (see the PCI-SIG Single Root IO Virtualization and Sharing Specifications, Version 1.1, Section 3.3.3.5 for details). This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    VFMC(ro) - VF Migration Capable: Set when the Controller supports VF migration. Hardwired to 0.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_SRIOV_CAP_REG  0x00000204
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CAP_REG_R31(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CAP_REG_R31_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CAP_REG_R2 BIT(2)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CAP_REG_ACHP BIT(1)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CAP_REG_VFMC BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg -
    Bits: 31:16 SSR(ro) - SRIOV Status Register: Not implemented.
    Bits: 15:6  R15(ro) - Reserved: Reserved
    Bits:  5    R5(ro) - Reserved: Reserved
    Bits:  4    ARIE(rw) - ARI Capable Hierarchy: This bit enables the ARI mode for Virtual Functions. ARI Capable Hierarchy is only present in the lowest numbered PF which is enabled (for example PF0) and affects all PFs of the Device. ARI Capable Hierarchy is Read Only Zero in other PFs of a Device.
    Bits:  3    VFMSE(rw) - VF Memory Space Enable: This bit must be set to allow access to the memory space of the VFs associated with this PF.
    Bits:  2    VFMIE(rw) - VF Migration Interrupt Enable: Not supported. Hardwired to 0
    Bits:  1    VFME(rw) - VF Migration Enable: Not supported. Hardwired to 0
    Bits:  0    VFE(rw) - VF Enable: This bit must be set to enable the VFs associated with this PF.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_SRIOV_CTRL_STATUS_REG 0x00000208
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_SSR(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_SSR_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_R15(_x) (((_x) & 0x3ff) << 6)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_R15_of(_x) (((_x) >> 6) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_R5 BIT(5)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_ARIE BIT(4)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_VFMSE BIT(3)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_VFMIE BIT(2)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_VFME BIT(1)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SRIOV_CTRL_STATUS_REG_VFE BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_initial_total_VFs_reg -
    Bits: 22:16 TVF(rw) - Total VFs: This field contains the total number of VFs per PF. Its default setting is identical to that of InitialVFs. This field can be modified using local management registers.
    Bits:  6:0  IVF(rw) - Initial VFs: This field contains the initial number of VFs configured for each PF. This field can be modified using local management registers. Please see the `define den_db_PFx_TOTAL_VF_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_INITIAL_TOTAL_VFS_REG 0x0000020c
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_INITIAL_TOTAL_VFS_REG_TVF(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_INITIAL_TOTAL_VFS_REG_TVF_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_INITIAL_TOTAL_VFS_REG_IVF(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_INITIAL_TOTAL_VFS_REG_IVF_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg -
    Bits: 23:16 FDL(rw) - Function Dependency Link: This field is used to specify dependencies between PFs. It can be modified independently for each Function from the local management bus. Please see the `define den_db_Fx_SR_IOV_FUNCTION_DEPENDENCY_LINK values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 15:0  NVF(rw) - NumVFs: This field must be set by the software to the number of VFs that it wants to enable for each PF. This field can be changed only when the VF Enable bit in the SR-IOV Control Register is 0. Its value should not exceed the setting of TotalVFs for the corresponding Physical Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_FUNC_DEP_LINK_NUMVFS_REG 0x00000210
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_FUNC_DEP_LINK_NUMVFS_REG_FDL(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_FUNC_DEP_LINK_NUMVFS_REG_FDL_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_FUNC_DEP_LINK_NUMVFS_REG_NVF(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_FUNC_DEP_LINK_NUMVFS_REG_NVF_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_offset_stride_reg -
    Bits: 31:16 VFS(ro) - VF Stride: Stride value used to assign RIDs for VFs. The stride value is hardwired to 1 for all Physical Functions.
    Bits: 15:0  FVFO(rw) - First VF Offset: Offset of First VF relative to its PF. This field can be re-written independently for each PF from the local management bus. Please see the `define den_db_Fx_VF_ADDR_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_OFFSET_STRIDE_REG 0x00000214
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_OFFSET_STRIDE_REG_VFS(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_OFFSET_STRIDE_REG_VFS_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_OFFSET_STRIDE_REG_FVFO(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_OFFSET_STRIDE_REG_FVFO_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_device_id_reg -
    Bits: 31:16 VFDI(rw) - VF Device ID: VF device id assigned to the device. Its default value is specified in reg_defaults.h, but can be re-written independently for each PF from the local management bus.
    Bits: 15:0  R2(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_DEVICE_ID_REG 0x00000218
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_DEVICE_ID_REG_VFDI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_DEVICE_ID_REG_VFDI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_DEVICE_ID_REG_R2(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_DEVICE_ID_REG_R2_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_supported_page_size_reg -
    Bits: 31:16 R0(ro) - Reserved: Reserved
    Bits: 15:0  PS(rw) - Page Sizes: Page sizes supported by the device (one bit for each page size). The Controller implements only bits 15:0 of this register. The default value of this field is specified in reg_defaults.h, but can be re-written independently for each PF from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_SUPPORTED_PAGE_SIZE_REG 0x0000021c
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SUPPORTED_PAGE_SIZE_REG_R0(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SUPPORTED_PAGE_SIZE_REG_R0_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SUPPORTED_PAGE_SIZE_REG_PS(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SUPPORTED_PAGE_SIZE_REG_PS_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_system_page_size_reg -
    Bits: 31:16 R0(ro) - Reserved: Reserved
    Bits: 15:0  SPS(rw) - System Page Size: This field must be programmed by software to the current page size in use. TheController implements only bits 15:0 of this register. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_SYSTEM_PAGE_SIZE_REG 0x00000220
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SYSTEM_PAGE_SIZE_REG_R0(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SYSTEM_PAGE_SIZE_REG_R0_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SYSTEM_PAGE_SIZE_REG_SPS(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_SYSTEM_PAGE_SIZE_REG_SPS_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_0_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 1 is treated as a continuation of the base address in BAR 0. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_0_REG   0x00000224
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_P0 BIT(3)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_S0 BIT(2)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_R7 BIT(1)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_0_REG_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_1_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_1_REG   0x00000228
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_1_REG_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_1_REG_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_2_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 3 is treated as a continuation of the base address in BAR 2. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_2_REG   0x0000022c
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_P0 BIT(3)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_S0 BIT(2)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_R7 BIT(1)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_2_REG_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_3_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_3_REG   0x00000230
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_3_REG_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_3_REG_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_4_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 5 is treated as a continuation of the base address in BAR 4. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_4_REG   0x00000234
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_P0 BIT(3)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_S0 BIT(2)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_R7 BIT(1)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_4_REG_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_5_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_BAR_5_REG   0x00000238
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_5_REG_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_BAR_5_REG_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_migration_state_arr_offset_reg -
    Bits: 31:0  MSAOR(ro) - NA
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_I_VF_MIGRATION_STATE_ARR_OFFSET_REG 0x0000023c
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_MIGRATION_STATE_ARR_OFFSET_REG_MSAOR(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_SRIOV_CAP_STRUCT_I_VF_MIGRATION_STATE_ARR_OFFSET_REG_MSAOR_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the TPH Requester Capability.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_REQ_EXT_CAP_HEADER_REG 0x00000274
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_cap_reg -
    Bits: 31:27 R2(ro) - Reserved: Reserved
    Bits: 26:16 STS(rw) - ST Table Size: Specifies the number of entries in the Steering Tag Table (0 = 1 entry, 1 = 2 entries, and so on). Max limit is 64 entries when the ST Table is located in the TPH Requester Capability Structure, and 2048 entries when located in the MSI-X table. Each entry is 16 bits long. This field can be modified from the local management bus.
    Bits: 15:11 R1(ro) - Reserved: Reserved
    Bits: 10:9  STL(rw) - ST Table Location: The setting of this field indicates if a Steering Tag Table is implemented for this Function, and its location if present. (00 = ST Table not present, 01 = ST Table in the TPH Requester Capability Structure, 10 = ST values stored in the MSI-X Table in client RAM, 11 = reserved.). This field can be modified from the local management bus.
    Bits:  8    ERS(ro) - Extended TPH Requester Supported: When set to 1, indicates that the Function is capable of generating requests with a TPH TLP Prefix.
    Bits:  7:3  R0(ro) - Reserved: Reserved
    Bits:  2    DSMS(rw) - Device-Specific Mode Supported: A setting of 1 indicates that the Function supports the Device- Specific Mode for TPH Steering Tag generation. In this mode, the Steering Tags are supplied by the client for each request through the HAL master interface. The client typically chooses the Steering Tag values from the ST Table, but is not required to do so. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  1    IVMS(rw) - Interrupt Vector Mode Supported: A setting of 1 indicates that the Function supports the Interrupt Vector Mode for TPH Steering Tag generation. In the Interrupt Vector Mode, Steering Tags are attached to MSI/MSI-X interrupt requests. The Steering Tag for each interrupt request is selected by the MSI/MSI-X interrupt vector number. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    NSM(ro) - No ST Mode Supported: When set to 1, indicates that this Function supports the 'No ST Mode' for the generation of TPH Steering Tags. In the No ST Mode, the device must use a Steering Tag value of 0 for all requests. This bit is hardwired to 1, as all TPH Requesters are required to support the No ST Mode of operation.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_REQ_CAP_REG  0x00000278
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R2(_x) (((_x) & 0x1f) << 27)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R2_of(_x) (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R1(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R1_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STL(_x) (((_x) & 0x3) << 9)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STL_of(_x) (((_x) >> 9) & 0x3)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_ERS BIT(8)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R0(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R0_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_DSMS BIT(2)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_IVMS BIT(1)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_NSM BIT(0)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_ctrl_reg -
    Bits: 31:10 R10(ro) - Reserved: Reserved
    Bits:  9:8  CRE(rw) - TPH Requester Enable: When set , the Function is allowed to generate requests with Transaction Processing Hints. Defined Encodings are: 00b - Function operating as a Requester is not permitted to issue Requests with TPH or Extended TPH. 01b - Function operating as a Requester is permitted to issue Requests with TPH and is not permitted to issue Requests with Extended TPH. 10b - Reserved. 11b - Function operating as a Requester is permitted to issue Requests with TPH and Extended TPH.
    Bits:  2:0  CSM(rw) - ST Mode: This field selects the ST mode (000 = No Steering Tag Mode, 001 = Interrupt Vector Mode, 010 = Device-Specific Mode, other values are reserved). The TPH_ST_MODE output of the Controller reflects the setting of this register field. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_REQ_CTRL_REG 0x0000027c
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_R10(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_R10_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_CRE(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_CRE_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_CSM(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_CSM_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_tab_0 -
  Register: i_TPH_cap_struct_i_TPH_tab_1 -
  Register: i_TPH_cap_struct_i_TPH_tab_2 -
  Register: i_TPH_cap_struct_i_TPH_tab_3 -
  Register: i_TPH_cap_struct_i_TPH_tab_4 -
  Register: i_TPH_cap_struct_i_TPH_tab_5 -
  Register: i_TPH_cap_struct_i_TPH_tab_6 -
  Register: i_TPH_cap_struct_i_TPH_tab_7 -
  Register: i_TPH_cap_struct_i_TPH_tab_8 -
  Register: i_TPH_cap_struct_i_TPH_tab_9 -
  Register: i_TPH_cap_struct_i_TPH_tab_10 -
  Register: i_TPH_cap_struct_i_TPH_tab_11 -
  Register: i_TPH_cap_struct_i_TPH_tab_12 -
  Register: i_TPH_cap_struct_i_TPH_tab_13 -
  Register: i_TPH_cap_struct_i_TPH_tab_14 -
  Register: i_TPH_cap_struct_i_TPH_tab_15 -
    Bits: 31:24 STU1(ro) - ST Upper 1: This field is used for the upper 8 bits of the second Steering Tag when Extended TPH Requester support is enabled.
    Bits: 23:16 STL1(rw) - ST Lower 1: Lower 8 bits of the second Steering Tag. This is the 8-bit Steering Tag sent out in requests.
    Bits: 15:8  STU0(ro) - ST Upper 0: This field is used for the upper 8 bits of the first Steering Tag when Extended TPH Requester support is enabled.
    Bits:  7:0  STL0(rw) - ST Lower 0: Lower 8 bits of the first Steering Tag. This is the 8-bit Steering Tag sent out in requests.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_0        0x00000280
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_1        0x00000284
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_2        0x00000288
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_3        0x0000028c
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_4        0x00000290
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_5        0x00000294
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_6        0x00000298
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_7        0x0000029c
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_8        0x000002a0
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_9        0x000002a4
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_10       0x000002a8
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_11       0x000002ac
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_12       0x000002b0
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_13       0x000002b4
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_14       0x000002b8
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_I_TPH_TAB_15       0x000002bc
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STU1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STU1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STL1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STL1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STU0(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STU0_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STL0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_TPH_CAP_STRUCT_TPH_ST_TABLE_CL_STL0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECI(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Secondary PCI Express Capability
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_SEC_PCIE_CAP_HDR_REG 0x00000300
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_PECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_SEC_PCIE_CAP_HDR_REG_PECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_link_control3_reg -
    Bits: 31:12 R2(ro) - Reserved: Reserved
    Bits: 11:9  ELSOSGV(rw) - Enable Lower SKP OS Generation Vector: When the Link is in L0 and the bit in this field corresponding to the current Link speed is Set, SKP Ordered Sets are scheduled at the rate defined for SRNS, overriding the rate required based on the clock tolerance architecture.
    Bits:  8:0  R1(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LINK_CONTROL3_REG 0x00000304
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_R2(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_R2_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_ELSOSGV(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_ELSOSGV_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_R1(_x) (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LINK_CONTROL3_REG_R1_of(_x) (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg -
    Bits: 31:8  R0(ro) - Reserved:
    Bits:  7:0  LES(w1c) - Lane Error Status: Each of these bits indicates the error status for the corresponding lane. STICKY.
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LANE_ERROR_STATUS_REG 0x00000308
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_ERROR_STATUS_REG_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_ERROR_STATUS_REG_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_ERROR_STATUS_REG_LES(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_ERROR_STATUS_REG_LES_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 1 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 1 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 0 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 0 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LANE_EQUALIZATION_CONTROL_REG0 0x0000030c
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R3 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R1 BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG0_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 3 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 3 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 2 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 2 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LANE_EQUALIZATION_CONTROL_REG1 0x00000310
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R3 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R1 BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG1_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 5 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 5 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 4 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 4 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LANE_EQUALIZATION_CONTROL_REG2 0x00000314
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R3 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R1 BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG2_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 7 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 7 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 6 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 6 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_I_LANE_EQUALIZATION_CONTROL_REG3 0x00000318
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R3 BIT(31)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R1 BIT(15)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_I_PCIE_SEC_EXT_CAP_STRUCT_I_LANE_EQUALIZATION_CONTROL_REG3_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vsec_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECI(rw) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Vendor-Specific Extended Capability.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_I_VSEC_HEADER_REG 0x00000400
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_PECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VSEC_HEADER_REG_PECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_header_reg -
    Bits: 31:20 VL(rw) - VSEC Length: Total byte count (in hex format) of the VSEC structure, including the Vendor-Specific Capability Header, the Vendor-Specific Header and the Vendor-Specific registers. This field can be written from the local management bus independently or each PF.
    Bits: 19:16 VR(rw) - VSEC Revision: Vendor-defined version number for the VSEC structure. This field can be written from the local management bus independently or each PF.
    Bits: 15:0  VI(rw) - VSEC ID: This field contains a vendor defined ID number that indicates the nature and format of the information in the Vendor-Specific Capability Structure. This field can be written from the local management bus independently or each PF.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_I_VENDOR_SPECIFIC_HEADER_REG 0x00000404
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VL(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VL_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VR(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VR_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_HEADER_REG_VI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_control_reg -
    Bits: 31:9  VSEC_COUT(rw) - VSEC Control Out: The state of these bits drive the output pins Fx_VSEC_CONTROL_OUT ( where x is the function number). These are implemented as register bits that can be read and written by the host through a Config transaction, or via the local management interface.
    Bits:  8    HTI(rw) - Host-Triggered Interrupt: The state of this bit drives the output pins Fx_VSEC_INTERRUPT_OUT ( where x is the function number). It can be used by the host to signal a software-driven interrupt to the application logic outside the Controller. This bit may be read and written by the host through a Config transaction, or via the local management interface.
    Bits:  7:0  VSEC_CIN(ro) - VSEC Control In: The 8-bit value read from this field of PFx reflects the setting of Fx_VSEC_CONTROL_IN[7:0] input to the Controller. This field can also be read from the local management bus
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_I_VENDOR_SPECIFIC_CONTROL_REG 0x00000408
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_CONTROL_REG_VSEC_COUT(_x) (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_CONTROL_REG_VSEC_COUT_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_CONTROL_REG_HTI BIT(8)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_CONTROL_REG_VSEC_CIN(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_CONTROL_REG_VSEC_CIN_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_data_reg0 -
    Bits: 31:0  GPD(rw) - General-Purpose Data: These bits are implemented as register bits that can be read and written by the host through a Config transaction, or via the local management interface. Their use is application-dependent.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_I_VENDOR_SPECIFIC_DATA_REG0 0x0000040c
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_DATA_REG0_GPD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_VSEC_STRUCT_I_VENDOR_SPECIFIC_DATA_REG0_GPD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the L1 PM Substates Extended Capability Structure (001E hex).
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_I_L1_PM_EXT_CAP_HDR 0x00000900
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_EXT_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_cap -
    Bits: 23:19 R0(rw) - Port Power- On Time Value: Along with the Port T_POWER_ON Scale field in the L1 PM Substates Capabilities register sets the time (in us) that this Port requires the port on the opposite side of Link to wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. The value of Port T_POWER_ON is calculated by multiplying the value in this field by the scale value in the Port T_POWER_ON Scale field in the L1 PM Substates Capabilities register. T Power On is the minimum amount of time that each component must wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. This is to ensure no device is ever actively driving into an unpowered component.This bit can be modified using local management interface.
    Bits: 17:16 L1PrtPvrOnScale(rw) - Port Power-On Time Scale: Specifies the scale used for the Port T_POWER_ON Value field in the L1 PM Substates Capabilities register. Range of Values 00b = 2us 01b = 10us 10b = 100us 11b = Reserved Default value is 00.This bit can be modified using local management interface.
    Bits: 15:8  L1PrtCmMdReStrTime(rw) - Port Common Mode Restore Time: Time (in us) required for this Port to re-establish common mode during exit from PM or ASPM L1.2 substate. This bit can be modified using local management interface.
    Bits:  4    L1PMSUPP(rw) - L1 PM Substates Supported: When Set this bit indicates that this Port supports L1 PM Substates.This bit can be modified using local management interface.
    Bits:  3    L1ASPML11SUPP(rw) - ASPML1.1 Supported: When Set this bit indicates that ASPM L1.1 is supported.This bit can be modified using local management interface.
    Bits:  2    L1ASPML12SUPP(rw) - ASPML1.2 Supported: When Set this bit indicates that ASPM L1.2 is supported.This bit can be modified using local management interface.
    Bits:  1    L1PML11SUPP(rw) - PML1.1 Supported: When Set this bit indicates that PCI-PM L1.1 is supported.This bit can be modified using local management interface.
    Bits:  0    L1PML12SUPP(rw) - PML1.2 Supported: When Set this bit indicates that PCI-PM L1.2 is supported. This bit can be modified using local management interface.
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_I_L1_PM_CAP 0x00000904
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_R0(_x) (((_x) & 0x1f) << 19)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_R0_of(_x) (((_x) >> 19) & 0x1f)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PRTPVRONSCALE(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PRTPVRONSCALE_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PRTCMMDRESTRTIME(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PRTCMMDRESTRTIME_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PMSUPP BIT(4)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1ASPML11SUPP BIT(3)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1ASPML12SUPP BIT(2)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PML11SUPP BIT(1)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CAP_L1PML12SUPP BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1 -
    Bits: 31:29 L1ThrshldSc(rw) - LTR L1.2 Threshold Scale: This field provides a scale for the value contained within the LTR_L1.2_THRESHOLD_Value. 000 - Value times 1 ns 001 - Value times 32 ns 010 - Value times 1024 ns 011 - Value times 32,768 ns 100 - Value times 1,048,576 ns 101 - Value times 33,554,422ns 110-111 - Not permitted
    Bits: 25:16 L1ThrshldVal(rw) - LTR L1.2 Threshold Value: Along with the LTR_L1.2_THRESHOLD_Scale, this field indicates the LTR threshold used to determine if entry into L1 results in L1.1 (if enabled) or L1.2 (if enabled).
    Bits: 15:8  L1CmMdReStrTime(ro) - Common Mode Restore Time: This field is reserved for EP.
    Bits:  3    L1ASPML11EN(rw) - ASPML1.1 Enable: When Set this bit enables ASPM L1.1.
    Bits:  2    L1ASPML12EN(rw) - ASPML1.2 Enable: When Set this bit enables ASPM L1.2.
    Bits:  1    L1PML11EN(rw) - PML1.1 Enable: When Set this bit enables PCI-PM L1.1.
    Bits:  0    L1PML12EN(rw) - PML1.2 Enable: When Set this bit enables PCI-PM L1.2.
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_I_L1_PM_CTRL_1 0x00000908
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1THRSHLDSC(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1THRSHLDSC_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1THRSHLDVAL(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1THRSHLDVAL_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1CMMDRESTRTIME(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1CMMDRESTRTIME_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1ASPML11EN BIT(3)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1ASPML12EN BIT(2)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1PML11EN BIT(1)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_1_L1PML12EN BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2 -
    Bits:  7:3  L1PwrOnVal(rw) - T_POWER_ON Value: Along with the T_POWER_ON Scale sets the minimum amount of time (in us) that the Port must wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. T_POWER_ON is calculated by multiplying the value in this field by the value in the T_POWER_ON Scale field.
    Bits:  1:0  L1PwrOnSc(rw) - T_POWER_ON Scale: Specifies the scale used for T_POWER_ON Value. Range of Values 00b = 2us 01b = 10us 10b = 100us 11b = Reserved
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_I_L1_PM_CTRL_2 0x0000090c
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_2_L1PWRONVAL(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_2_L1PWRONVAL_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_2_L1PWRONSC(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_I_REGF_L1_PM_CAP_STRUCT_I_L1_PM_CTRL_2_L1PWRONSC_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_rc_pcie_base_i_RC_generic_reserved_reg -
    Bits: 31:0  rsvd(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_RC_i_rc_pcie_base_I_RC_GENERIC_RESERVED_REG 0x00000000
#define   NFP3800_PCIEX_RC_I_RC_PCIE_BASE_I_RC_GENERIC_RESERVED_REG_RSVD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_RC_I_RC_PCIE_BASE_I_RC_GENERIC_RESERVED_REG_RSVD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pl_config_0_reg -
    Bits: 31    MLE(rw) - Master Loopback Enable: When the Controller is operating as a Root Port, setting this to 1 causes the LTSSM to initiate a loopback and become the loopback master. This bit is not used in the EndPoint Mode.
    Bits: 30    R0(ro) - Remote Linkwidth Upconfigure Capability Status: A 1 in this field indicates that the remote node advertised Linkwidth Upconfigure Capability in the training sequences in the Configuration.Complete state when the link came up. A 0 indicates that the remote node did not set the Link Upconfigure bit.
    Bits: 29:24 LTSSM(ro) - LTSSM State: Current state of the LTSSM. The encoding of the states is given in Appendix C.
    Bits: 23:16 RLID(ro) - Received Link ID: Link ID received from other side during link training.
    Bits: 15:8  RFC(ro) - Received FTS Count for 2.5 GT/s speed: FTS count received from the other side during link training for use at the 2.5 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 2.5 GT/s speed.
    Bits:  7    TSS(rw) - Tx Swing Setting: This bit drives the PIPE_TX_SWING output of the Controller.
    Bits:  6    APER(rw) - Phy Error Reporting: This bit controls the reporting of Errors Detected by the PHY. The Errors Detected by the PHY include:- - Received errors indicated on PIPE RxStatus interface, - 8.0 GT/s Invalid Sync Header received error, If PHY Error Reporting bit is set to 0, the Controller will only report those errors that caused a TLP or DLLP to be dropped because of a Detected PHY Error. If PHY Error Reporting bit is set to 1, the Controller will report all Detected PHY Errors regardless of whether a TLP or DLLP was dropped. The following registers report PHY error in conjunction with this bit: - Correctable Error Status Register, i_corr_err_status, bit-0, Receiver Error Status - Local Error and Status Register, i_local_error_status_register, bit-7, Phy Error In addition to the Errors Detected by the PHY(PCS), the Controller detects the following Physical Layer Protocol Framing Errors: - Framing Errors in the received DLLP and TLP - Ordered Set Block Received Without EDS - Data Block Received After EDS - Illegal Ordered Set Block Received After EDS - Ordered Set Block Received After Skip OS Note: These Errors are always reported independent of the setting of this bit.
    Bits:  5    LTD(ro) - Link Training Direction: The state of this bit indicates whether the Controller completed link training as an upstream port(EndPoint)(=0) or a downstream port(Root Port)(=1). Default value depends on CORE_TYPE strap pin.
    Bits:  4:3  NS(ro) - Negotiated Speed: Current operating speed of link (00 = 2.5G, 01 = 5G, 10 = 8G, 11 = 16G).
    Bits:  2:1  NLC(ro) - Negotiated Lane Count: Lane count negotiated with other side during link training (00 = x1, 01 = x2, 10 = x4, 11 = x8).
    Bits:  0    LS(ro) - Link Status: Current state of link (1 = link training complete, 0 = link training not complete).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PL_CONFIG_0_REG 0x00000000
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_MLE BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_R0 BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_LTSSM(_x) (((_x) & 0x3f) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_LTSSM_of(_x) (((_x) >> 24) & 0x3f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_RLID(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_RLID_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_RFC(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_RFC_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_TSS BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_APER BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_LTD BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_NS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_NS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_NLC(_x) (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_NLC_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_0_REG_LS BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pl_config_1_reg -
    Bits: 31:24 TFC3(rw) - Transmitted FTS Count at 8 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits: 23:16 TFC2(rw) - Transmitted FTS Count at 5 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits: 15:8  TFC1(rw) - Transmitted FTS Count at 2.5 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits:  7:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PL_CONFIG_1_REG 0x00000004
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC3(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC3_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC2(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC2_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_TFC1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_R0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PL_CONFIG_1_REG_R0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_dll_tmr_config_reg -
    Bits: 31:25 R25(ro) - Reserved: Reserved
    Bits: 24:16 RSART(rw) - Receive-Side ACK-NAK Replay Timeout Adjustment: Additional receive side ACK-NAK timer timeout interval. This 9-bit value is added as a signed 2's complement number to the internal ACK-NAK timer timeout value computed by the Controller based on the PCI Express Specifications. This enables the user to make minor adjustments to the spec-defined replay timer settings.Its value is in multiples of (2 Symbol Times) At Gen1 adjustment range = (+2040 ns to -2048 ns). At Gen2 adjustment range = (+1020 ns to -1024 ns). At Gen3 adjustment range = (+510 ns to -512 ns).
    Bits: 15:9  R9(ro) - Reserved: Reserved
    Bits:  8:0  TSRT(rw) - Transmit-Side Replay Timeout Adjustment: Additional transmit-side replay timer timeout interval. This 9-bit value is added as a signed 2's complement number to the internal replay timer timeout value computed by the Controller based on the PCI Express Specifications. This enables the user to make minor adjustments to the spec-defined replay timer settings. Its value is in multiples of (2 Symbol Times) At Gen1 adjustment range = (+2040 ns to -2048 ns). At Gen2 adjustment range = (+1020 ns to -1024 ns). At Gen3 adjustment range = (+510 ns to -512 ns).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DLL_TMR_CONFIG_REG 0x00000008
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_R25(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_R25_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_RSART(_x) (((_x) & 0x1ff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_RSART_of(_x) (((_x) >> 16) & 0x1ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_R9(_x) (((_x) & 0x7f) << 9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_R9_of(_x) (((_x) >> 9) & 0x7f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_TSRT(_x) (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DLL_TMR_CONFIG_REG_TSRT_of(_x) (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg -
    Bits: 31:20 NPPC(rw) - Non-Posted Payload Credit VC0: Non-Posted payload credit limit advertised by the Controller for VC 0 . (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 19:12 PHC(rw) - Posted Header Credit VC0: Posted header credit limit advertised by the Controller for VC 0. (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 11:0  PPC(rw) - Posted Payload Credit VC0: Posted payload credit limit advertised by the Controller for VC 0. (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_RCV_CRED_LIM_0_REG 0x0000000c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_NPPC(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_NPPC_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_PHC(_x) (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_PHC_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_PPC(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_0_REG_PPC_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg -
    Bits: 31:24 CHC(rw) - Completion Header Credit VC0: Completion header credit limit advertised by the Controller for VC 0 (in number of packets). (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 23:20 R2(ro) - Reserved: Reserved
    Bits: 19:8  CPC(rw) - Completion Payload Credit VC0: Completion payload credit limit advertised by the Controller for VC 0 . (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits:  7:0  NPHCL(rw) - Non-Posted Header Credit Limit VC0: Non-Posted header credit limit advertised by the Controller for VC 0 (in number of packets). (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_RCV_CRED_LIM_1_REG 0x00000010
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_CHC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_CHC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_R2(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_R2_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_CPC(_x) (((_x) & 0xfff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_CPC_of(_x) (((_x) >> 8) & 0xfff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_NPHCL(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RCV_CRED_LIM_1_REG_NPHCL_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_lim_0_reg -
    Bits: 31:20 NPPC(ro) - Non-Posted Payload Credit VC0: Non-Posted payload credit limit received by the Controller for Link 0 . (in units of 4 Dwords)
    Bits: 19:12 PHC(ro) - Posted Header Credit VC0: Posted header credit limit received by the Controller for this link . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
    Bits: 11:0  PPC(ro) - Posted Payload Credit VC0: Posted payload credit limit received by the Controller for this link . (in units of 4 Dwords)
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSM_CRED_LIM_0_REG 0x00000014
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_NPPC(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_NPPC_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_PHC(_x) (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_PHC_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_PPC(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_0_REG_PPC_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_lim_1_reg -
    Bits: 31:24 CHC(ro) - Completion Header Credit VC0: Completion header credit limit received by the Controller for VC 0 . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
    Bits: 23:20 R3(ro) - Reserved: Reserved
    Bits: 19:8  CPC(ro) - Completion Payload Credit VC0: Completion payload credit limit received by the Controller for VC 0 . (in units of 4 Dwords)
    Bits:  7:0  NPHC(ro) - Non-Posted Header Credit VC0: Non-Posted header credit limit received by the Controller for VC 0 . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSM_CRED_LIM_1_REG 0x00000018
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_CHC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_CHC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_R3(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_R3_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_CPC(_x) (((_x) & 0xfff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_CPC_of(_x) (((_x) >> 8) & 0xfff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_NPHC(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_LIM_1_REG_NPHC_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg -
    Bits: 31:16 MNUI(rw) - Minimum Non-Posted Update Interval: Minimum credit update interval for non-posted transactions. The Controller follows this minimum interval between issuing posted credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This field is re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
    Bits: 15:0  MPUI(rw) - Minimum Posted Update Interval: Minimum credit update interval for posted transactions. The Controller follows this minimum interval between issuing posted credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This field is re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSM_CRED_UPDATE_INT_CONFIG_0_REG 0x0000001c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_0_REG_MNUI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_0_REG_MNUI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_0_REG_MPUI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_0_REG_MPUI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg -
    Bits: 31:16 MUI(rw) - Maximum Update Interval: Maximum credit update interval for all transactions. If no new credit has become available since the last update, the Controller will repeat the last update after this interval. This is to recover from any losses of credit update packets. The value is in units of 16 ns. This field could be re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
    Bits: 15:0  CUI(rw) - Minimum Completion Update Interval: Minimum credit update interval for Completion packets. The Controller follows this minimum interval between issuing completion credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This parameter is not used when the Completion credit is infinity.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSM_CRED_UPDATE_INT_CONFIG_1_REG 0x00000020
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_1_REG_MUI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_1_REG_MUI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_1_REG_CUI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSM_CRED_UPDATE_INT_CONFIG_1_REG_CUI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_L0S_timeout_limit_reg -
    Bits: 31:16 R4(ro) - Reserved: Reserved
    Bits: 15:0  LT(rw) - L0S Timeout: Contains the timeout value (in units of 16 ns) for transitioning to the L0S power state. Setting this parameter to 0 permanently disables the transition to the L0S power state.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_L0S_TIMEOUT_LIMIT_REG 0x00000024
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L0S_TIMEOUT_LIMIT_REG_R4(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L0S_TIMEOUT_LIMIT_REG_R4_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L0S_TIMEOUT_LIMIT_REG_LT(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L0S_TIMEOUT_LIMIT_REG_LT_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transmit_tlp_count_reg -
    Bits: 31:0  TTC(w1c) - Transmit TLP Count: Count of TLPs transmitted
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSMIT_TLP_COUNT_REG 0x00000028
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSMIT_TLP_COUNT_REG_TTC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSMIT_TLP_COUNT_REG_TTC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transmit_tlp_payload_dword_count_reg -
    Bits: 31:0  TTPBC(w1c) - Transmit TLP Payload Byte Count: Count of TLPs payload Dwords transmitted
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_TRANSMIT_TLP_PAYLOAD_DWORD_COUNT_REG 0x0000002c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSMIT_TLP_PAYLOAD_DWORD_COUNT_REG_TTPBC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_TRANSMIT_TLP_PAYLOAD_DWORD_COUNT_REG_TTPBC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_tlp_count_reg -
    Bits: 31:0  RTC(w1c) - Receive TLP Count: Count of TLPs received
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_RECEIVE_TLP_COUNT_REG 0x00000030
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_TLP_COUNT_REG_RTC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_TLP_COUNT_REG_RTC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_tlp_payload_dword_count_reg -
    Bits: 31:0  RTPDC(w1c) - Receive TLP Payload Byte Count: Count of TLP payload Dwords received
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_RECEIVE_TLP_PAYLOAD_DWORD_COUNT_REG 0x00000034
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_TLP_PAYLOAD_DWORD_COUNT_REG_RTPDC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_TLP_PAYLOAD_DWORD_COUNT_REG_RTPDC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg -
    Bits: 31:24 R5(ro) - Reserved: Reserved
    Bits: 15:0  CTL(rw) - Completion Timeout Limit: Timeout limit for completion timers. This value is in multiples of 4096 ns. Default value is 50ms. Please note that there could be a variation of 0 to +8us on the programmed Completion Timeout.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_COMPLN_TMOUT_LIM_0_REG 0x00000038
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_0_REG_R5(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_0_REG_R5_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_0_REG_CTL(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_0_REG_CTL_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg -
    Bits: 31:28 R6(ro) - Reserved: Reserved
    Bits: 15:0  CTL(rw) - Completion Timeout Limit: Timeout limit for completion timers.This value is in multiples of 4096 ns. Default value is 200ms. Please note that there could be a variation of 0 to +8us on the programmed Completion Timeout.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_COMPLN_TMOUT_LIM_1_REG 0x0000003c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_1_REG_R6(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_1_REG_R6_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_1_REG_CTL(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_COMPLN_TMOUT_LIM_1_REG_CTL_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_L1_st_reentry_delay_reg -
    Bits: 31:0  L1RD(rw) - L1 Re-Entry Delay: Delay to re-enter L1 after no activity (in units of 16 ns).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_L1_ST_REENTRY_DELAY_REG 0x00000040
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L1_ST_REENTRY_DELAY_REG_L1RD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_L1_ST_REENTRY_DELAY_REG_L1RD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg -
    Bits: 31    DISLNRXCHK(rw) - Disable Check for Link RX IDLE: This bit is used to configure the ASPM L1 Entry mechanism: 1: Link is checked for IDLE only on the TX to determine ASPM L1 Entry. ASPM L1 entry is initiated if no TLP is transmitted for the L1 timeout period. 0: Link is checked for IDLE both on the TX and RX to determine ASPM L1 Entry. ASPM L1 entry is initiated if no TLP is transmitted/received for the L1 timeout period.
    Bits: 30:20 R7(ro) - Reserved: Reserved
    Bits: 19:0  L1T(rw) - L1 Timeout: Contains the timeout value(in units of 16 ns) for transitioning to the L1 power state. Setting it to 0 permanently disables the transition to the L1 power state.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG 0x00000048
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG_DISLNRXCHK BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG_R7(_x) (((_x) & 0x7ff) << 20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG_R7_of(_x) (((_x) >> 20) & 0x7ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG_L1T(_x) (((_x) & 0xfffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ASPM_L1_ENTRY_TMOUT_DELAY_REG_L1T_of(_x) (((_x) >> 0) & 0xfffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg -
    Bits: 31:16 R7(ro) - Reserved: Reserved
    Bits: 15:0  PTOAD(rw) - PME Turnoff Ack Delay: Time in microseconds between the Controller receiving a PME_TurnOff message TLP and the Controller sending a PME_TO_Ack response to it. This field must be set to a non-zero value in order for the Controller to send a response. Setting this field to 0 suppresses the Controller's response to PME_TurnOff message, so that the client may transmit the PME_TO_Ack message through the master interface.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PME_TURNOFF_ACK_DELAY_REG 0x0000004c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_TURNOFF_ACK_DELAY_REG_R7(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_TURNOFF_ACK_DELAY_REG_R7_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_TURNOFF_ACK_DELAY_REG_PTOAD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_TURNOFF_ACK_DELAY_REG_PTOAD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_linkwidth_control_reg -
    Bits: 31    EPLSCRL(rw) - EP Link Speed Change Retrain Link: Writing a 1 into this field results in the Controller re-training the link to change its speed. When setting this bit to 1, the software must also set the EP Target Link Speed field to indicate the speed that the EP desires to change on the link. The EP Controller will attempt to change the link to this speed. This bit is cleared by the internal logic of the Controller after the re-training has been completed and link has reached the L0 state. Software must wait for the bit to be clear before setting it again to change the link speed.
    Bits: 30:26 R2(ro) - Reserved: Reserved
    Bits: 25:24 EPTLS(rw) - EP Target Link Speed: This field contains the Link Speed that the EP intends to change to during the re-training. Client needs to ensure that this field is programmed to a speed which is lesser than or equal to the Target Link Speed field of PF0 Configuration Link Control 2 Register. Client also needs to ensure that this does not exceed PCIE_GENERATION_SEL strap input. Defined encodings of this field are: 00 - GEN1 01 - GEN2 10 - GEN3 11 - Reserved
    Bits: 23:17 R1(ro) - Reserved: Reserved
    Bits: 16    RL(rw) - Link Upconfigure Retrain Link: Writing a 1 into this field results in the Controller re-training the link to change its width. When setting this bit to 1, the software must also set the target lane-map field to indicate the lanes it desires to be part of the link. The Controller will attempt to form a link with this set of lanes. The link formed at the end of the retraining may include all of these lanes (if both nodes agree on them during re-training), or the largest subset that both sides were able to activate. This bit is cleared by the internal logic of the Controller after the re-training has been completed and link has reached the L0 state. Software must wait for the bit to be clear before setting it again to change the link width.
    Bits: 15:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  TLM(rw) - Target Lane Map: This field contains the bitmap of the lanes to be included in forming the link during the re-training. 00000001 - Retrain to a x1 link 00000011 - Retrain to a x2 link 00001111 - Retrain to a x4 link 11111111 - Retrain to a x8 link If the target lane map includes lanes that were inactive when retraining is initiated, then both the Controller and its link partner must support the LinkWidth Upconfigure Capability to be able to activate those lanes. In RC Mode, the user can check if the remote node has this capability by reading the Remote Link Upconfigure Capability Status bit in Physical Layer Configuration Register 0 after the link first came up.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LINKWIDTH_CONTROL_REG 0x00000050
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_EPLSCRL BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R2(_x) (((_x) & 0x1f) << 26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R2_of(_x) (((_x) >> 26) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_EPTLS(_x) (((_x) & 0x3) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_EPTLS_of(_x) (((_x) >> 24) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R1(_x) (((_x) & 0x7f) << 17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R1_of(_x) (((_x) >> 17) & 0x7f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_RL BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R0(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_R0_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_TLM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LINKWIDTH_CONTROL_REG_TLM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_sris_control_reg -
    Bits: 31:1  R31(ro) - Reserved: Reserved
    Bits:  0    SRISE(rw) - SRIS Enable: Setting this bit enables SRIS mode in the PHY layer. This bit should be changed before link training begins by holding the LINK_TRAINING_ENABLE input to 1'b0. When SRIS is disabled using this bit the Lower SKP OS Generation Supported Speeds Vector and Lower SKP OS Reception Supported Speeds Vector in the Link Capabilities Register 2 will be forced to ZERO. The default value of this register can be controlled using the SRIS_ENABLE strap input.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SRIS_CONTROL_REG 0x00000074
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SRIS_CONTROL_REG_R31(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SRIS_CONTROL_REG_R31_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SRIS_CONTROL_REG_SRISE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_0_reg -
    Bits: 31:0  SHDW_HDR_LOG_0(rw) - Shadow header log 0: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [31:0] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_HDR_LOG_0_REG 0x00000100
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_0_REG_SHDW_HDR_LOG_0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_0_REG_SHDW_HDR_LOG_0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_1_reg -
    Bits: 31:0  SHDW_HDR_LOG_1(rw) - Shadow header log 1: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [63:32] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_HDR_LOG_1_REG 0x00000104
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_1_REG_SHDW_HDR_LOG_1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_1_REG_SHDW_HDR_LOG_1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_2_reg -
    Bits: 31:0  SHDW_HDR_LOG_2(rw) - Shadow header log 2: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [95:64] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_HDR_LOG_2_REG 0x00000108
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_2_REG_SHDW_HDR_LOG_2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_2_REG_SHDW_HDR_LOG_2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_3_reg -
    Bits: 31:0  SHDW_HDR_LOG_3(rw) - Shadow header log 3: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [127:96] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_HDR_LOG_3_REG 0x0000010c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_3_REG_SHDW_HDR_LOG_3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_HDR_LOG_3_REG_SHDW_HDR_LOG_3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_func_num_reg -
    Bits: 31:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  SHDW_FUNC_NUM(rw) - Shadow register target function number: The value here will be the target function number when f/w sets any bit in the shadow error register.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_FUNC_NUM_REG 0x00000110
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_FUNC_NUM_REG_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_FUNC_NUM_REG_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_FUNC_NUM_REG_SHDW_FUNC_NUM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_FUNC_NUM_REG_SHDW_FUNC_NUM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_ur_err_reg -
    Bits: 31:2  R0(ro) - Reserved: Reserved
    Bits:  1    NP_UR_ERR(wo) - Non Posted Error: If this bit is set, the corresponding non-posted UR error bits will be set in the AER and device status registers of the target function.
    Bits:  0    P_UR_ERR(wo) - Posted UR Error: If this bit is set, the corresponding posted UR error bits will be set in the AER and device status registers of the target function.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_SHDW_UR_ERR_REG 0x00000114
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_UR_ERR_REG_R0(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_UR_ERR_REG_R0_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_UR_ERR_REG_NP_UR_ERR BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_SHDW_UR_ERR_REG_P_UR_ERR BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pm_clk_frequency_reg -
    Bits: 31:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  PMCLKFRQ(rw) - PM_CLK Frequency Select: This field specifies the PM_CLK Frequency selected. The encoding is described below: 000000: Reserved 000001: Reserved 000010: PM_CLK is 2 MHz 000011: PM_CLK is 3 MHz 000100: PM_CLK is 4 MHz 000101: PM_CLK is 5 MHz .. 111010: PM_CLK is 58 MHz 111011: PM_CLK is 59 MHz 111100: PM_CLK is 60 MHz 111101 : Reserved 111110 : Reserved 111111 : Reserved .
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PM_CLK_FREQUENCY_REG 0x00000140
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PM_CLK_FREQUENCY_REG_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PM_CLK_FREQUENCY_REG_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PM_CLK_FREQUENCY_REG_PMCLKFRQ(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PM_CLK_FREQUENCY_REG_PMCLKFRQ_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen1_reg -
    Bits: 31:0  DLLPCNT1(ro) - GEN1 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN1 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DEBUG_DLLP_COUNT_GEN1_REG 0x00000144
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN1_REG_DLLPCNT1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN1_REG_DLLPCNT1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen2_reg -
    Bits: 31:0  DLLPCNT2(ro) - GEN2 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN2 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DEBUG_DLLP_COUNT_GEN2_REG 0x00000148
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN2_REG_DLLPCNT2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN2_REG_DLLPCNT2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen3_reg -
    Bits: 31:0  DLLPCNT3(ro) - GEN3 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN3 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DEBUG_DLLP_COUNT_GEN3_REG 0x0000014c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN3_REG_DLLPCNT3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_DLLP_COUNT_GEN3_REG_DLLPCNT3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_vendor_defined_message_tag_reg -
    Bits:  7:0  VDMTAG(rw) - Vendor Defined Message Tag: The Controller will use the tag programed in this register for all Outbound Vendor Defined Messages.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_VENDOR_DEFINED_MESSAGE_TAG_REG 0x00000158
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_VENDOR_DEFINED_MESSAGE_TAG_REG_VDMTAG(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_VENDOR_DEFINED_MESSAGE_TAG_REG_VDMTAG_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_negotiated_lane_map_reg -
    Bits: 31:17 R71(ro) - Reserved: Reserved
    Bits: 16    LRS(ro) - Lane Reversal Status: This bit set by the Controller at the end of link training if the LTSSM had to reverse the lane numbers to form the link.
    Bits: 15:8  R70(ro) - Reserved: Reserved
    Bits:  7:0  NLM(ro) - Negotiated Lane Map: Bit i of this field is set to 1 at the end of link training if Lane i is part of the PCIe link. The value of this field is valid only when the link is in L0 or L0s states.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_NEGOTIATED_LANE_MAP_REG 0x00000200
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_R71(_x) (((_x) & 0x7fff) << 17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_R71_of(_x) (((_x) >> 17) & 0x7fff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_LRS BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_R70(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_R70_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_NLM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_NEGOTIATED_LANE_MAP_REG_NLM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_fts_count_reg -
    Bits: 31:24 R24(ro) - Reserved: Reserved
    Bits: 23:16 R16(ro) - Reserved: Reserved
    Bits: 15:8  RFC8S(ro) - Received FTS Count for 8GT/s Speed: FTS count received from the other side during link training for use at the 8 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 8 GT/s speed.
    Bits:  7:0  RFC5S(ro) - Received FTS Count for 5GT/s Speed: FTS count received from the other side during link training for use at the 5 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 5 GT/s speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_RECEIVE_FTS_COUNT_REG 0x00000204
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_R24(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_R24_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_R16(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_R16_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_RFC8S(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_RFC8S_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_RFC5S(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_RECEIVE_FTS_COUNT_REG_RFC5S_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_mux_control_reg -
    Bits: 31    EFSRTCA(rw) - Enable Function-Specific Reporting of Type-1 Configuration Accesses: Setting this bit to 0 causes all the enabled Functions to report an error when a Type-1 configuration access is received by the Controller, targeted at any Function. Setting it to 1 limits the error reporting to the type-0 Function whose number matches with the Function number specified in the request. If the Function number in the request refers to an unimplemented or disabled Function, all enabled Functions report the error regardless of the setting of this bit.
    Bits: 30    DOC(rw) - Disable Ordering Checks: Setting this bit to 1 disables the ordering check in the Controller between Completions and Posted requests received from the link.
    Bits: 29    DFCUT(rw) - Disable Flow Control Update Timeout: When this bit is 0, the Controller will time out and re-train the link when no Flow Control Update DLLPs are received from the link within an interval of 128 us. Setting this bit to 1 disables this timeout. When the advertised receive credit of the link partner is infinity for the header and payload of all credit types, this timeout is always suppressed. The setting of this bit has no effect in this case. This bit should not be set during normal operation, but is useful for testing.
    Bits: 28    DEI(rw) - Disable Electrical Idle Infer in L0 State: Setting this bit to 1 disables the inferring of electrical idle in the L0 state. Electrical idle is inferred when no flow control updates and no SKP sequences are received within an interval of 128 us. This bit should not be set during normal operation, but is useful for testing.
    Bits: 27    DGLUS(rw) - Disable Gen3 LFSR Update from SKP: Setting this bit to 1 disables the update of the LFSRs in the Gen3 descramblers of the Controller, from the values received in SKP sequences. This bit should not be set during normal operation, but is useful for testing.
    Bits: 26    R26(ro) - Reserved: Reserved
    Bits: 25    ESPC(rw) - Enable Slot Power Capture: When this bit is set to 1, the Controller will capture the Slot Power Limit Value and Slot Power Limit Scale parameters from a Set_Slot_Power_Limit message received in the Device Capabilities Register. When this bit is 0, the capture is disabled. This bit is valid only when the Controller is configured as an EndPoint. It has no effect when the Controller is a Root Complex.
    Bits: 24    EFLT(rw) - Enable Fast Link Training: This bit is provided to shorten the link training time to facilitate fast simulation of the design, especially at the gate level. Enabling this bit has the following effects: 1. The 1 ms, 2 ms, 12 ms, 24 ms, 32 ms and 48 ms timeout intervals in the LTSSM are shortened by a factor of 500. 2. In the Polling.Active state of the LTSSM, only 16 training sequences are required to be transmitted (Instead of 1024) to make the transition to the Configuration state. This bit should not be set during normal operation of the Controller.
    Bits: 23    DLUC(rw) - Disable Link Upconfigure Capability: The user may set this bit to turn off the link upconfigure capability of the Controller. Setting this bit prevents the Controller from advertising the link upconfigure capability in training sequences transmitted in the Configuration.Complete state. In addition, setting this bit causes the Controller to put the unused lanes into Turn Off mode. When disable_link_upconfigure_capability==1: Controller drives PIPE_TX_ELEC_IDLE==1 AND PIPE_TX_COMPLIANCE==1 for the Unused upper lanes. The Unused upper lanes are put into Turn Off mode by the PHY as per PIPE specification. When disable_link_upconfigure_capability==0: Controller drives PIPE_TX_ELEC_IDLE==1 AND PIPE_TX_COMPLIANCE==0 for the Unused upper lanes. The Unused upper lanes are put into Electrical Idle by the PHY.
    Bits: 22    DLRFE(rw) - Disable Link Re-Training on Framing Error: When this bit is 1, the Controller will not transition its LTSSM into the Recovery state when it detects a Framing Error at 8 GT/s speed (as defined in Section 4.2.2.3.3 of the PCIe Base Specification 3.0. This bit must normally be set to 0 so that a Framing Error will cause the LTSSM to enter Recovery. The setting of this bit has no effect on the operation of the Controller at 2.5 and 5 GT/s speeds.
    Bits: 21    DSHEC(rw) - Disable Sync Header Error Check: When this bit is 0, the Controller will signal a framing error if it detects a sync header error in the received blocks at 8 GT/s speed (A 00 or 11 binary setting of the sync header on the received blocks in any lane constitutes a framing error). Setting this bit to 1 suppresses this error check. This bit should normally be set to 0, as the sync header check is mandatory in the PCIe 3.0 Specifications.
    Bits: 20    DCIVMC(rw) - Disable checking of invalid message codes: When this bit is 1, the Controller will not check for invalid message codes. This bit should normally set to 0, as the invalid message code checking is mandatory in the PCIe 3.0 specifications.
    Bits: 19    DIOAEFC(rw) - Disable Illegal OS After EDS Framing Check: When this bit is 1, the Controller will not check for illegal OS after EDS as part of Gen3 Framing Error Checks. This bit should normally set to 0, as this is a mandatory Gen3 Framing Error check in the PCIe 3.0 specifications.
    Bits: 18    DOASFC(rw) - Disable OS After Skip Framing Check: When this bit is 1, the Controller will not check for OS after SKIP OS as part of Gen3 Framing Error Checks. This bit should normally set to 0, as this is a mandatory Gen3 Framing Error check in the PCIe 3.0 specifications.
    Bits: 17    R8B(ro) - Reserved:
    Bits: 16    R8A(ro) - Reserved:
    Bits: 15    FDS(rw) - Force Disable Scrambling: Disable Scrambling/Descrambling in Gen1/Gen2.
    Bits: 14    R14(ro) - Reserved:
    Bits: 13    R1313(ro) - Reserved:
    Bits: 12    R1212(ro) - Reserved:
    Bits: 11    R1111(rw) - Disable Client TX MUX arbitartion: When this bit is 1, Disable Client TX MUX Completion and PNP request arbitartion,roundrobin priority logic added to prevent PNP requests from starving when completions are present
    Bits: 10    DRXNPSP(rw) - Disable RX NP Starvation Prevention: As per PCIe specification, Non Posted packets should not pass ahead of a Posted packet. Posted and Non Posted packets are stored in a common Receive PNP FIFO. Controller ensures that the P and NP are delivered to the HAL/AXI target interface without violating the Ordering rules. When a mix of P and NP requests are received over the link, the NP packets can be starved if multiple Posted packets are stored in the PNP RX FIFO. Controller implements a mechanism to prevent NP Starvation Prevention which can be programmed through this bit: 0: Send P and NP in the received order, instead of giving priority only for P and starve NP when continous P, NP packets are received. 1: Priority only for P. Starve NP when continous P, NP packets are received. NP packets sent to HAL/AXI target interface only when all P packets in the PNP FIFO are delivered.
    Bits:  9    MSIVCMS(rw) - MSI Vector Count Mode Select: Sets the mode of generating MSI_VECTOR_COUNT output for all functions. 0 - MSI_VECTOR_COUNT always outputs the configured value of MSI Multiple Message Enable[2:0] register. 1 - MSI_VECTOR_COUNT outputs the lesser of the MSI Multiple Message Enable[2:0] and MSI Multiple Message Capable[2:0] This mode can be used to handle any programming error form the Host software.
    Bits:  8    DIDBOC(rw) - Disable ID Based Ordering Checks: Setting this bit to 1 disables the ID Based Ordering check in the Controller between Completions and Posted requests received from the link.
    Bits:  7    R77(rw) - Reserved: This bit should be set to 0 for backward compatibility.
    Bits:  6:5  R6(ro) - Reserved:
    Bits:  4:0  MS(rw) - Mux Select: Bits 4:3 select the module and bits 2:0 select the group of signals within the module that are driven on the debug bus. The assignments of signals on the debug outputs of the Controller are given in Appendix B.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DEBUG_MUX_CONTROL_REG 0x00000208
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_EFSRTCA BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DOC BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DFCUT BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DEI BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DGLUS BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R26 BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_ESPC BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_EFLT BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DLUC BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DLRFE BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DSHEC BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DCIVMC BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DIOAEFC BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DOASFC BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R8B BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R8A BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_FDS BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R14 BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R1313 BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R1212 BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R1111 BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DRXNPSP BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_MSIVCMS BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_DIDBOC BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R77 BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R6(_x) (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_R6_of(_x) (((_x) >> 5) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_MS(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_REG_MS_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_error_status_register -
    Bits: 31:28 R31_28(ro) - Reserved: Reserved
    Bits: 27:26 R27(ro) - Reserved: Reserved
    Bits: 25    MSIXMSKST(w1c) - MSIX Function Mask Change: This interrupt status bit is used when MSIX Function Mask Enhanced Interrupt Enable bit is set to 0 by the User. This status bit indicates that the MSIX Function Mask bit of any function, PF or VF, was programmed or configured by Local Firmware Or Host SW.
    Bits: 24:22 R24(ro) - Reserved: Reserved
    Bits: 21    HAWCD(w1c) - Hardware Autonomous Width Change Disable Toggle: This interrupt status bit indicates that the Host toggled the Hardware Autonomous Width Change bit in the Link Control Register through a Config Write. Upon this interrupt, the Client firmware must read the Link Control Register to check the value set by Host in the Hardware Autonomous Width Change bit. The Host Software may disable autonomous width change by setting Hardware Autonomous Width Disable bit in the Link Control register. If disabled by the Host and if the Endpoint firmware had initiated an autonomous width downsizing prior to this interrupt, then the local Client firmware is responsible to upconfigure the Link to go to its full functional width by initiating the link_upconfigure_retrain_link within 1 ms of this interrupt.
    Bits: 20    MSIENGRCAP(w1c) - MSI Multiple Message Enable Greater Than Capability: The configured value of MSI Multiple Message Enable[2:0] for a function was greater than the functions MSI Multiple Message Capable[2:0]
    Bits: 19    MMVC(w1c) - MSI Mask Value Change: This status bit is set whenever the MSI mask register value in the MSI capability register changes value in ANY of the functions in the controller
    Bits: 18    UTC(w1c) - Unmapped TC: Unmapped TC error. This bit is tied to 0 since this configuration of the Controller does not implement the Virtual Channel Capability Registers.
    Bits: 17    R17(ro) - Reserved: Reserved
    Bits: 16:13 R13(ro) - Reserved: Reserved
    Bits: 12    TSRPE(w1c) - TPH ST RAM Parity Error: Uncorrectable parity error detected while reading from the TPH Steering Tag RAM
    Bits: 11    CT(w1c) - Completion Timeout: A request timed out waiting for completion.
    Bits: 10    FCE(w1c) - Flow Control Error: An error was observed in the flow control advertisements from the other side.
    Bits:  9    UCR(w1c) - Unexpected Completion Received: Unexpected Completion received from the link.
    Bits:  8    MTR(w1c) - Malformed TLP Received: Malformed TLP received from the link.
    Bits:  7    PE(w1c) - Phy Error: Phy error detected on receive side. This bit is set when an error is detected in the receive side of the Physical Layer of the Controller (e.g. a bit error or coding violation). This bit is set upon any of the following errors: (1) PHY reported 8B10B error, Disparity Error, Elastic Buffer Overflow Error, Underflow Error (2) GEN3 TLP, DLLP Framing Errors (3) OS Block Received Without EDS (4) Data Block Received After EDS (5) Illegal OS Block After EDS (6) OS Block Received After SKIP OS (7) OS Block Received After SDS (8) Sync Header Error (9) Loss of Gen3 Block Alignment This error is not Function-specific..
    Bits:  6    RTR(w1c) - Replay Timer Rollover: Replay timer rolled over after 4 transmissions of the same TLP.
    Bits:  5    RT(w1c) - Replay Timeout: Replay timer timed out
    Bits:  4    CRFO(w1c) - Completion RX FIFO Overflow: Overflow occurred in the Completion Receive FIFO.
    Bits:  3    PRFO(w1c) - PNP RX FIFO Overflow: Overflow occurred in the PNP Receive FIFO.
    Bits:  2    RRPE(w1c) - Replay RAM Parity Error: Parity error detected while reading from Replay Buffer RAM.
    Bits:  1    CRFPE(w1c) - Completion RX FIFO Parity Error: Parity error detected while reading from the Completion Receive FIFO RAM.
    Bits:  0    PRFPE(w1c) - PNP RX FIFO Parity Error: Parity error detected while reading from the PNP Receive FIFO RAM.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LOCAL_ERROR_STATUS_REGISTER 0x0000020c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R31_28(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R31_28_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R27(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R27_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_MSIXMSKST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R24(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R24_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_HAWCD BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_MSIENGRCAP BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_MMVC BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_UTC BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R17 BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R13(_x) (((_x) & 0xf) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_R13_of(_x) (((_x) >> 13) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_TSRPE BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_CT BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_FCE BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_UCR BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_MTR BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_PE BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_RTR BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_RT BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_CRFO BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_PRFO BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_RRPE BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_CRFPE BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_REGISTER_PRFPE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_intrpt_mask_reg -
    Bits: 31:28 R31_28(ro) - Reserved: Reserved
    Bits: 27:26 R27(ro) - Reserved: Reserved
    Bits: 25    MSIXMSK(rw) - MSIX Function Mask Change: This bit is used to mask interrupt that indicates that the MSIX Function Mask bit of any function, PF or VF, was programmed or configured by Local Firmware Or Host SW.
    Bits: 24:22 R24(ro) - Reserved: Reserved
    Bits: 21    HAWCD(rw) - Hardware Autonomous Width Change Disable Toggle: This bit is used to mask interrupt that indicates that the Host toggled the Hardware Autonomous Width Change in the Endpoint Link Control Register through a Config Write.
    Bits: 20    MSIENGRCAP(rw) - MSI Multiple Message Enable Greater Than Capability: The configured value of MSI Multiple Message Enable[2:0] for a function was greater than the functions MSI Multiple Message Capable[2:0]
    Bits: 19    MMVC(rw) - MSI Mask Value Change: MSI mask register value in the MSI capability register changes value in ANY of the functions in the controller
    Bits: 18    UTC(rw) - Unmapped TC: Unmapped TC error
    Bits: 17    R17(ro) - Reserved: Reserved
    Bits: 16:13 R13(ro) - Reserved: Reserved
    Bits: 12    TSRPE(rw) - TPH ST RAM Parity Error: Uncorrectable parity error detected while reading from the TPH Steering Tag RAM
    Bits: 11    CT(rw) - Completion Timeout: A request timed out waiting for completion.
    Bits: 10    FCE(rw) - Flow Control Error: An error was observed in the flow control advertisements from the other side.
    Bits:  9    UCR(rw) - Unexpected Completion Received: Unexpected Completion received from the link.
    Bits:  8    MTR(rw) - Malformed TLP Received: Malformed TLP received from the link.
    Bits:  7    PE(rw) - Phy Error: Phy error detected on receive side.
    Bits:  6    RTR(rw) - Replay Timer Rollover: Replay timer rolled over after 4 transmissions of the same TLP.
    Bits:  5    RT(rw) - Replay Timeout: Replay timer timed out
    Bits:  4    CRFO(rw) - Completion RX FIFO Overflow: Overflow occurred in the Completion Receive FIFO.
    Bits:  3    PRFO(rw) - PNP RX FIFO Overflow: Overflow occurred in the PNP Receive FIFO.
    Bits:  2    RRPE(rw) - Replay RAM Parity Error: Parity error detected while reading from Replay Buffer RAM.
    Bits:  1    CRFPE(rw) - Completion RX FIFO Parity Error: Parity error detected while reading from the Completion Receive FIFO RAM.
    Bits:  0    PRFPE(rw) - PNP RX FIFO Parity Error: Parity error detected while reading from the PNP Receive FIFO RAM.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LOCAL_INTRPT_MASK_REG 0x00000210
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R31_28(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R31_28_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R27(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R27_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_MSIXMSK BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R24(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R24_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_HAWCD BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_MSIENGRCAP BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_MMVC BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_UTC BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R17 BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R13(_x) (((_x) & 0xf) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_R13_of(_x) (((_x) >> 13) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_TSRPE BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_CT BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_FCE BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_UCR BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_MTR BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_PE BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_RTR BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_RT BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_CRFO BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_PRFO BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_RRPE BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_CRFPE BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_REG_PRFPE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_lcrc_err_count_reg -
    Bits: 31:16 R11(ro) - Reserved: Reserved
    Bits: 15:0  LEC(w1c) - LCRC Eror Count: Number of TLPs received with LCRC errors.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LCRC_ERR_COUNT_REG 0x00000214
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LCRC_ERR_COUNT_REG_R11(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LCRC_ERR_COUNT_REG_R11_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LCRC_ERR_COUNT_REG_LEC(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LCRC_ERR_COUNT_REG_LEC_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ecc_corr_err_count_reg -
    Bits: 31:24 R12(w1c) - TPH ST RAM Correctable Error Count: Number of correctable errors detected while reading from the TPH Steering Tag RAM. This is an 8-bit saturating counter that can be cleared by writing all 1s into it.
    Bits: 23:16 RRCER(w1c) - Replay RAM Correctable Error Count: Number of correctable errors detected while reading from the Replay Buffer RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
    Bits: 15:8  SFRCER(w1c) - SC FIFO RAM Correctable Error Count: Number of correctable errors detected while reading from the SC FIFO RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
    Bits:  7:0  PFRCER(w1c) - PNP FIFO RAM Correctable Error Count: Number of correctable errors detected while reading from the PNP FIFO RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_ECC_CORR_ERR_COUNT_REG 0x00000218
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_R12(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_R12_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_RRCER(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_RRCER_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_SFRCER(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_SFRCER_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_PFRCER(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_ECC_CORR_ERR_COUNT_REG_PFRCER_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ltr_snoop_lat_reg -
    Bits: 31    SL(rw) - Snoop Latency: The client software must set this bit to 1 to set the Snoop Latency Requirement bit in the LTR message to be sent.
    Bits: 30:29 R13(ro) - Reserved: Reserved
    Bits: 28:26 SLS(rw) - Snoop Latency Scale: The client software must program this field with the value to be sent in the Snoop Latency Scale field of the LTR message.
    Bits: 25:16 SLV(rw) - Snoop Latency Value: The client software must program this field with the value to be sent in the Snoop Latency Value field of the LTR message.
    Bits: 15    NSLR(rw) - No-Snoop Latency Requirement: The client software must set this bit to 1 to set the No-Snoop Latency Requirement bit in the LTR message to be sent.
    Bits: 14:13 R12(ro) - Reserved:
    Bits: 12:10 NSLS(rw) - No-Snoop Latency Scale: The client software must program this field with the value to be sent in the No-Snoop Latency Scale field of the LTR message.
    Bits:  9:0  NSLV(rw) - No-Snoop Latency Value: The client software must program this field with the value to be sent in the No-Snoop Latency Value field of the LTR message.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LTR_SNOOP_LAT_REG 0x0000021c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_SL BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_R13(_x) (((_x) & 0x3) << 29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_R13_of(_x) (((_x) >> 29) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_SLS(_x) (((_x) & 0x7) << 26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_SLS_of(_x) (((_x) >> 26) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_SLV(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_SLV_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_NSLR BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_R12(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_R12_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_NSLS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_NSLS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_NSLV(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_SNOOP_LAT_REG_NSLV_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg -
    Bits: 12    TMFPSC(rw) - Transmit Message on Function Power State Change: When this bit is set to 1, the Controller will automatically transmit an LTR message when all the Functions in the Controller have transitioned to a non-D0 power state, provided that the following conditions are both true: 1. The Controller sent at least one LTR message since the Data Link layer last transitioned from down to up state. 2. The most recent LTR message transmitted by the Controller had as least one of the Requirement bits set. The Controller will set the Requirement bits in this LTR message to 0. When this bit 12 is 0, the Controller will not, by itself, send any LTR messages in response to Function Power State changes. Client logic may monitor the FUNCTION_POWER_STATE outputs of the Controller and transmit LTR messages through the master interface, in response to changes in their states.
    Bits: 11    TMLMET(rw) - Transmit Message on LTR Mechanism Enable Transition: When this bit is set to 1, the Controller will automatically transmit an LTR message whenever the LTR Mechanism Enable bit in the Device Control 2 Register changes from 0 to 1, with the parameters specified in the LTR Snoop/No-Snoop Latency Register. When this bit is 1, the Controller will also transmit an LTR message whenever the LTR Mechanism Enable bit is cleared, if the following conditions are both true: 1. The Controller sent at least one LTR message since the LTR Mechanism Enable bit was last set. 2. The most recent LTR message transmitted by the Controller had as least one of the Requirement bits set. The Controller will set the Requirement bits in this LTR message to 0. When this bit 11 is 0, the Controller will not, by itself, send any LTR messages in response to state changes of the LTR Mechanism Enable bit. Client logic may monitor the state of the LTR_MECHANISM_ ENABLE output of the Controller and transmit LTR messages through the master interface, in response to its state changes.
    Bits: 10    SLM(ro) - Send LTR Message: Setting this bit causes the Controller to transmit an LTR message with the parameters specified in the LTR Snoop/No-Snoop Latency Register (Section 8.4.2.9). This bit is cleared by the Controller on transmitting the LTR message, and stays set until then. Client software must read this register and verify that this bit is 0 before setting it again to send a new message. This field becomes writable when LTR mechanism is enabled in device control-2 register.
    Bits:  9:0  MLI(rw) - Minimum LTR Interval: This field specifies the minimum spacing between LTR messages transmitted by the Controller in units of microseconds. The PCI Express Specifications recommend sending no more than two LTR messages within a 500 microsecond interval. The Controller will wait for the minimum delay specified by this field after sending an LTR message, before transmitting a new LTR message. NOTE: The LINK can be in low power states(L0s and L1) when send LTR Message is trigered. So, the user has to consider the exit latencies while programming this field. It is recommended to program this field with about 2 us higher than the required interval to account for the L0s/L1 exit latencies.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LTR_MSG_GEN_CTL_REG 0x00000220
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_MSG_GEN_CTL_REG_TMFPSC BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_MSG_GEN_CTL_REG_TMLMET BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_MSG_GEN_CTL_REG_SLM BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_MSG_GEN_CTL_REG_MLI(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LTR_MSG_GEN_CTL_REG_MLI_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg -
    Bits: 31:21 R21(ro) - Reserved: Reserved
    Bits: 20    DPMOPS(rw) - Disable PME message on PM Status: When this bit is set, Controller will not automatically send a PME message, when PM Status bit in PMCSR register is set
    Bits: 19:0  PSTD(rw) - PME Service Timeout Delay: Specifies the timeout delay for retransmission of PM_PME messages. The value is in units of microseconds. The actual time elapsed has a +1 microseconds tolerance from the value programmed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PME_SERVICE_TIMEOUT_DELAY_REG 0x00000224
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_SERVICE_TIMEOUT_DELAY_REG_R21(_x) (((_x) & 0x7ff) << 21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_SERVICE_TIMEOUT_DELAY_REG_R21_of(_x) (((_x) >> 21) & 0x7ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_SERVICE_TIMEOUT_DELAY_REG_DPMOPS BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_SERVICE_TIMEOUT_DELAY_REG_PSTD(_x) (((_x) & 0xfffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PME_SERVICE_TIMEOUT_DELAY_REG_PSTD_of(_x) (((_x) >> 0) & 0xfffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ep_bus_device_number_reg -
    Bits: 31:16 R16(ro) - Reserved: Reserved
    Bits: 15:8  EPBN(ro) - Bus Number: Bus Number captured by Function 0 in End Point mode
    Bits:  7:5  R5(ro) - Reserved: Reserved
    Bits:  4:0  EPDN(ro) - Device Number: Device Number captured by Function 0 in End Point mode
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_EP_BUS_DEVICE_NUMBER_REG 0x0000022c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_R16(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_R16_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_EPBN(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_EPBN_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_R5(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_R5_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_EPDN(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_EP_BUS_DEVICE_NUMBER_REG_EPDN_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_mux_control_2_reg -
    Bits: 31:29 R31(ro) - Reserved: Reserved
    Bits: 28    DFLRTRB(rw) - Disable FLR Termination Resp Block: 1 : NP Termination due to FLR/Completion Timeout is delayed till the RX Completion FIFO is Empty. 0 : NP Termination due to FLR is done immediately on receiving FLR/Completion Timeout.
    Bits: 27    R27(ro) - Reserved: Reserved
    Bits: 26    R26(ro) - Reserved: Reserved
    Bits: 25    MSIXMSKEN(rw) - MSIX Function Mask Change Enhanced Interrupt Enable: By default, the Controller provides a single status bit when any function's MSIX Function Mask is programmed or configured by Local firmware or Host SW. Controller also implements an enhanced MSIX Function Mask Interrupt mechanism, which provides per-function set/clear status when a function's MSIX Function Mask is updated by SW. This Local Management programmable bit allows user to choose between the Default and Enhanced MSIX Function Mask Change Interrupt mechanisms.
    Bits: 24    MSIMSKEN(rw) - MSI Mask Change Enhanced Interrupt Enable: By default, the Controller provides a single status bit when any function's MSI Mask is programmed or configured by Local firmware or Host SW. Controller also implements an enhanced MSI Mask Interrupt mechanism, which provides per-function set/clear status when a function's MSI Mask is updated by SW. This Local Management programmable bit allows user to choose between the Default and Enhanced MSI Mask Change Interrupt mechanisms.
    Bits: 23    VARCCLKEN(rw) - Enable Variable Core Clock: If this bit is set the CORE_CLK input can be driven with Variable Clock depending on the Link Speed,similar to the PIPE_PCLK.
    Bits: 22:13 MAXNPREQ(rw) - Maximum NP Outstanding Request Limit: The Controller supports 128 outstanding NP requests that can be initiated by the User. However, the number of split completion TLPs that can be stored in the Controller is limited to 128. The Completion FIFO will overflow if more than 128 split completion packets are pending. If the User interface can accept inbound Posted and Completion packets at the same rate as received from PCIe link, then the split completion FIFO will never reach the FULL condition. However, if the User cannot guarantee this, then this register needs to be programmed as described in the Programming Guide section of the Controller User guide. The Controller will limit the maximum number of outstanding NP requests to the value programmed in this register. Example: 8 : Controller will limit maximum number of outstanding NP requests to 8. 0-7 : Reserved Default Value is 128
    Bits: 12    AXINPSPEN_RSVD(ro) - RESERVED: RESERVED
    Bits: 11    CMPTOADV(rw) - Completion Timeout Advisory Non Fatal: As per PCIe specification on Error Signaling, the Requester detecting a Completion Timeout is allowed to handle this as an Advisory Non Fatal Error. 1: Completion Timeout is handled as Advisory Non-Fatal Error. 0: Completion Timeout is handled as normally as a Non-Fatal Error.
    Bits: 10    PSNADV(rw) - Poisoned TLP Received Advisory Non Fatal: As per PCIe specification 2.7.2.2, the following Poisoned TLP requests must be handled as Uncorrectable and not as Advisory: I/O Write Request, Memory Write Request, or non-vendor-defined Message with data that target a Control structure. Since it is not possible for the Controller to determine if the target is a Control or a non-Control strusture, the Controller implements this bit for the user to determine the required handling. 1: Poisoned TLP of type IOWr, MemWr, MsgD will be handled as Advisory Non-Fatal Error. 0: Poisoned TLP of type IOWr, MemWr, MsgD will be handled as Uncorrectable Error. Note: Poisoned CplD will always be reported as Advisory Non-Fatal and is not controlled by this register setting.
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    R8(ro) - Reserved: Reserved
    Bits:  7:6  BLKALNWIN(rw) - Gen3 Block Alignment Check Window: When in the data stream at Gen3 or higher speeds, the pipe_rx_valid is asserted by the PHY. If the block alignment is lost, then the PHY may deassert pipe_rx_valid. Controller reports loss of block alignment if pipe_rx_valid or pipe_rx_data_valid=0 for a period consecutive clock cycles as programmed in this field. 00: 8 CORE_CLK cycles 01: 16 CORE_CLK cycles 10: 64 CORE_CLK cycles 11: 256 CORE_CLK cycles
    Bits:  5    BLKALNCHK(rw) - Gen3 Block Alignment Check Disable: When in the data stream at Gen3 or higher speeds, the pipe_rx_valid is asserted by the PHY. If the block alignment is lost, then the PHY may deassert pipe_rx_valid. Block Alignment may be lost if the received sync header is invalid. Controller supports detecting loss of block alignment while in a data stream in Gen3. 0: Enable check for loss of Gen3 Block Alignment during data stream. 1: Disable check for loss of Gen3 Block Alignment.
    Bits:  4    ARICAPMOD(rw) - ARI Capable Hierarchy Mode: As per SR IOC specification, ARI Capable Hierarchy bit is only present in the lowest numbered PF of a Device. The Controller has two modes to determine the lowest numbered PF. 0: the first PF which is enabled (PF0) is taken as the lowest numbered PF. 1: the first PF which has a non-zero TOTAL_VF_COUNT field is taken as the lowest numbered PF.(Default Mode)
    Bits:  3    ENLNCHK(rw) - Enable Link Lane Number Check for Loopback and Link Disable: As per PCIe specification, LTSSM should transition to Disabled after any Lanes that are transmitting TS1 Ordered Sets receive two consecutive TS1 Ordered Sets with the Disable Link bit asserted. Similarly, LTSSM should transition to Loopback after all Lanes that are transmitting TS1 Ordered Sets, that are also receiving TS1 Ordered Sets, receive the Loopback bit asserted in two consecutive TS1 Ordered Sets. Controller ignores the Link and Lane Number in the Received TS1s with Loopback/Disable bit set. Setting this bit to 1 turns on the check for link number (assigned by RC in Recovery.Idle) and lane number (PAD in Config.LW.Start or as assigned by RC in Recovery.Idle). This bit is recommended to be kept at the default value of 0.
    Bits:  2    DISSDSCHK(rw) - Disable SDS OS Check: As per PCIe specification, When using 128b/130b encoding, next state is L0 if eight consecutive Symbol Times of Idle data are received on all configured Lanes. The Controller checks to ensure that the Idle symbols of data are received in Data Blocks after SDS OS. This check is enabled by default. Setting this bit to 1 turns off this check. This bit is recommended to be kept at the default value of 0.
    Bits:  1    EXTSNP(rw) - Enable Extended Config Snoop Read: This bit can be set if an extra clock cycle is required by the Client Application logic to respond with the Read Data on Configuration Snoop Interface. Please refer to the user guide section on Configuration Snoop Interface for timing diagrams.
    Bits:  0    DLFFS(rw) - Disable LOCALLF, LOCALFS sampling after speed change: As per PIPE 4.2 specification, the LOCALLF, LOCALFS outputs from PHY can be sampled uponf PHYSTATUS pulse after Reset# OR upon the first PHYSTATUS pulse after speed change to GEN3. This bit can be set to 1 to disable sampling after speed change to GEN3 or higher
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_DEBUG_MUX_CONTROL_2_REG 0x00000234
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R31(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R31_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_DFLRTRB BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R27 BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R26 BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_MSIXMSKEN BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_MSIMSKEN BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_VARCCLKEN BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_MAXNPREQ(_x) (((_x) & 0x3ff) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_MAXNPREQ_of(_x) (((_x) >> 13) & 0x3ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_AXINPSPEN_RSVD BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_CMPTOADV BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_PSNADV BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R9 BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_R8 BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_BLKALNWIN(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_BLKALNWIN_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_BLKALNCHK BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_ARICAPMOD BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_ENLNCHK BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_DISSDSCHK BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_EXTSNP BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_DEBUG_MUX_CONTROL_2_REG_DLFFS BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_phy_status_1_reg -
    Bits: 31:9  R31(ro) - Reserved: Reserved
    Bits:  8    LOSBLKALN(w1c) - Loss of Block Alignment Error: This bit is set if the PHY Loses Block Alignment during data stream. This is detected based upon an unexpected PIPE_RX_VALID input deassertion during data stream. Write a 1 to clear this error.
    Bits:  7    INVSYNHR(w1c) - Invalid Sync Header Error: This bit is set if an invalid Sync Header is detected. 00 and 11 are Invalid Sync Headers. Write a 1 to clear this error. .
    Bits:  6    OSAFSDS(w1c) - OS Block Received After SDS: This bit is set if an SDS is received after an SDS. This is a framing error. Write a 1 to clear this error.
    Bits:  5    G3FRERR(w1c) - Gen3 Framing Error Detected: This bit is set if a framing error is detected while receiving a TLP in Gen3. Example, if an invalid token is received in a data stream, this error is flagged. Write a 1 to clear this error.
    Bits:  4    OSWOEDS(w1c) - OS Block Received without EDS: This bit is set if an Ordered Set Block is received without an EDS. This is a framing error. Write a 1 to clear this error.
    Bits:  3    DATEDS(w1c) - Data Block After EDS: This bit is set if a Data Block is received after an EDS. Write a 1 to clear this error.
    Bits:  2    ILOSEDS(w1c) - Illegal OS Block After EDS: The Valid OS blocks after an EDS are EIOS, EIEOS and SKP. If any other OS blocks are received after EDS, then it is a framing error and this bit is asserted.
    Bits:  1    OSASKP(w1c) - OS Block After Skip OS: This bit indicates that an Ordered Set BLock was received immediately after a SKIP OS. This is a framing error. Write a 1 to clear this field.
    Bits:  0    TLPPHYER(w1c) - TLP PHY Error Status: This bit indicates that a PHY Error was detected on the PIPE_RX_STATUS within a TLP. Write a 1 to clear this field.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PHY_STATUS_1_REG 0x00000238
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_R31(_x) (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_R31_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_LOSBLKALN BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_INVSYNHR BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_OSAFSDS BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_G3FRERR BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_OSWOEDS BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_DATEDS BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_ILOSEDS BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_OSASKP BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PHY_STATUS_1_REG_TLPPHYER BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_BAR_config_0_reg -
    Bits: 31:29 BAR3C(rw) - BAR 3 Control: Specifies the configuration of BAR3. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 28:24 BAR3A(rw) - BAR 3 Aperture: Specifies the aperture of the BAR 3 when it is configured as a 32-bit BAR. For 32-bit BAR 3, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits: 23:21 BAR2C(rw) - BAR 2 Control: Specifies the configuration of BAR2. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits: 20:16 BAR2A(rw) - BAR 2 Aperture: Specifies the aperture of the 32-bit BAR 2 or 64bit BAR2-3. For 32-bit BAR 2, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR2-3, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
    Bits: 15:13 BAR1C(rw) - BAR 1 Control: Specifies the configuration of BAR1. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  BAR1A(rw) - BAR 1 Aperture: Specifies the aperture of the BAR 1 when it is configured as a 32-bit BAR. For 32-bit BAR 1, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits:  7:5  BAR0C(rw) - BAR 0 Control: Specifies the configuration of BAR0. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  BAR0A(rw) - BAR 0 Aperture: Specifies the aperture of the 32-bit BAR 0 or 64bit BAR0-1. For 32-bit BAR 0, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR0-1, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_0_BAR_CONFIG_0_REG 0x00000240
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_1_BAR_CONFIG_0_REG 0x00000248
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_2_BAR_CONFIG_0_REG 0x00000250
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_3_BAR_CONFIG_0_REG 0x00000258
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR3C(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR3C_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR3A(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR3A_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR2C(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR2C_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR2A(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR2A_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR1C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR1C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR1A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR1A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR0C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR0C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR0A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_0_REG_BAR0A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_BAR_config_1_reg -
    Bits: 31    ERBC(rw) - Enable Resizable BAR Capability: Setting this bit to 1 enables the Resizable BAR Capability in the PCI Express Configuration Space of the associated Function. When the Resizable BAR Capability is enabled, the apertures of the memory BARs of the corresponding Function are no longer selected by the fields in this register, but by the setting of the registers in the Resizable BAR Capability Structure.
    Bits: 30:24 R24(ro) - Reserved: Reserved
    Bits: 23:22 R22(ro) - Reserved: Reserved
    Bits: 21    ERBE(rw) - EXP-ROM BAR Enable: This bit must be set to enable the Expansion ROM BAR associated with the Function.
    Bits: 20:16 ERBA(rw) - EXP-ROM BAR Aperture: Specifies the aperture of the Expansion ROM BAR. The encodings are: 00000-00011 = undefined, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 00110 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes,10010-11111 = undefined
    Bits: 15:13 BAR5C(rw) - BAR 5 Control: Specifies the configuration of BAR5. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  BAR5A(rw) - BAR 5 Aperture: Specifies the aperture of the BAR 5 when it is configured as a 32-bit BAR. For 32-bit BAR 5, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits:  7:5  BAR4C(rw) - BAR 4 Control: Specifies the configuration of BAR4. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  BAR4A(rw) - BAR 4 Aperture: Specifies the aperture of the 32-bit BAR 4 or 64bit BAR4-5. For 32-bit BAR 4, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR4-5, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_0_BAR_CONFIG_1_REG 0x00000244
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_1_BAR_CONFIG_1_REG 0x0000024c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_2_BAR_CONFIG_1_REG 0x00000254
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_3_BAR_CONFIG_1_REG 0x0000025c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_ERBC BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_R24(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_R24_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_R22(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_R22_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_ERBE BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_ERBA(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_ERBA_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR5C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR5C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR5A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR5A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR4C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR4C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR4A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_PF_BAR_CONFIG_1_REG_BAR4A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_0_reg -
    Bits: 31:29 VFBAR3C(rw) - VF BAR 3 Control: Specifies the configuration of VF BAR3. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 28:24 VFBAR3A(rw) - VF BAR 3 Aperture: Specifies the aperture of the VF BAR 3 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits: 23:21 VFBAR2C(rw) - VF BAR 2 Control: Specifies the configuration of VF BAR2. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits: 20:16 VFBAR2A(rw) - VF BAR 2 Aperture: Specifies the aperture of the 32-bit VF BAR 2 or 64bit VF BAR2-3. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
    Bits: 15:13 VFBAR1C(rw) - VF BAR 1 Control: Specifies the configuration of VF BAR1. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  VFBAR1A(rw) - VF BAR 1 Aperture: Specifies the aperture of the VF BAR 1 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits:  7:5  VFBAR0C(rw) - VF BAR 0 Control: Specifies the configuration of VF BAR0. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  VFBAR0A(rw) - VF BAR 0 Aperture: Specifies the aperture of the 32-bit VF BAR 0 or 64bit VF BAR0-1. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_0_VF_BAR_CONFIG_0_REG 0x00000280
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_1_VF_BAR_CONFIG_0_REG 0x00000288
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_2_VF_BAR_CONFIG_0_REG 0x00000290
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_3_VF_BAR_CONFIG_0_REG 0x00000298
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR3C(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR3C_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR3A(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR3A_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR2C(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR2C_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR2A(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR2A_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR1C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR1C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR1A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR1A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR0C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR0C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR0A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_0_REG_VFBAR0A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_1_reg -
    Bits: 31:16 R16(ro) - Reserved: Reserved
    Bits: 15:13 VFBAR5C(rw) - VF BAR 5 Control: Specifies the configuration of VF BAR5. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  VFBAR5A(rw) - VF BAR 5 Aperture: Specifies the aperture of the VF BAR 5 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits:  7:5  VFBAR4C(rw) - VF BAR 4 Control: Specifies the configuration of VF BAR4. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  VFBAR4A(rw) - VF BAR 4 Aperture: Specifies the aperture of the 32-bit VF BAR 4 or 64bit VF BAR4-5. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_0_VF_BAR_CONFIG_1_REG 0x00000284
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_1_VF_BAR_CONFIG_1_REG 0x0000028c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_2_VF_BAR_CONFIG_1_REG 0x00000294
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_3_VF_BAR_CONFIG_1_REG 0x0000029c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_R16(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_R16_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR5C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR5C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR5A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR5A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR4C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR4C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR4A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_VF_BAR_CONFIG_1_REG_VFBAR4A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_config_reg -
    Bits: 31:4  R(ro) - Reserved: Reserved
    Bits:  3    F3E(rw) - Function 3 Enable: Enable for Function 3. This bit can be modified from the local management bus.
    Bits:  2    F2E(rw) - Function 2 Enable: Enable for Function 2. This bit can be modified from the local management bus.
    Bits:  1    F1E(rw) - Function 1 Enable: Enable for Function 1. This bit can be modified from the local management bus.
    Bits:  0    F0E(ro) - Function 0 Enable: Enable for Function 0. This bit is hardwired to 1.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_PF_CONFIG_REG 0x000002c0
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_R(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_R_of(_x) (((_x) >> 4) & 0xfffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_F3E BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_F2E BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_F1E BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_PF_CONFIG_REG_F0E BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_default_preset_reg -
    Bits: 31:19 R31(ro) - Reserved: Reserved
    Bits: 18:8  S8GPR(rw) - Supported 8G Preset: This register can be used to program the Presets that are supported by local Transmitter at 8Gbps. Default value of this register is determined by the SUPPORTED_PRESET strap input. Note: At 8.0 GT/s and 16.0 GT/s all preset values must be supported for Full swing signaling. Reduced swing signaling must implement presets #4, #1, #9, #5, #6, and #3.
    Bits:  7    R7(ro) - Reserved: Reserved
    Bits:  6:4  GDRXPH(rw) - Default Receiver Preset Hint: Default receiver preset hint value used for a lane that did not receive EQ TS2 in Recovery.RcvrCfg LTSSM state
    Bits:  3:0  GDTXP(rw) - Default Transmitter Preset: Default transmitter preset value used for a lane that did not receive EQ TS2 in Recovery.RcvrCfg LTSSM state
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_DEFAULT_PRESET_REG 0x00000360
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_R31(_x) (((_x) & 0x1fff) << 19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_R31_of(_x) (((_x) >> 19) & 0x1fff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_S8GPR(_x) (((_x) & 0x7ff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_S8GPR_of(_x) (((_x) >> 8) & 0x7ff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_R7 BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_GDRXPH(_x) (((_x) & 0x7) << 4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_GDRXPH_of(_x) (((_x) >> 4) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_GDTXP(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_DEFAULT_PRESET_REG_GDTXP_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg -
    Bits: 31:30 RXEQABM(rw) - RXEQINPROGRESS Abort Timer Mode Control: When a 24ms timeout occurs in the LTSSM Equalization Phase 2, the Controller aborts Equalization Phase 2 and transitions to Recovery.Rcvr.Lock. In this case, the RxEqEval output on the PIPE Interface will be de-asserted immediately (if it was asserted). The RxEqInProgress output will stay high and waits for PhyStatus pulse. Controller implements a timer to select an upper limit to wait for this PhyStatus pulse during an abort to de-assert RxEqInProgress. 00: Wait for a maximum of 4 PIPE_PCLK period. 01: Wait for a maximum of 8 PIPE_PCLK period. 10: Wait for a maximum of 16 PIPE_PCLK period. 11: Disabled. Wait till PhyStatus Pulse is received. Note: This register is used only if RxEqEval was asserted when LTSSM 24ms timeout occured in Equalization.
    Bits: 29    RXEQABD(rw) - RXEQINPROGRESS Abort Disable: In an unexpected case where the PIPE_PCLK stops due to error in equalization, this bit can be set to de-couple RxEqInProgress from the rest of the equalization state machine. This bit should not be set for normal usage.
    Bits: 28    R28(ro) - Reserved: Reserved
    Bits: 27:0  LEQT2ms(rw) - Link Equalization Timeout 2ms: Time spent for evaluation per TX Setting in Endpoint Phase 2 (RC Mode Phase 3) of Link Equalization specified in multiples of 16ns. eg. the value 125000 will result in 125000*16ns = 2ms. Simulation with reduced time mode(PCIE_SIM define) will give a samller value of 300 as power on reset value.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG 0x00000364
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_RXEQABM(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_RXEQABM_of(_x) (((_x) >> 30) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_RXEQABD BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_R28 BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_LEQT2MS(_x) (((_x) & 0xfffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_TIMEOUT_2MS_REG_LEQT2MS_of(_x) (((_x) >> 0) & 0xfffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg -
    Bits: 31:3  RES3(ro) - Reserved: Reserved
    Bits:  2:0  MXECC(rw) - Max Eval Convergence Count: Controls the number of consecutive RxEqEval iterations with direction change feedback of 00s before Equalization Convergence is inferred. 0 : Infer Convergence after 1 feedback of 000000 1 : Infer Convergence after 2 feedback of 000000 2 : Infer Convergence after 3 consecutive feedback of 000000 .. 7 : Infer Convergence after 8 consecutive feedback of 000000. Note: Each lane independently counts consecutive feedback of 000000. Note: Count is reset after a non-000000 feedback on each lane.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_CTRL_REG 0x00000368
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_CTRL_REG_RES3(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_CTRL_REG_RES3_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_CTRL_REG_MXECC(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_GEN3_LINK_EQ_CTRL_REG_MXECC_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane0 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane1 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane2 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane3 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane4 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane5 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane6 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane7 -
    Bits: 31:26 RES3126(ro) - Reserved: Reserved
    Bits: 25:8  LEQTXCO(ro) - Link Equalization TX Coefficient: TX Coefficients agreed upon for this lane. [25:20] : Post Cursor Coefficient [19:14] : Cursor Coefficient [13:8] : Pre-Cusror Coefficient
    Bits:  7:5  RES75(ro) - Reserved: Reserved
    Bits:  4    LEQTXPRV(ro) - Link Equalization TX Preset Valid: TX Preset Valid Indicator. This bit is set when a TX Preset is received in TS1s with the use_preset bit set in Endpoint Mode Phase 3 or RC Mode Phase 2.
    Bits:  3:0  LEQTXPR(ro) - Link Equalization TX Preset: TX Preset agreed upon for this lane
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE0 0x00000380
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE1 0x00000384
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE2 0x00000388
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE3 0x0000038c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE4 0x00000390
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE5 0x00000394
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE6 0x00000398
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_GEN3_LINK_EQ_DEBUG_STATUS_REG_LANE7 0x0000039c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_RES3126(_x) (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_RES3126_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_LEQTXCO(_x) (((_x) & 0x3ffff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_LEQTXCO_of(_x) (((_x) >> 8) & 0x3ffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_RES75(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_RES75_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_LEQTXPRV BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_LEQTXPR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_GEN3_LINK_EQ_DEBUG_STATUS_REG_LEQTXPR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control0 -
    Bits: 27    L1DLEUP(rw) - Disable L1 exit upon Pending Tlps: Pending Tlps trigger a L1 exit by default. This includes internaly generated messages and internaly blocked TLPs. Setting this bit changes the default behavior. This is required only for debug purpose.
    Bits: 26:25 L1EM(ro) - L1 entry mode: This field shows the last entered L1 mode. This is useful for debug. bit 0 - Entry mode was ASPM. Bit 1 - Entry mode was PM. This is reset before any new L1 entry.
    Bits: 24    L1DBRI(rw) - Do Not block Request interface: Before entering L1, controller internally blocks all TLP and Register Request interface entering controller. interfaces are internally unblocked while exiting L1. This field control this behavior. '1' in this field makes the controler to do not perform any blocking to interfaces. '0' makes the controller behaves normaly. This is required only for debug purpose. Power shutoff feature has to be disabled while using this field.
    Bits: 23:0  L1XDELAY(rw) - L1 substate entry delay: Normaly L1 substate entry process is initiated immedaitely after LTSSM enters L1. A delay in micro-seconds can be given in this field to delay L1 substate entry process. This timeout has 0-1us margin of error. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_L1_SUBSTATE_ENTRY_DELAY
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_LOW_POWER_DEBUG_AND_CONTROL0 0x00000c88
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1DLEUP BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1EM(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1EM_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1DBRI BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1XDELAY(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL0_L1XDELAY_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control1 -
    Bits:  7:0  L1ER(ro) - L1 or L1.x Exit Trigger conditions: This field shows the values of possible L1 or L1-substate exit triggers. This is useful for debug. this is captured during L1 or L1-substate exit process. this field is reset during L1 entry. 0 : CLIENT_REQ_EXIT_L1 asserted 1 : Electrical Idle exit detected at link 2 : New TLP request detected 3 : Internal request to send TLP. This includes CFG completions. internal messages. INTx messages 4 : Pending TX traffic available. This could be traffic from DMA and blocked traffic due to credits at AXI. 5 : #CLKREQ assert detected 6 : CLIENT_REQ_EXIT_L1_SUBSTATE asserted 7 : Reg Access request detected Triggers #5,6,7 are valid only with L1-substate supported configs.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_LOW_POWER_DEBUG_AND_CONTROL1 0x00000c8c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL1_L1ER(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL1_L1ER_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control2 -
    Bits: 30    L1CSC(rw) - Client supplies slow clock to core during L1: L1-substate removes CORE_CLK. since the registers are implemented in core-clk, register access is not possible during L1-substate. If client can supply a slow clock to core(CORE_CLK) during L1-substates, APB/mgmt access is possible in L1.x. set this bit if client can supply slow clock to CORE_CLK when CLKREQ_IN_N is 1(de-asserted). If this bit is set, Controller neither wake-up from L1 or generate error response for APB access during L1.x. Controller behavior is undefined if register write is performed while slow clock is supplied to core_clk. Recommended flow is to first exit from L1-substate and perform register writes. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_CLIENT_SUPPLIES_SLOW_CLK_TO_CORE_DURING_L1
    Bits: 29    L1DAET(rw) - Disable Autonomous L1.x exit upon reg access: L1.x turns off clocks to the controller. Default behavior is made to exit L1.x if Register access request is present at register interface. Setting this bit disables this feature. If this bit is set and CLKREQ_IN_N is 1(de-asserted), Controller responds with ERROR response to APB requests. Client can use CLIENT_EXIT_L1_SUBSTATE pin to trigger L1.x exit if autonomous exit is disabled for register access. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_DISABLE_AUTONOMOUS_L1_EXIT_ON_NEW_REG_REQ
    Bits: 28    L1TROW(ro) - Timeout occured during RX and outstanding wait: This is a debug status field. '1' in this field indicates that a timeout has occured while waiting for RX path or OUTstanding packet IDLE conditions. This is cleared on new entry to L1.
    Bits: 26    L1ERC(rw) - Enable RX path check: Enables waiting for RX path IDLE condition before entering L1.x. This checks that all packets from PCIE link has reached client side before entering L1.x. This only a tuning register. Not setting this regsiter will cause controller to enter L1.x to save power without checking this. controller will resume transferring RX data once it exit from L1.x state if RX buffers were not empty. This field is ignored if Power shutoff mechanism is enabled for L1.x and Controller will always check RX path idle condition before turning off internal power(with cpf flow). If timeout is enabled, controller enters L1.x without internal power shutoff after timeout. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_WAIT_FOR_RX_BUFFER_IDLE
    Bits: 25    L1EOC(rw) - Enable outstanding CPL check: Enable waiting for outstanding completions before entering L1.x. Outstanding packets expected from pcie link as well as from AXI side is checked. FOR HAL configurations client has to assert PREVENT_L1x_ENTRY signal to prevent L1x entry. This only a tuning register. Not setting this regsiter will cause controller to enter L1.x to save power without checking this. controller exit from L1.x as soon as it receives expected TLps. This field is ignored if Power shutoff mechanism is selected for L1.x and Controller will always wait for outstanding packets before turning off internal power(with cpf flow). If timeout is enabled, controller enters L1.x without internal power shutoff after timeout. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_WAIT_FOR_OUTSTANDING_CPLS
    Bits: 23:0  L1TWROI(rw) - Timeout while waiting for RX IDLE and OUTSTANDING Idle.: This field enables a timeout mechanism while waiting for RX buffers and Outstanding Pkts before turning off power. Controller enters L1 substate after timeout. A value of 0x0 disables this timeout mechanism. Controller do not select internal power shutoff if it enters L1.x with this timeout. User can give timeout in micro-seconds using this register. This field is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_RX_CPL_IDLE_CHECK_TIMEOUT
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_LOW_POWER_DEBUG_AND_CONTROL2 0x00000c90
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1CSC BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1DAET BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1TROW BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1ERC BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1EOC BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1TWROI(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_LOW_POWER_DEBUG_AND_CONTROL2_L1TWROI_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_tl_internal_control -
    Bits: 31:1  RES1(ro) - Reserved: Reserved
    Bits:  0    ECFLR(rw) - Enable CRS under FLR: By default controller ignores config request if a function is under going FLR. Setting this bit Makes the controller to respond with CRS response. Power on reset value of this register can be adjusted by modifying the define `den_db_TL_CTRL_ENABLE_CRS_UNDER_FLR
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_TL_INTERNAL_CONTROL 0x00000c94
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_TL_INTERNAL_CONTROL_RES1(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_TL_INTERNAL_CONTROL_RES1_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_TL_INTERNAL_CONTROL_ECFLR BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_error_status_2_register -
    Bits: 31:10 R31(ro) - Reserved: Reserved
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    NFTSTOS(w1c) - NFTS Timeout Status: This status bit indicates that a NFTS Timeout occured. This could occur if the PHY failed to achieve lock on the receive data before the NFTS Timeout during Rx_L0s.FTS state. Local Firmware should consider increasing the advertized NFTS values if this event occurs.
    Bits:  7:4  R4(ro) - Reserved: Reserved
    Bits:  3    MSIXMSKSETST(w1c) - MSIX Function Mask Set Status: This status bit indicates that the MSIX Function Mask of any function, PF or VF, was programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSIX Function Mask Clear status per-function is captured in the msix_function_mask_set_status_register. Firmware has to clear the per-function bits in msix_function_mask_set_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  2    MSIXMSKCLST(w1c) - MSIX Function Mask Cleared Status: This status bit indicates that the MSIX Function Mask of any function, PF or VF, was programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSIX Function Mask Clear status per-function is captured in the msix_function_mask_cleared_status_register. Firmware has to clear the per-function bits in msix_function_mask_cleared_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  1    MSIMSKSETST(w1c) - MSI Mask Set Status: This status bit indicates that One or More bits of MSI Mask of any function, PF or VF, was programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSI Mask Clear status per-function is captured in the msi_mask_set_status_register. Firmware has to clear the per-function bits in msi_mask_set_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  0    MSIMSKCLST(w1c) - MSI Mask Cleared Status: This status bit indicates that One or More bits of MSI Mask of any function, PF or VF, was programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSI Mask Clear status per-function is captured in the msi_mask_cleared_status_register. Firmware has to clear the per-function bits in msi_mask_cleared_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LOCAL_ERROR_STATUS_2_REGISTER 0x00000d00
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_R31(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_R31_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_R9 BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_NFTSTOS BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_R4(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_R4_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_MSIXMSKSETST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_MSIMSKSETST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_ERROR_STATUS_2_REGISTER_MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg -
    Bits: 31:10 R31(ro) - Reserved: Reserved
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    NFTSTOM(rw) - NFTS Timeout Mask: Mask for NFTS Timeout.
    Bits:  7:4  R4(ro) - Reserved: Reserved
    Bits:  3    MSIXMSKSET(rw) - MSIX Function Mask Set: Mask for MSIX Function Mask Cleared Status.
    Bits:  2    MSIXMSKCL(rw) - MSIX Function Mask Cleared: Mask for MSIX Function Mask Set Status.
    Bits:  1    MSIMSKSET(rw) - MSI Mask Set: Mask for MSI Mask Set Status.
    Bits:  0    MSIMSKCL(rw) - MSI Mask Cleared: Mask for MSI Mask Cleared Status.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_I_LOCAL_INTRPT_MASK_2_REG 0x00000d04
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_R31(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_R31_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_R9 BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_NFTSTOM BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_R4(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_R4_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_MSIXMSKSET BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_MSIXMSKCL BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_MSIMSKSET BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_I_LOCAL_INTRPT_MASK_2_REG_MSIMSKCL BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_1 -
    Bits: 31    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIMSKCLST(w1c) - PF3 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIMSKCLST(w1c) - PF2 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIMSKCLST(w1c) - PF1 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIMSKCLST(w1c) - PF0 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_CLEARED_STATUS_1 0x00000d10
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF27MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF26MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF25MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF24MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF23MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF22MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF21MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF20MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF19MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF18MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF17MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF16MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF15MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF14MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF13MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF12MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF11MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF10MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF9MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF8MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF7MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF6MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF5MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF4MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF3MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF2MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF1MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_VF0MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_PF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_PF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_PF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_1_PF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_1 -
    Bits: 31    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIMSKCLST(w1c) - PF3 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIMSKCLST(w1c) - PF2 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIMSKCLST(w1c) - PF1 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIMSKCLST(w1c) - PF0 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_SET_STATUS_1 0x00000d14
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF27MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF26MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF25MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF24MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF23MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF22MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF21MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF20MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF19MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF18MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF17MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF16MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF15MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF14MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF13MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF12MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF11MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF10MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF9MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF8MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF7MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF6MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF5MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF4MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF3MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF2MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF1MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_VF0MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_PF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_PF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_PF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_1_PF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_1 -
    Bits: 31    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIXMSKCLST(w1c) - PF3 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIXMSKCLST(w1c) - PF2 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIXMSKCLST(w1c) - PF1 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIXMSKCLST(w1c) - PF0 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_CLEARED_STATUS_1 0x00000d18
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF27MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF26MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF25MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF24MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF23MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF22MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF21MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF20MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF19MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF18MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF17MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF16MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF15MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF14MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF13MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF12MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF11MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF10MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF9MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF8MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF7MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF6MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF5MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF4MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF3MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF2MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF1MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_VF0MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_PF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_PF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_PF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_1_PF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_1 -
    Bits: 31    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIXMSKCLST(w1c) - PF3 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIXMSKCLST(w1c) - PF2 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIXMSKCLST(w1c) - PF1 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIXMSKCLST(w1c) - PF0 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_SET_STATUS_1 0x00000d1c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF27MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF26MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF25MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF24MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF23MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF22MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF21MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF20MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF19MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF18MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF17MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF16MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF15MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF14MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF13MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF12MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF11MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF10MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF9MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF8MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF7MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF6MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF5MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF4MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF3MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF2MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF1MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_VF0MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_PF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_PF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_PF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_1_PF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_2 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_CLEARED_STATUS_2 0x00000d20
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_2_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_2 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_SET_STATUS_2 0x00000d24
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_2_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_2 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_CLEARED_STATUS_2 0x00000d28
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_2_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_2 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_SET_STATUS_2 0x00000d2c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_2_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_3 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_CLEARED_STATUS_3 0x00000d30
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_CLEARED_STATUS_3_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_3 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSI_MASK_SET_STATUS_3 0x00000d34
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSI_MASK_SET_STATUS_3_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_3 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_CLEARED_STATUS_3 0x00000d38
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_CLEARED_STATUS_3_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_3 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_MSIX_FUNCTION_MASK_SET_STATUS_3 0x00000d3c
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_MSIX_FUNCTION_MASK_SET_STATUS_3_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_rx_elec_idle_filter_control -
    Bits: 31:24 GFLCP(rw) - RX Electrical Idle Glitch Filter Count PM Clocks: This controls the glitch filter on PM Clock domain. This counter indicates the number of PM Clocks the glitch will be filtered out. The total delay of the glitch filter is calculated as (PM Clock Period * Number of PM Clocks) this delay should be same or close enough for both Core Clock(GFLCC) and PM Clock(GFLCP)
    Bits: 23:16 GFLCC(rw) - RX Electrical Idle Glitch Filter Count CORE Clocks: This controls the glitch filter on CORE Clock domain. This counter indicates the number of CORE Clocks the glitch will be filtered out. Thetotal delay of the glitch filter is calculated as (CORE Clock Period * Number of CORE Clocks) thisdelay should be same or close enough for both CORE Clock(GFLCC) and PM Clock(GFLCP)
    Bits: 15:8  RSVGFLD(ro) - Reserved: Reserved
    Bits:  7:0  GFLD(rw) - RX Electrical Idle Glitch Filter Disable: By default controller enables glitch filter on all lanes. Setting this bit to one makes the controller to disable the glitch filter on that corresponding lanes in which the bit is set. When all bits are set to one the Glitch filter is completely bypassed, When any bit is zero glitch filter is enabled, and de-glitching is done only on the lanes that are set to zero
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_RX_ELEC_IDLE_FILTER_CONTROL 0x00000da4
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLCP(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLCP_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_RSVGFLD(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_RSVGFLD_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLD(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_I_REGF_LM_PCIE_BASE_RX_ELEC_IDLE_FILTER_CONTROL_GFLD_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_vendor_id_device_id -
    Bits: 31:16 DID(ro) - Device ID: Device ID assigned by the manufacturer of the device. On power-up, the core sets it to the value defined in the RTL file reg_defaults.h. This field can be written independently for each Function from the local management bus.
    Bits: 15:0  VID(ro) - Vendor ID: A read to this register returns FFFFh for VFs
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_VENDOR_ID_DEVICE_ID 0x00000000
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_DID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_DID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_VID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_VENDOR_ID_DEVICE_ID_VID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_command_status -
    Bits: 31    DPE(w1c) - Detected Parity Error: This bit is set when the core has received a Poisoned TLP targeted at this VF. The Parity Error Response enable bit (bit 6) in the PCI Command Register of the associated PF has no effect on the setting of this bit. STICKY.
    Bits: 30    SSE(w1c) - Signaled System Error: If the SERR enable bit in the PCI Command Register of the associated Physical Function is 1, this bit is set when this VF has sent out a fatal or non-fatal error message on the link to the Root Complex. If the SERR enable bit is 0, this bit remains 0. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 29    RMA(w1c) - Received Master Abort: This bit is set when this VF has received a completion from the link with the Unsupported Request status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 28    RTA(w1c) - Received Target Abort: This bit is set when this Virtual Function has received a completion from the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 27    STA(w1c) - Signaled Target Abort: This bit is set when the core has sent a completion from this VF to the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 26:25 R5(ro) - Reserved: Reserved
    Bits: 24    MDPE(w1c) - Master Data Parity Error: When the Parity Error Response enable bit in the PCI Command Register of the associated Physical Function is set, the core sets this bit when it detects the following error conditions: (i) The core receives a Poisoned Completion TLP from the link in response to a request from this VF. (ii) The core sends out a poisoned write request on the link from this VF. (This bit remains 0 when the Parity Error Response enable bit in the PCI Command Register of the associated Physical Function is 0). This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 23:21 R4(ro) - Reserved: Reserved
    Bits: 20    CL(ro) - Capabilities List: Indicates the presence of PCI Extended Capabilities registers. This bit is hardwired to 1.
    Bits: 19    IS(ro) - Interrupt Status: Reserved
    Bits: 18:11 R3(ro) - Reserved: Reserved
    Bits: 10    IMD(ro) - INTx Message Disable: Reserved
    Bits:  9    R2(ro) - Reserved: Reserved
    Bits:  8    SE(ro) - SERR Enable: Reserved
    Bits:  7    R1(ro) - Reserved: Reserved
    Bits:  6    PERE(ro) - Parity Error Response Enable: Reserved
    Bits:  5:3  R0(ro) - Reserved: Reserved
    Bits:  2    BME(rw) - Bus-Master Enable: Enables the device to issue memory requests from this Function. This field can be written from the local management bus.
    Bits:  1    MSE(ro) - Mem-Space Enable: Reserved
    Bits:  0    IOSE(ro) - IO-Space Enable: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_COMMAND_STATUS     0x00000004
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_DPE BIT(31)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_SSE BIT(30)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_RMA BIT(29)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_RTA BIT(28)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_STA BIT(27)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R5(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R5_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_MDPE BIT(24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R4(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R4_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_CL BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_IS BIT(19)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R3(_x) (((_x) & 0xff) << 11)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R3_of(_x) (((_x) >> 11) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_IMD BIT(10)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R2 BIT(9)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_SE BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R1 BIT(7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_PERE BIT(6)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R0(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_R0_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_BME BIT(2)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_MSE BIT(1)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_COMMAND_STATUS_IOSE BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_revision_id_class_code -
    Bits: 31:24 CC(ro) - Class Code: Identifies the function of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 23:16 SCC(ro) - Sub-Class Code: Identifies a sub-category within the selected function. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 15:8  PIB(ro) - Programming Interface Byte: Identifies the register set layout of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits:  7:0  RID(ro) - Revision ID: Assigned by the manufacturer of the device to identify the revision RO Setting of this field Denali Cadence-PCIe Core User Guide, PMC-Sierra Version 3.4 202 number of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_REVISION_ID_CLASS_CODE 0x00000008
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_CC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_CC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_SCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_SCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_PIB(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_PIB_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_RID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_REVISION_ID_CLASS_CODE_RID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bist_header_latency_cache_line -
    Bits: 31:24 BR(ro) - BIST Register: Reserved
    Bits: 23    DT(ro) - Device Type: Identifies whether the device supports a single Function or multiple Functions. This bit is read as 0 when only Function 0 has been enabled in the Physical Function Configuration Register (in the local management block). Reserved for VFs
    Bits: 22:16 HT(ro) - Header Type: Reserved
    Bits: 15:8  LT(ro) - Latency Timer: Reserved
    Bits:  7:0  CLS(ro) - Cache Line Size: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BIST_HEADER_LATENCY_CACHE_LINE 0x0000000c
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_BR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_BR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_DT BIT(23)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_HT(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_HT_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_LT(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_LT_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_CLS(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BIST_HEADER_LATENCY_CACHE_LINE_CLS_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_0_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_0_REG          0x00000010
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_0_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_0_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_1_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_1_REG          0x00000014
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_1_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_1_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_2_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_2_REG          0x00000018
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_2_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_2_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_3_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_3_REG          0x0000001c
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_3_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_3_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_4_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_4_REG          0x00000020
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_4_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_4_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_5_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_BAR_5_REG          0x00000024
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_5_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_BAR_5_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_rsvd_0A -
  Register: i_vf_pcie_base_rsvd_0E -
  Register: i_vf_MSI_cap_struct_rsvd_02A_02B_[2] -
  Register: i_vf_MSIX_cap_struct_rsvd_02F -
  Register: i_vf_PCIE_cap_struct_rsvd_034_038_[5] -
  Register: i_vf_PCIE_cap_struct_rsvd_03A_03F_[6] -
  Register: i_vf_AER_cap_struct_rsvd_04B_04D_[3] -
  Register: i_vf_ARI_cap_struct_rsvd_052_09C_[75] -
    Bits: 31:0  RSVD(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_RSVD_0A              0x00000028
#define NFP3800_PCIEX_VF_i_vf_pcie_base_RSVD_0E              0x00000038
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_RSVD_02A_02B(_x) (0x000000a8 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_RSVD_02F       0x000000bc
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_RSVD_034_038(_x) (0x000000d0 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_RSVD_03A_03F(_x) (0x000000e8 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_RSVD_04B_04D(_x) (0x0000012c + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_RSVD_052_09C(_x) (0x00000148 + (0x4 * ((_x) & 0x7f)))
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_VF_GENERIC_RESERVED_REG_VF_CL_RSVD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_VF_GENERIC_RESERVED_REG_VF_CL_RSVD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i -
    Bits: 31:16 SID(ro) - Subsystem ID: Specifies the Subsystem ID assigned by the manufacturer of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 15:0  SVID(ro) - Subsystem Vendor ID: Specifies the Subsystem Vendor ID assigned by the PCI SIG to the manufacturer of the device.This field when read reflects the Subsystem Vendor ID of the Physical Function the VF is associated with.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I 0x0000002c
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SVID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_SUBSYSTEM_VENDOR_ID_SUBSYSTEM_I_SVID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_expansn_rom_bar_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_EXPANSN_ROM_BAR_REG 0x00000030
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_EXPANSN_ROM_BAR_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_EXPANSN_ROM_BAR_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_capabilities_pointer -
    Bits: 31:8  R6(ro) - Reserved: Reserved
    Bits:  7:0  CP(ro) - Capabilities Pointer: Contains pointer to the first PCI Capability Structure. This field is set by default to point to the Power Management Capability Structure. It can be modified by writing to VF 0 from the local management bus, and the setting is common across all VFs.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_CAPABILITIES_POINTER 0x00000034
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_CAPABILITIES_POINTER_R6(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_CAPABILITIES_POINTER_R6_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_CAPABILITIES_POINTER_CP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_CAPABILITIES_POINTER_CP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_intrpt_line_intrpt_pin_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_I_INTRPT_LINE_INTRPT_PIN_REG 0x0000003c
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_REG_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_BASE_I_INTRPT_LINE_INTRPT_PIN_REG_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap -
    Bits: 31    PSDCS(ro) - PME Support for D3(cold) State: Indicates whether the Function is capable of sending PME messages when in the D3cold state. Because the device does not have aux power, this bit is hardwired to 0.
    Bits: 30    PSDHS(rw) - PME Support for D3(hot) State: Indicates whether the Function is capable of sending PME messages when in the D3hot state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 29    PSD2S(ro) - PME Support for D2 State: Indicates whether the Function is capable of sending PME messages when in the D2 state. This bit is hardwired to 0 because D2 state is not supported.
    Bits: 28    PSD1S(rw) - PME Support for D1 State: Indicates whether the Function is capable of sending PME messages when in the D1 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 27    PSD0S(rw) - PME Support for D0 State: Indicates whether the Function is capable of sending PME messages when in the D0 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 26    D2S(ro) - D2 Support: Set if the Function supports the D2 power state. Currently hardwired to 0.
    Bits: 25    D1S(rw) - D1 Support: Set if the Function supports the D1 power state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 24:22 MCRAPS(ro) - Max Current Required from Aux Power Supply: Specifies the maximum current drawn by the device from the aux power source in the D3cold state. This field is not implemented in devices not supporting PME notification when in the D3cold state, and is therefore hardwired to 0.
    Bits: 21    DSI(ro) - Device Specific Initialization Bit: This bit, when set, indicates that the device requires additional configuration steps beyond setting up its PCI configuration space, to bring it to the D0active state from the D0uninitialized state. This bit is hardwired to 0.
    Bits: 20    R0(ro) - Reserved: Reserved
    Bits: 19    PC(ro) - PME Clock: Not applicable to PCI Express. This bit is hardwired to 0.
    Bits: 18:16 VID(ro) - Version ID: Indicates the version of the PCI Bus Power Management Specifications that the Function implements. This field is set by default to 011 (Version 1.2). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. The core sets it to the value defined in the RTL file reg_defaults.h. By default, this points to the MSI Capability Structure. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  CID(ro) - Capability ID: Identifies that the capability structure is for Power Management. This field is set by default to 01 hex. It can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_I_PWR_MGMT_CAP 0x00000088
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSDCS BIT(31)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSDHS BIT(30)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD2S BIT(29)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD1S BIT(28)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PSD0S BIT(27)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_D2S BIT(26)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_D1S BIT(25)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_MCRAPS(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_MCRAPS_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_DSI BIT(21)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_R0 BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_PC BIT(19)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_VID(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_VID_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CAP_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep -
    Bits: 31:24 DR(ro) - Data Register: This optional register is not implemented in the Cadence PCIe core. This field is hardwired to 0.
    Bits: 23:16 R1(ro) - Reserved: Reserved
    Bits: 15    PMES(rw) - PME Status: When PME notification is enabled, writing a 1 into this bit position from the local management bus sets this bit and causes the core to send a PME message from the associated Function. When the Root Complex processes this message, it will turn off this bit by writing a 1 into this bit position though a Config Write. This bit can be set or cleared from the local management bus, by writing a 1 or 0, respectively. It can only be cleared from the configuration path (by writing a 1).
    Bits: 14:9  R2(ro) - Reserved: Reserved
    Bits:  8    PE(rw) - PME Enable: Setting this bit enables the notification of PME events from the associated Function. This bit can be set also by writing into this register from the local management bus.
    Bits:  7:4  R3(ro) - Reserved: Reserved
    Bits:  3    NSR(rw) - No Soft Reset: When this bit is set to 1, the Function will maintain all its state in the PM state D3hot. The software is not required to re-initialize the Function registers on the transition back to D0. This bit is set to 1 by default, but can be modified independently for each VF from the local management bus.
    Bits:  2    R4(ro) - Reserved: Reserved
    Bits:  1:0  PS(rw) - Power State: Indicates the power state this Function is currently in. This field can be read by the software to monitor the current power state, or can be written to cause a transition to a new state. The valid settings are 00 (state D0), 01 (state D1) and 11 (state D3hot). The software should not write any other value into this field. This field can also be written from the local management bus independently for each VF Function.
*/
#define NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_I_PWR_MGMT_CTRL_STAT_REP 0x0000008c
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_DR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_DR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PMES BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R2(_x) (((_x) & 0x3f) << 9)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R2_of(_x) (((_x) >> 9) & 0x3f)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PE BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R3(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R3_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_NSR BIT(3)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_R4 BIT(2)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PS(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_VF_I_VF_POWER_MGMT_CAP_STRUCT_I_PWR_MGMT_CTRL_STAT_REP_PS_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_ctrl_reg -
    Bits: 31:25 R0(ro) - Reserved: Reserved
    Bits: 24    MC(rw) - MSI masking capable: can be modified using localmanagement interface
    Bits: 23    AC64(rw) - 64-Bit Address Capable: Set to 1 to indicate that the device is capable of generating 64-bit addresses for MSI messages.
    Bits: 22:20 MME(rw) - Multiple Message Enable: Encodes the number of distinct messages that the core is programmed to generate for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). This setting must be based on the number of interrupt inputs of the core that are actually used by this Function. This field can be written from the local management bus.
    Bits: 19:17 MMC(rw) - Multiple Message Capable: Encodes the number of distinct messages that the core is capable of generating for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). Thus, this field defines the number of the interrupt vectors for this Function. The core allows up to 32 distinct messages, but the setting of this field must be based on the number of interrupt inputs of the core that are actually used by the client. For example, if the client logic uses 8 of the 32 distinct MSI interrupt inputs of the core for this Function, then the value of this field must be set to 011. This field can be written from the local management bus. Please see the `define den_db_VF_MSI_MULTIPLE_MSG_CAPABLE for default value in the reg_defaults.v files.
    Bits: 16    ME(rw) - MSI Enable: Set by the configuration program to enable the MSI feature. This field can also be written from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Pointer to the next PCI Capability Structure. The value read from this read-only field is the corresponding pointer in the MSI Capability Structure of the Physical Function this VF is attached to. The setting is common across all the Virtual Functions.
    Bits:  7:0  CID(ro) - Capability ID: Specifies that the capability structure is for MSI. Hardwired to 05 hex.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_CTRL_REG  0x00000090
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_R0(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_R0_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MC BIT(24)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_AC64 BIT(23)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MME(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MME_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MMC(_x) (((_x) & 0x7) << 17)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_MMC_of(_x) (((_x) >> 17) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_ME BIT(16)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_CTRL_REG_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_low_addr -
    Bits: 31:2  MAL(rw) - Message Address Low: Lower bits of the address to be used in MSI messages. This field can also be written from the local management bus.
    Bits:  1:0  R1(ro) - Reserved: The two lower bits of the address are hardwired to 0 to align the address on a double-word boundary.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_MSG_LOW_ADDR 0x00000094
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_MAL(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_MAL_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_R1(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_LOW_ADDR_R1_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_hi_addr -
    Bits: 31:0  MAH(rw) - Message Address High: Contains bits 63:32 of the 64-bit address to be used in MSI Messages. A value of 0 specifies that 32-bit addresses are to be used in the messages. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_MSG_HI_ADDR 0x00000098
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_HI_ADDR_MAH(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_HI_ADDR_MAH_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_data -
    Bits: 31:16 R2(ro) - Reserved: Hardwired to 0
    Bits: 15:0  MD(rw) - Message Data: Message data to be used for this Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_MSG_DATA  0x0000009c
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_DATA_R2(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_DATA_R2_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_DATA_MD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MSG_DATA_MD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_mask -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MM(rw) - MSI Mask: Mask bits for MSI interrupts. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid mask bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Mask field also changes correspondingly
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_MASK      0x000000a0
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MASK_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MASK_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_MASK_MM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_pending_bits -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MP(rw) - MSI Pending Bits: Pending bits for MSI interrupts. This register contains the MSI pending interrupt bits, one for each of the interrupt levels. This field can be written from the local management bus. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid pending bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Pending Bits field also changes correspondingly
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_I_MSI_PENDING_BITS 0x000000a4
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_VF_I_VF_MSI_CAP_STRUCT_I_MSI_PENDING_BITS_MP BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_ctrl -
    Bits: 31    MSIXE(rw) - MSI-X Enable: Set by the configuration program to enable the MSI-X feature. This field can also be written from the local management bus.
    Bits: 30    FM(rw) - Function Mask: This bit serves as a global mask to all the interrupt conditions associated with this Function. When this bit is set, the core will not send out MSI messages from this Function. This field can also be written from the local management bus.
    Bits: 29:27 R0(ro) - Reserved: Reserved
    Bits: 26:16 MSIXTS(rw) - MSI-X Table Size: Specifies the size of the MSI-X Table, that is, the number of interrupt vectors defined for the Function. The programmed value is 1 minus the size of the table (that is, this field is set to 0 if the table size is 1.). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Contains a pointer to the next PCI Capability Structure. The value read from this read-only field is the corresponding pointer in the MSI-X Capability Structure of the Physical Function this VF is attached to.
    Bits:  7:0  CID(ro) - Capability ID: Identifies that the capability structure is for MSI-X. This field is set by default to 11 hex. It can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_I_MSIX_CTRL    0x000000b0
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXE BIT(31)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_FM BIT(30)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_R0(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_R0_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_MSIXTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_CTRL_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_tbl_offset -
    Bits: 31:3  TO(rw) - Table Offset: Offset of the memory address where the MSI-X Table is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the MSI-X Table is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5).
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_I_MSIX_TBL_OFFSET 0x000000b4
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_TO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_TO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_TBL_OFFSET_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_pending_intrpt -
    Bits: 31:3  PO(rw) - PBA Offset: Offset of the memory address where the PBA is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_I_MSIX_PENDING_INTRPT 0x000000b8
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_PO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_PO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_I_VF_MSIX_CAP_STRUCT_I_MSIX_PENDING_INTRPT_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_cap_list -
    Bits: 31    R0(ro) - Reserved: Reserved
    Bits: 30    TRS(ro) - TCS Routing Supported: When set to 1, this bit indicates that the device supports routing of Trusted Configuration Requests. Not valid for Endpoints. Hardwired to 0.
    Bits: 29:25 IMN(ro) - Interrupt Message Number: Identifies the MSI or MSI-X interrupt vector for the interrupt message generated corresponding to the status bits in the Slot Status Register, Root Status Register, or this capability structure. This field must be defined based on the chosen interrupt mode - MSI or MSI-X. This field is hardwired to 0.
    Bits: 24    SS(ro) - Slot Status: Set to 1 when the link connected to a slot. Hardwired to 0.
    Bits: 23:20 DT(ro) - Device Type: Indicates the type of device implementing this Function. This field is hardwired to 0 in the EP mode.
    Bits: 19:16 CV(ro) - Capability Version: Identifies the version number of the capability structure. This field is set to 2 by default to indicate that the Controller is compatible to PCI Express Base Specification Revision 3.0.
    Bits: 15:8  NCP(ro) - Next Capability Pointer: Points to the next PCI capability structure. Set to 0 because this is the last capability structure.
    Bits:  7:0  CID(ro) - Capability ID: Specifies Capability ID assigned by PCI SIG for this structure. This field is hardwired to 10 hex.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_I_PCIE_CAP_LIST 0x000000c0
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_R0 BIT(31)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_TRS BIT(30)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_IMN(_x) (((_x) & 0x1f) << 25)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_IMN_of(_x) (((_x) >> 25) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_SS BIT(24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_DT(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_DT_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_NCP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_NCP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_CAP_LIST_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_cap -
    Bits: 31:29 R3(ro) - Reserved: Reserved
    Bits: 28    FLRC(ro) - FLR Capable: Set when device has Function-Level Reset capability. Hardwired to 1.
    Bits: 27:26 CPLS(ro) - Captured Power Limit Scale: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 25:18 CSPLV(ro) - Captured Slot Power Limit Value: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 17:16 R2(ro) - Reserved: Reserved
    Bits: 15    RBER(ro) - Role-Based Error Reporting: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 14:12 R1(ro) - Reserved: Reserved
    Bits: 11:9  AL1SL(ro) - Acceptable L1 Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L1 to L0. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  8:6  AL0SL(ro) - Acceptable L0S Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L0S to L0. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  5    ETFS(ro) - Extended Tag Field Supported: Set when device allows the tag field to be extended from 5 to 8 bits. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  4:3  PFS(ro) - Phantom Functions Supported: This field is used to extend the tag field by combining unused Function bits with the tag bits. This field is hardwired to 00 to disable this feature.
    Bits:  2:0  MPS(ro) - Max Payload Size: Specifies maximum payload size supported by the device. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_I_PCIE_DEV_CAP 0x000000c4
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R3(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R3_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_FLRC BIT(28)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CPLS(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CPLS_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CSPLV(_x) (((_x) & 0xff) << 18)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_CSPLV_of(_x) (((_x) >> 18) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R2_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_RBER BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R1(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_R1_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL1SL(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL1SL_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL0SL(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_AL0SL_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_ETFS BIT(5)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_PFS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_PFS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_MPS(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_MPS_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status -
    Bits: 31:22 R4(ro) - Reserved: Reserved
    Bits: 21    TP(ro) - Transaction Pending: Indicates if any of the Non-Posted requests issued by the VF are still pending.
    Bits: 20    APD(ro) - Aux Power Detected: Reserved
    Bits: 19    URD(w1c) - Unsupported Request Detected: Set to 1 by the core when it receives an unsupported request, regardless of whether its reporting is enabled or not.
    Bits: 18    FED(w1c) - Fatal Error Detected: Set to 1 by the core when it detects a fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 17    NFER(w1c) - Non-Fatal Error Detected: Set to 1 by the core when it detects a non-fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 16    CED(w1c) - Correctable Error Detected: Set to 1 by the core when it detects a correctable error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked
    Bits: 15    FLR(rw) - Function-Level Reset: Writing a 1 into this bit position generated a Function-Level Reset for the selected VF. This bit reads as 0.
    Bits: 14:12 MRRS(ro) - Max Read Request Size: Reserved
    Bits: 11    EBS(ro) - Enable No Snoop: Reserved
    Bits: 10    EAP(ro) - Enable Aux Power: Reserved
    Bits:  9    EPF(ro) - Enable Phantom Functions: Reserved
    Bits:  8    ETFE(ro) - Extended Tag Field Enable: Reserved
    Bits:  7:5  MPS(ro) - Max Payload Size: Reserved
    Bits:  4    ERO(ro) - Enable Relaxed Ordering: Reserved
    Bits:  3    EURR(ro) - Enable Unsupported Request Reporting: Reserved
    Bits:  2    EFER(ro) - Enable Fatal Error Reporting: Reserved
    Bits:  1    ENFER(ro) - Enable Non-Fatal Error Reporting: Reserved
    Bits:  0    ECER(ro) - Enable Correctable Error Reporting: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_I_PCIE_DEV_CTRL_STATUS 0x000000c8
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_R4(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_R4_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_TP BIT(21)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_APD BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_URD BIT(19)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_FED BIT(18)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_NFER BIT(17)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_CED BIT(16)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_FLR BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MRRS(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MRRS_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EBS BIT(11)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EAP BIT(10)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EPF BIT(9)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ETFE BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MPS(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_MPS_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ERO BIT(4)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EURR BIT(3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_EFER BIT(2)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ENFER BIT(1)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CTRL_STATUS_ECER BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_link_cap -
    Bits: 31:24 PN(ro) - Port Number: Specifies the port number assigned to the PCI Express link connected to this device.
    Bits: 23    R5(ro) - Reserved: Reserved
    Bits: 22    AOC(ro) - ASPM Optionality Compliance: Setting this bit indicates that the device supports the ASPM Optionality feature. It can be turned off by writing a 0 to this bit position through the local management bus.
    Bits: 21    LBNC(ro) - Link Bandwidth Notification Capability: A value of 1b indicates support for the Link Bandwidth Notification status and interrupt mechanisms. Reserved for Endpoint.
    Bits: 20    DLLARC(ro) - Data Link Layer Active Reporting Capability: Set to 1 if the device is capable of reporting that the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0, as this version of the core does not support the feature.
    Bits: 19    SDERC(ro) - Surprise Down Error Reporting Capability: Indicates the capability of the device to report a Surprise Down error condition. This bit is hardwired to 0, as this version of the core does not support the feature.
    Bits: 18    CPM(ro) - Clock Power Management: Indicates that the device supports removal of referenc clocks. It is set by default to the value of the define in reg_defaults.h. It can be re-written independently for each function from the local management bus.
    Bits: 17:15 L1EL(ro) - L1 Exit Latency: Specifies the exit latency from L1 state. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 L0SEL(ro) - L0S Exit Latency: Specifies the time required for the device to transition from L0S to L0. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 11:10 ASPM(ro) - Active State Power Management: Indicates the level of ASPM support provided by the device. This field can be re-written independently for each Function from the local management bus. When SRIS is enabled in local management register bit, L0s capability is not supported and is forced low.
    Bits:  9:4  MLW(ro) - Maximum Link Width: Indicates the maximum number of lanes supported by the device. This field is hardwired based on the setting of the LANE_COUNT_IN strap input.
    Bits:  3:0  MLS(ro) - Maximum Link Speed: Indicates the maximum speed supported by the link. (2.5 GT/s, 5 GT/s, 8 GT/s per lane). This field is hardwired to 0001 (2.5GT/s) when the strap input PCIE_GENERATION_SEL is set to 0, to 0010 (5 GT/s) when the strap is set to 1, and to 0011 (8 GT/s) when the strap input is set to 10.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_I_LINK_CAP     0x000000cc
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_PN(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_PN_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_R5 BIT(23)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_AOC BIT(22)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_LBNC BIT(21)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_DLLARC BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_SDERC BIT(19)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_CPM BIT(18)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_L1EL(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_L1EL_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_L0SEL(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_L0SEL_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_ASPM(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_ASPM_of(_x) (((_x) >> 10) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_MLW(_x) (((_x) & 0x3f) << 4)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_MLW_of(_x) (((_x) >> 4) & 0x3f)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_MLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_LINK_CAP_MLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_cap_2 -
    Bits: 31:24 R14(ro) - Reserved: Reserved
    Bits: 23:22 MEEP(ro) - Max End-End TLP Prefixes: Indicates the maximum number of End-End TLP Prefixes supported by the Function. The supported values are: 01b 1 End-End TLP Prefix 10b 2 End-End TLP Prefixes
    Bits: 21    EEPS(ro) - End-End TLP Prefix Supported: Indicates whether the Function supports End-End TLP Prefixes. A 1 in this field indicates that the Function supports receiving TLPs containing End-End TLP Prefixes.
    Bits: 20    EXFS(ro) - Extended Format Field Supported: Indicates that the Function supports the 3-bit definition of the Fmt field in the TLP header. This bit is hardwired to 1 for all Physical Functions.
    Bits: 19:18 OPFFS(ro) - OBFF Supported: A 1 in this bit position indicates that the Function supports the Optimized Buffer Flush/Fill (OBFF) capability using message signaling.
    Bits: 15:14 R13(ro) - Reserved: Reserved
    Bits: 13:12 TCS(ro) - TPH Completer Supported: These bits, when set, indicate that the Function is capable of serving as a completer for requests with Transaction Processing Hints (TPH). It can be turned off for all Physical Functions by writing into PF 0. Defined Encodings are: 00b TPH and Extended TPH Completer not supported. 01b TPH Completer supported Extended TPH Completer not supported. 10b Reserved. 11b Both TPH and Extended TPH Completer supported.
    Bits: 11    LMS(ro) - LTR Mechanism Supported: A 1 in this bit position indicates that the Function supports the Latency Tolerance Reporting (LTR) Capability. This bit is set to 1 by default, but can be turned off for all Physical Functions by writing into PF 0.
    Bits: 10    R12(ro) - Reserved: Reserved
    Bits:  9    BAOCS128(ro) - 128-Bit CAS Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for the Compare-and- Swap (CAS) Atomic Operation with 128-bit operands. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  8    BAOCS64(ro) - 64-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 64-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  7    BAOCS32(ro) - 32-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 32-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  6    OPRS(ro) - OP routing supported: Atomic OP routing supported.
    Bits:  5    AFS(ro) - ARI forwarding support: ARI forwarding supported. This field is hard coded to zero
    Bits:  4    CTDS(ro) - Completion Timeout Disable Supported: A 1 in this field indicates that the associated Function supports the capability to turn off its Completion timeout. This bit is set to 1 by default, but can be re-written independently for each Function from the local management bus.
    Bits:  3:0  CTR(ro) - Completion Timeout Ranges: Specifies the Completion Timeout values supported by the device. This field is set by default to 0010 (10 ms - 250 ms). The actual timeout values are in two programmable local management registers, which allow the timeout settings of the two sub-ranges within Range B to be programmed independently.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_I_PCIE_DEV_CAP_2 0x000000e4
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R14(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R14_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_MEEP(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_MEEP_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_EEPS BIT(21)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_EXFS BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPFFS(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPFFS_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R13(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R13_of(_x) (((_x) >> 14) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_TCS(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_TCS_of(_x) (((_x) >> 12) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_LMS BIT(11)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_R12 BIT(10)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS128 BIT(9)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS64 BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_BAOCS32 BIT(7)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_OPRS BIT(6)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_AFS BIT(5)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTDS BIT(4)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_I_VF_PCIE_CAP_STRUCT_I_PCIE_DEV_CAP_2_CTR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field reflects the setting of the corresponding field in the AER Enhanced Capability Header Register of PF 0.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express AER Extended Capability Structure (0001 hex).
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_AER_ENHANCED_CAP_HDR 0x00000100
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_AER_ENHANCED_CAP_HDR_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_status -
    Bits: 31:23 R3(ro) - Reserved: Reserved
    Bits: 22    Uncorr_Int_Err_Status(ro) - Uncorrectable Internal Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 21    R2(ro) - Reserved: Reserved
    Bits: 20    URES(w1c) - Unsupported Request Error Status: This bit is set when the core has received a request from the link that it does not support. This error is not Function-specific. This error is considered non-fatal by default. In the special case described in Sections 6.2.3.2.4.1 of the PCI Express Specifications, the error is reported by sending an ERR_COR message. In all other cases, the error is reported by sending an ERR_NONFATAL message. The header of the received request that caused the error is logged in the Shared VF Header Log Registers. STICKY.
    Bits: 19    ECRC_Err_Status(ro) - ECRC Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 18    Malformed_TLP_Status(ro) - Malformed TLP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 17    Rcvr_Overflow_Status(ro) - Receiver Overflow Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 16    UCS(w1c) - Unexpected Completion Status: This bit is set when the core has received an unexpected Completion packet from the link. This error is not Function-specific. STICKY.
    Bits: 15    CAS(w1c) - Completer Abort Status: This bit is set when the core has returned the Completer Abort (CA) status to a request received from the link. This error is Function-specific. The header of the received request that caused the error is logged in the Shared VF Header Log Registers. STICKY.
    Bits: 14    CTS(w1c) - Completion Timeout Status: This bit is set when the completion timer associated with an outstanding request times out. This error is Function-specific. This error is considered non-fatal by default. STICKY.
    Bits: 13    FCPES(ro) - Flow Control Protocol Error Status: This bit is is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 12    PTS(w1c) - Poisoned TLP Status: This bit is set when the core receives a poisoned TLP from the link, targeted at this VF. This error is Function-specific. This error is considered non-fatal by default. The error is reported by sending an ERR_NONFATAL message. The header of the received TLP with error is logged in the Shared VF Header Log Registers associated with the VF. STICKY.
    Bits: 11:5  R1(ro) - Reserved: Reserved
    Bits:  4    DLPER(ro) - Data Link Protocol Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_UNCORR_ERR_STATUS 0x00000104
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R3(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R3_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_UNCORR_INT_ERR_STATUS BIT(22)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R2 BIT(21)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_URES BIT(20)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_ECRC_ERR_STATUS BIT(19)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_MALFORMED_TLP_STATUS BIT(18)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_RCVR_OVERFLOW_STATUS BIT(17)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_UCS BIT(16)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_CAS BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_CTS BIT(14)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_FCPES BIT(13)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_PTS BIT(12)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R1(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R1_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_DLPER BIT(4)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_STATUS_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_mask -
    Bits: 31:0  R4(ro) - Reserved:
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_UNCORR_ERR_MASK 0x00000108
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R4(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_MASK_R4_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_severity -
    Bits: 31:0  R8(ro) - Reserved:
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_UNCORR_ERR_SEVERITY 0x0000010c
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R8(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_UNCORR_ERR_SEVERITY_R8_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_corr_err_status -
    Bits: 31:16 R14(ro) - Reserved: Reserved
    Bits: 15    HLOS(w1c) - Header Log Overflow Status: This bit is set on a Header Log Register overflow, that is, when the header could not be logged in the Header Log Register because it is occupied by a previous header. As per SR-IOV specification, this bit is hardwired to 0 since the Header Log is Shared among VFs.
    Bits: 14    CIES(ro) - Corrected Internal Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 13    ANFES(w1c) - Advisory Non-Fatal Error Status: This bit is set when an uncorrectable error occurs, which is determined to belong to one of the special cases described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications. This causes the core to generate an ERR_COR message in place of an ERR_NONFATAL message. STICKY.
    Bits: 12    RTTS(ro) - Replay Timer Timeout Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 11:9  R13(ro) - Reserved: Reserved
    Bits:  8    RNRS(ro) - Replay Number Rollover Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  7    BDS(ro) - Bad DLLP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  6    BTPS(ro) - Bad TP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  5:1  R12(ro) - Reserved: Reserved
    Bits:  0    RES(ro) - Receiver Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_CORR_ERR_STATUS 0x00000110
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R14(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R14_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_HLOS BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_CIES BIT(14)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_ANFES BIT(13)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RTTS BIT(12)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R13(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R13_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RNRS BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_BDS BIT(7)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_BTPS BIT(6)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R12(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_R12_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_STATUS_RES BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_corr_err_mask -
    Bits: 31:16 R17(ro) - Reserved:
    Bits: 15    HLOM(rw) - Header Log Overflow Mask: This bit, when set, masks the generation of error messages in response to a Header Log register overflow. STICKY. Header logs are shared across Vfs hence this field is reserved. This field is reserved since Header log sharing is selected for this configuration.
    Bits: 14    CIEM(ro) - Corrected Internal Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 13    ANFEM(ro) - Advisory Non-Fatal Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 12    RTTM(ro) - Replay Timer Timeout Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 11:9  R16(ro) - Reserved: Reserved
    Bits:  8    RNRM(ro) - Replay Number Rollover Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  7    BDM(ro) - Bad DLLP Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  6    BTM(ro) - Bad TLP Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  5:1  R15(ro) - Reserved: Reserved
    Bits:  0    REM(ro) - Receiver Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_CORR_ERR_MASK 0x00000114
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R17(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R17_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_HLOM BIT(15)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_CIEM BIT(14)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_ANFEM BIT(13)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_RTTM BIT(12)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R16(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R16_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_RNRM BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_BDM BIT(7)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_BTM BIT(6)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R15(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_R15_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_CORR_ERR_MASK_REM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_advcd_err_cap_ctrl -
    Bits: 31:11 R18(ro) - Reserved: Reserved
    Bits: 10    MHRE(ro) - Multiple Header Recording Enable: Setting this bit enables the Function to log multiple error headers in its Header Log Registers. It is hardwired to 0
    Bits:  9    MHRC(ro) - Multiple Header Recording Capable: This bit is set when the Function has the capability to log more than one error header in its Header Log Registers. It is hardwired to 0.
    Bits:  8    ECC(ro) - Enable ECRC Check: Setting this bit enables ECRC checking on the receive side of the core. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  7    ECCAP(ro) - ECRC Check Capability: This read-only bit indicates to the software that the device is capable of checking ECRC in packets received from the link. This bit is hardwired to 0. This setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  6    EEG(ro) - Enable ECRC Generation: Enables the ECRC generation on the transmit side of the core. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  5    EGC(ro) - ECRC Generation Capability: This read-only bit indicates to the software that the device is capable of generating ECRC in packets transmitted on the link. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  4:0  FER(ro) - First Error Pointer: This is a 5-bit pointer to the bit position in the Uncorrectable Error Status Register corresponding to the error that was detected first. When there are multiple bits set in the Uncorrectable Error Status Register, this field informs the software which error was observed first. To prevent the field from being overwritten before software was able to read it, this field is not updated while the status bit pointed by it in the Uncorrectable Error Status Register remains set. After the software clears this status bit, a subsequent error condition that sets any bit in the Uncorrectable Error Status Register will update the First Error Pointer. Any uncorrectable error type, including the special cases where the error is reported using an ERR_COR message, will set the First Error Pointer (assuming the software has reset the error pointed by it in the Uncorrectable Error Status Register). STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_ADVCD_ERR_CAP_CTRL 0x00000118
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_R18(_x) (((_x) & 0x1fffff) << 11)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_R18_of(_x) (((_x) >> 11) & 0x1fffff)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_MHRE BIT(10)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_MHRC BIT(9)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_ECC BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_ECCAP BIT(7)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_EEG BIT(6)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_EGC BIT(5)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_FER(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_ADVCD_ERR_CAP_CTRL_FER_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_0 -
    Bits: 31:0  HD0(ro) - Header DWORD 0: First DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_HDR_LOG_0     0x0000011c
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_0_HD0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_0_HD0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_1 -
    Bits: 31:0  HD1(ro) - Header DWORD 1: Second DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_HDR_LOG_1     0x00000120
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_1_HD1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_1_HD1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_2 -
    Bits: 31:0  HD2(ro) - Header DWORD 2: Third DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_HDR_LOG_2     0x00000124
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_2_HD2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_2_HD2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_3 -
    Bits: 31:0  HD3(ro) - Header DWORD 3: Fourth DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_I_HDR_LOG_3     0x00000128
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_3_HD3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_AER_CAP_STRUCT_I_HDR_LOG_3_HD3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is taken from the setting of the corresponding field in the ARI Extended Capability Header Register of PF 0.
    Bits: 15:0  PCCID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the ARI Extended Capability (000E hex).
*/
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_I_ARI_EXT_CAP_HDR 0x00000140
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_PCCID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_EXT_CAP_HDR_PCCID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_ARI_cap_struct_i_ARI_cap_and_ctrl -
    Bits: 31:0  R13(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_I_ARI_CAP_AND_CTRL 0x00000144
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_R13(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_ARI_CAP_STRUCT_I_ARI_CAP_AND_CTRL_R13_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified for all VFs by writing into this register field of Physical Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the TPH Requester Capability.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_REQ_EXT_CAP_HEADER_REG 0x00000274
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_EXT_CAP_HEADER_REG_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_cap_reg -
    Bits: 31:27 R2(ro) - Reserved: Reserved
    Bits: 26:16 STTS(rw) - ST Table Size: Specifies the number of entries in the Steering Tag Table (0 = 1 entry, 1 = 2 entries, and so on). Max limit is 64 entries when the ST Table is located in the TPH Requester Capability Structure, and 2048 entries when located in the MSI-X table. Each entry is 16 bits long. This field can be modified from the local management bus.
    Bits: 15:11 R1(ro) - Reserved: Reserved
    Bits: 10:9  STTL(rw) - ST Table Location: The setting of this field indicates if a Steering Tag Table is implemented for this Function, and its location if present. (00 = ST Table not present, 01 = ST Table in the TPH Requester Capability Structure, 10 = ST values stored in the MSI-X Table in client RAM, 11 = reserved.). This field can be modified from the local management bus.
    Bits:  8    ERS(ro) - Extended TPH Requester Supported: When set to 1, indicates that the Function is capable of generating requests with a TPH TLP Prefix.
    Bits:  7:3  R0(ro) - Reserved: Reserved
    Bits:  2    DSMS(rw) - Device-Specific Mode Supported: A setting of 1 indicates that the Function supports the Device- Specific Mode for TPH Steering Tag generation. In this mode, the Steering Tags are supplied by the client for each request through the HAL master interface. The client typically chooses the Steering Tag values from the ST Table, but is not required to do so. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  1    IVMS(rw) - Interrupt Vector Mode Supported: A setting of 1 indicates that the Function supports the Interrupt Vector Mode for TPH Steering Tag generation. In the Interrupt Vector Mode, Steering Tags are attached to MSI/MSI-X interrupt requests. The Steering Tag for each interrupt request is selected by the MSI/MSI-X interrupt vector number. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    NSTM(ro) - No ST Mode Supported: When set to 1, indicates that this Function supports the 'No ST Mode' for the generation of TPH Steering Tags. In the No ST Mode, the device must use a Steering Tag value of 0 for all requests. This bit is hardwired to 1, as all TPH Requesters are required to support the No ST Mode of operation.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_REQ_CAP_REG 0x00000278
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R2(_x) (((_x) & 0x1f) << 27)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R2_of(_x) (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R1(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R1_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STTL(_x) (((_x) & 0x3) << 9)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_STTL_of(_x) (((_x) >> 9) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_ERS BIT(8)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R0(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_R0_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_DSMS BIT(2)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_IVMS BIT(1)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CAP_REG_NSTM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg -
    Bits: 31:10 R10(ro) - Reserved: Reserved
    Bits:  9:8  TRE(rw) - TPH Requester Enable: When set , the Function is allowed to generate requests with Transaction Processing Hints. Defined Encodings are: 00b Function operating as a Requester is not permitted to issue Requests with TPH or Extended TPH. 01b Function operating as a Requester is permitted to issue Requests with TPH and is not permitted to issue Requests with Extended TPH. 10b Reserved. 11b Function operating as a Requester is permitted to issue Requests with TPH and Extended TPH.
    Bits:  2:0  STM(rw) - ST Mode: This field selects the ST mode (000 = No Steering Tag Mode, 001 = Interrupt Vector Mode, 010 = Device-Specific Mode, other values are reserved). The VF_TPH_ST_MODE output of the core reflects the setting of this register field (bits 3:0 for VF 0 and so on). This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_REQ_CTRL_REG 0x0000027c
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_R10(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_R10_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_TRE(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_TRE_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_STM(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_I_TPH_REQ_CTRL_REG_STM_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_tab_0 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_1 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_2 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_3 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_4 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_5 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_6 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_7 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_8 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_9 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_10 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_11 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_12 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_13 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_14 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_15 -
    Bits: 31:24 ST1U(ro) - ST 1 Upper: This field is used for the upper 8 bits of the second Steering Tag when Extended TPH Requester support is enabled.
    Bits: 23:16 ST1L(rw) - ST 1 Lower: Lower 8 bits of the second Steering Tag. This is the 8-bit Steering Tag sent out in requests.
    Bits: 15:8  ST0U(ro) - ST 0 Upper: This field is used for the upper 8 bits of the first Steering Tag when Extended TPH Requester support is enabled.
    Bits:  7:0  ST0L(rw) - ST 0 Lower: Lower 8 bits of the first Steering Tag. This is the 8-bit Steering Tag sent out in requests.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_0     0x00000280
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_1     0x00000284
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_2     0x00000288
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_3     0x0000028c
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_4     0x00000290
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_5     0x00000294
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_6     0x00000298
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_7     0x0000029c
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_8     0x000002a0
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_9     0x000002a4
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_10    0x000002a8
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_11    0x000002ac
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_12    0x000002b0
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_13    0x000002b4
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_14    0x000002b8
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_I_TPH_TAB_15    0x000002bc
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST1U(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST1U_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST1L(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST1L_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST0U(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST0U_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST0L(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_I_VF_TPH_CAP_STRUCT_TPH_ST_TABLE_VF_CL_ST0L_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig0 - Configures operation mode for PCIe Control Island component
    Bits: 31    PCIeConfigWren(rw) - Software must set this bit when writing to this register and before writing to the PCIeCtrlConfig1 and PCIeCtrlConfig3 registers. After the PCIe parameters have been written softare should clear this bit to protect the fields from being accidentally overwritten.
    Bits: 11:8  PfBusMasterEnable(ro) - Physical Function status indicates can issue Master requests
    Bits:  4    PcieSerdesClkMuxSel(rw) - Selects which lane to source PIPE clock from
    Bits:  3:2  PCIeLanes(rw) - Status of the number of active lanes.
    Bits:  1:0  GenEnable(rw) - Status of PCIe generation the Controller Core is configured
*/
#define NFP3800_PCIEX_CTRLCFG_CFG0                           0x00000000
#define   NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_CONFIG_WREN        BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_BUS_MASTER_EN(_x)       (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_BUS_MASTER_EN_of(_x)    (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_SERDES_MUX_SEL     BIT(4)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_SERDES_MUX_SEL_SEL_LANE0_CLK (0 << 4)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_SERDES_MUX_SEL_SEL_LANE7_CLK BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES(_x)          (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES_of(_x)       (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES_X1         (0)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES_X2         (1)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES_X4         (2)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_PCIE_LANES_X8         (3)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_GEN_ENABLE_STAT(_x)     (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_CFG0_GEN_ENABLE_STAT_of(_x)  (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_GEN_ENABLE_STAT_GEN1  (0)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_GEN_ENABLE_STAT_GEN2  (1)
#define     NFP3800_PCIEX_CTRLCFG_CFG0_GEN_ENABLE_STAT_GEN3  (2)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig1 - Configures operation mode for PCIe Control Island component
    Bits: 27:21 PcieCtrlmaxEvalIteration(rw) - MAX_EVAL_ITERATION input to Pcie Controller Core.
    Bits:  9    PcieCtrlClientReqExitL1(rw) - LINK_CLIENT_REQ_EXIT_L1 input to Pcie Controller Core.
    Bits:  7    PcieCtrlRawResetDropDisable(rw) - Set this bit to stop PCIE from dropping master requests and target completions if the raw reset is low but pcie reset disable is stopping from resetting.
    Bits:  6    PcieCtrlClientReqExitL2(rw) - LINK_CLIENT_REQ_EXIT_L2 input to Pcie Controller Core.
    Bits:  3    MgmtTyp1RegAccess(rw) - MGMT_TYP1_REG_ACCESS input to Pcie Controller Core.
    Bits:  2    ReqPmTransitionL23Ready(rw) - Control input to Pcie Controller Core.
    Bits:  1    NonPostedOverrideDisable(rw) - Setting this bit allows HAL Target posted requests to postpone and pass existing received non_posted requests (allowed per pcie spec). Default 0 allows HAL Target to fairly mix posted and non-posted requests.
    Bits:  0    ConfigEnable(rw) - Tied to Pcie Controller CONFIG_ENABLE input. When this bit is a 0 in the EP mode, the core will generate a CRS Completion in response to Configuration Requests. In systems where the core configuration registers are loaded from RAM on power-up, this prevents the core from responding to Configuration Requests before all the registers are loaded. When this bit is a 1 in the EP mode, the core will accept Configuration Requests.
*/
#define NFP3800_PCIEX_CTRLCFG_CFG1                           0x00000004
#define   NFP3800_PCIEX_CTRLCFG_CFG1_PCIE_CTRL_MAX_EVAL_ITERATION(_x) (((_x) & 0x7f) << 21)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_PCIE_CTRL_MAX_EVAL_ITERATION_of(_x) (((_x) >> 21) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_PCIE_CTRL_CLIENT_REQ_EXIT_L1 BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_PCIE_CTRL_RAW_RESET_DROP_DISABLE BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_PCIE_CTRL_CLIENT_REQ_EXIT_L2 BIT(6)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_MGMT_TYP1_REG_ACCESS    BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_REQ_PM_TRANSITION_L23_READY BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_NON_POSTED_OVERRIDE_DISABLE BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_CFG1_CONFIG_ENABLE           BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig2 - Configures operation mode for PCIe Control Island component
    Bits: 25:10 PCIeCntrlrDebugData(ro) - Pcie Controller Core status of 16-bit output data from the debug bus.
    Bits:  9    HotResetStat(ro) - Reflects current state of the Hot Reset Status from the PCIe Controller. If set a hot reset was received from the link in the Endpoint mode.
    Bits:  8    HotResetInit(rw) - SW sets this bit when Pcie Controller Core needs to initiate a Hot Reset sequence on the PCIe link when in RC mode.
    Bits:  7    LinkDownResetOut(ro) - Pcie Controller Core status asserted when its LTSSM detects a link-down event (when the LINK_UP state variable goes to 0).
    Bits:  6    PhyInterrupt(rw1c) - PCIe Core output used in RC mode to signal a link training related event has occurred
    Bits:  5    LocalInterrupt(rw1c) - Pcie Controller Core status. Used to signal an error or abnormal condition to the local processor. The interrupting condition can be obtained by reading the Local Error Status Register.
    Bits:  4    FatalError(rw1c) - Pcie core detected a fatal error.
    Bits:  3    NonFatalError(rw1c) - Pcie core detected a non-fatal error.
    Bits:  2    CorrectableError(rw1c) - Pcie core detected a correctable error.
    Bits:  1    CorrectableErrorIn(wo) - Software writes a 1 to this bit when an correctable error has been detected. A correctable error can be a correctable error event from the Shared SRAM. The error is reported by the core through the PCI Express Advanced Error Reporting mechanism.
    Bits:  0    UncorrectableErrorIn(wo) - Software writes a 1 to this bit when an uncorrectable error has been detected. An uncorrectable error can be an uncorrectable error event from the Shared SRAM or a DMA Descriptor Rd Parity error. The error is reported by the core through the PCI Express Advanced Error Reporting mechanism.
*/
#define NFP3800_PCIEX_CTRLCFG_CFG2                           0x00000008
#define   NFP3800_PCIEX_CTRLCFG_CFG2_PCIE_CNTRLR_DEBUG_DATA(_x) (((_x) & 0xffff) << 10)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_PCIE_CNTRLR_DEBUG_DATA_of(_x) (((_x) >> 10) & 0xffff)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_HOT_RESET_STAT          BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_HOT_RESET_INIT          BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_LINK_DOWN_RESET_OUT     BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_PHY_INTERRUPT           BIT(6)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_LOCAL_INTERRUPT         BIT(5)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_FATAL_ERROR             BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_NON_FATAL_ERROR         BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_CORRECTABLE_ERROR       BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_CORRECTABLE_ERROR_IN    BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_CFG2_UNCORRECTABLE_ERROR_IN  BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig3 - Configures operation mode for PCIe Control Island component
    Bits: 12:2  PresetSweepMask(rw) - Controls masking off evalutating known bad TX Presets during link equalization
    Bits:  1    BypassRemoteTxEq(rw) - Controls bypassing the evaluation of the remote PHY Tx during Link Equalization
    Bits:  0    BypassPhase23(rw) - When in RC mode, controls Phase 2 and phase 3 of Link Equalization
*/
#define NFP3800_PCIEX_CTRLCFG_CFG3                           0x0000000c
#define   NFP3800_PCIEX_CTRLCFG_CFG3_PRESET_SWEEP_MASK(_x)   (((_x) & 0x7ff) << 2)
#define   NFP3800_PCIEX_CTRLCFG_CFG3_PRESET_SWEEP_MASK_of(_x) (((_x) >> 2) & 0x7ff)
#define   NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_REMOTE_TX_EQ     BIT(1)
#define     NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_REMOTE_TX_EQ_NOBYPASS (0 << 1)
#define     NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_REMOTE_TX_EQ_BYPASS BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_PHASE23          BIT(0)
#define     NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_PHASE23_NOBYPASS (0 << 0)
#define     NFP3800_PCIEX_CTRLCFG_CFG3_BYPASS_PHASE23_BYPASS BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlrStat - PCIe Controller Status
    Bits: 27:20 RcbStatus(ro) - Indicates Pcie Controller Core status of Read Completion Boundary setting: 0 = 64B, 1 = 128B
    Bits: 19:18 NegotiatedSpeed(ro) - Reflects Pcie Controller Core status of current operating speed of the link (00 = 2.5 GT/s, 01 = 5 GT/s, 10 = 8 GT/s). Valid when LINK_STATUS = 10 or 11.
    Bits: 17:15 MaxReadReqSize(ro) - Indicates Pcie Controller Core status of the limit of the size of outgoing read requests. The 3-bit codes are the same as those defined in PCIe Specifications: 000 = 128 bytes, 001 = 256 bytes, 010 = 512 bytes, 011 = 1024 bytes, 100 = 2048 bytes 101 = 4096 bytes.
    Bits: 14:12 MaxPayloadSize(ro) - Reflects Pcie Controller Core status of the limit of the size of Outgoing Completion payloads. The 3-bit codes are the same as those defined in PCIe Specifications: 000 = 128 bytes, 001 = 256 bytes, 010 = 512 bytes.
    Bits: 11:8  LinkPowerState(ro) - Reflects Pcie Controller Core power state of the PCIe link. 0001 = L0, 0010 = L0s, 0100 = L1, 1000 = L2.
    Bits:  7:6  LinkStatus(ro) - Indicates Pcie Controller Core status of the PCI Express link. 00 = No receivers detected, 01 = Link training in progress, 10 = Link up , DL initialization in progress, 11 = Link up, DL initialization completed..
    Bits:  5:0  LtssmState(ro) - Reflects Pcie Controller Core state of the Link Training and Status State Machine.
*/
#define NFP3800_PCIEX_CTRLCFG_STAT                           0x00000010
#define   NFP3800_PCIEX_CTRLCFG_STAT_RCB_STATUS(_x)          (((_x) & 0xff) << 20)
#define   NFP3800_PCIEX_CTRLCFG_STAT_RCB_STATUS_of(_x)       (((_x) >> 20) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_STAT_NEGOTIATED_SPEED(_x)    (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_CTRLCFG_STAT_NEGOTIATED_SPEED_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_STAT_MAX_READ_REQ_SIZE(_x)   (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_STAT_MAX_READ_REQ_SIZE_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_STAT_MAX_PAYLOAD_SIZE(_x)    (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_STAT_MAX_PAYLOAD_SIZE_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LINK_POWER_STATE(_x)    (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LINK_POWER_STATE_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LINK_STATUS(_x)         (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LINK_STATUS_of(_x)      (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LTSSM_STATE(_x)         (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_STAT_LTSSM_STATE_of(_x)      (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIePhysFuncStat - Physical function status
    Bits: 15:0  FunctionStatus(ro) - Indicates Pcie Controller Core status of the states of the Command Register bits in the PCI configuration space of each Function. There are 4-bits per physical function where bits [3:0] are PF0s functional status and bits [15:12] are PF3s functional status. These outputs are used to enable requests and completions from the host logic. The assignment of bits is as follows: Bit 0: Function 0 IO Space Enable, Bit 1: Function 0 Memory Space Enable, Bit 2: Function 0 Bus Master Enable, Bit 3: Function 0 INTx Disable.
*/
#define NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_STAT                 0x00000014
#define   NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_STAT_FUNCTION_STATUS(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_STAT_FUNCTION_STATUS_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIePhysFuncPwrState - Physical function power state
    Bits: 11:0  FunctionPowerState(ro) - Provides Pcie Controller Core status of the current power state of the Physical Functions. There are 3-bits per physical function where bits [2:0] are PF0s function power state and bits [11:9] are PF7s function power state. The possible power states are: 000: D0_uninitialized, 001: D0_active, 010: D1, 100: D3_hot.
*/
#define NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_PWR_STATE            0x00000018
#define   NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_PWR_STATE_FUNCTION_POWER_STATE(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PHYS_FUNC_PWR_STATE_FUNCTION_POWER_STATE_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: PCIeCtrlSpare0 - Spare
  Register: PCIeCtrlSpare1[5] - Spare
  Register: PCIeCtrlSpare2[23] - Spare
  Register: PCIeCtrlSpare3[23] - Spare
  Register: PCIeCtrlSpare4[5] - Spare
  Register: PCIeCtrlSpare5[4] - Spare register address, no hw implemented
  Register: PCIeCtrlSpare6 - Spare
  Register: PCIeCtrlSpare7 - Spare
  Register: PCIeCtrlSpare8[3] - Spare
  Register: PcieCtrlVscMap_PCIeCtrlVscMapSpare - Spare
  Register: PcieCtrlVscMap_PCIeCtrlVscSpare[21] - Spare
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE0               0x0000001c
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE1(_x)           (0x0000006c + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE2(_x)           (0x000000a0 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE3(_x)           (0x00000120 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE4(_x)           (0x000001bc + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE5(_x)           (0x00000210 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE6               0x00000228
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE7               0x0000022c
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SPARE8(_x)           (0x00000314 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_VSC_MAP_SPARE 0x00000334
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_VSC_SPARE(_x) (0x0000033c + (0x4 * ((_x) & 0x1f)))
/*----------------------------------------------------------------
  Register: PCIeVf0Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (27-0)
    Bits: 31:4  VFEnableStat(ro) - Virtual Function enable status for VF 27-0.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF0_ENABLE                0x00000020
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_ENABLE_VF_ENABLE_STAT(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_ENABLE_VF_ENABLE_STAT_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (59-28)
    Bits: 31:0  VFEnableStat(ro) - Virtual Function enable status for VF (59-28).
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF1_ENABLE                0x00000024
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_ENABLE_VF_ENABLE_STAT(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_ENABLE_VF_ENABLE_STAT_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (63-60)
    Bits:  3:0  VFEnableStat(ro) - Virtual Function enable status for VF (63-60).
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF2_ENABLE                0x00000028
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_ENABLE_VF_ENABLE_STAT(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_ENABLE_VF_ENABLE_STAT_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeIntSidebandSignals0 - Interrupt sideband status signals 0-31
  Register: PCIeIntSidebandSignals1 - Interrupt sideband status signals 32-63
    Bits: 31:0  PCIE_INBT_SIDEBAND_SIGNALS(rw1c) - PCIe Interrupt sideband signals
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_INT_SIDEBAND_SIGNALS0     0x00000030
#define NFP3800_PCIEX_CTRLCFG_PCIE_INT_SIDEBAND_SIGNALS1     0x00000034
#define   NFP3800_PCIEX_CTRLCFG_PCIEINTSIDEBANDSIGNALS_PCI_E__INB_T__SIDEBAN_D__SIGNALS(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIEINTSIDEBANDSIGNALS_PCI_E__INB_T__SIDEBAN_D__SIGNALS_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf0BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (27-0)
    Bits: 31:4  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 27-0.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF0_BUS_MSTR_ENABLE       0x00000040
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (59-28)
    Bits: 31:0  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 59-28.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF1_BUS_MSTR_ENABLE       0x00000044
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (63-60)
    Bits:  3:0  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 63-60.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF2_BUS_MSTR_ENABLE       0x00000048
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_BUS_MSTR_ENABLE_VF_BUS_MSTR_ENABLE_STAT_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlr0InProg - Virtual/Physicaa Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. PF# (0-3) VF# (0-27)
    Bits: 31:4  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (27-0)
    Bits:  3:0  FlrInProg(ro) - Physical Function, Function Level Reset in progress status
*/
#define NFP3800_PCIEX_CTRLCFG_FLR0PROG                       0x00000060
#define   NFP3800_PCIEX_CTRLCFG_FLR0PROG_VF_FLR_IN_PROG(_x)  (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_FLR0PROG_VF_FLR_IN_PROG_of(_x) (((_x) >> 4) & 0xfffffff)
#define   NFP3800_PCIEX_CTRLCFG_FLR0PROG_FLR_IN_PROG(_x)     (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_FLR0PROG_FLR_IN_PROG_of(_x)  (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlr1InProg - Virtual Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. VF# (59-28)
    Bits: 31:0  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (59-28)
*/
#define NFP3800_PCIEX_CTRLCFG_FLR1PROG                       0x00000064
#define   NFP3800_PCIEX_CTRLCFG_FLR1PROG_VF_FLR_IN_PROG(_x)  (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_FLR1PROG_VF_FLR_IN_PROG_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeFlr2InProg - Virtual Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. VF# (63-60)
    Bits:  3:0  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (63-60).
*/
#define NFP3800_PCIEX_CTRLCFG_FLR2PROG                       0x00000068
#define   NFP3800_PCIEX_CTRLCFG_FLR2PROG_VF_FLR_IN_PROG(_x)  (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_FLR2PROG_VF_FLR_IN_PROG_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeVfPwrState[8] - 3 bits per VF, provide current power state of the Virtual Function, 000: D0_uninitialized, 001: D0_active, 010: D1, 100: D3_hot. VF# (7-0)*{{X+1}}
    Bits: 23:21 PCIeVfPwrStateN7(ro) - VFn7 Power State
    Bits: 20:18 PCIeVfPwrStateN6(ro) - VFn6 Power State
    Bits: 17:15 PCIeVfPwrStateN5(ro) - VFn5 Power State
    Bits: 14:12 PCIeVfPwrStateN4(ro) - VFn4 Power State
    Bits: 11:9  PCIeVfPwrState_N3(ro) - VFn3 Power State
    Bits:  8:6  PCIeVfPwrStateN2(ro) - VFn2 Power State
    Bits:  5:3  PCIeVfPwrStateN1(ro) - VFn1 Power State
    Bits:  2:0  PCIeVfPwrStateN(ro) - VFn Power State
*/
#define NFP3800_PCIEX_CTRLCFG_VFPWR(_x)                      (0x00000080 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N7(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N7_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N6(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N6_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N5(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N5_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N4(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N4_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N3(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N3_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N2(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N2_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N1(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N1_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_VFPWR_PCIE_VF_PWR_STATE_N_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieHalPme - Indicates the activity in HAL switch, a value of zero indicates everything is idle.
    Bits:  2    PcieHalmComplInletFifoValid(rc) - pcie_halm_compl_inlet_fifo_valid
    Bits:  1    PcieHalmBurstComplFifoValid(rc) - pcie_halm_burst_compl_fifo_valid
    Bits:  0    PcieHalmOutletFifoValid(rc) - pcie_halm_outlet_fifo_valid
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_HAL_PME                   0x000000fc
#define   NFP3800_PCIEX_CTRLCFG_PCIE_HAL_PME_PCIE_HALM_COMPL_INLET_FIFO_VALID BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_HAL_PME_PCIE_HALM_BURST_COMPL_FIFO_VALID BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_HAL_PME_PCIE_HALM_OUTLET_FIFO_VALID BIT(0)
/*----------------------------------------------------------------
  Register: PCIeVfTphState[8] - TPH ST mode 3-bits per VF. VF# (7-0)*{{X+1}}
    Bits: 23:21 PCIeVfTphStModeN7(ro) - VFn7 TPH ST Mode
    Bits: 20:18 PCIeVfTphStModeN6(ro) - VFn6 TPH ST Mode
    Bits: 17:15 PCIeVfTphStModeN5(ro) - VFn5 TPH ST Mode
    Bits: 14:12 PCIeVfTphStModeN4(ro) - VFn4 TPH ST Mode
    Bits: 11:9  PCIeVfTphStModeN3(ro) - VFn3 TPH ST Mode
    Bits:  8:6  PCIeVfTphStModeN2(ro) - VFn2 TPH ST Mode
    Bits:  5:3  PCIeVfTphStModeN1(ro) - VFn1 TPH ST Mode
    Bits:  2:0  PCIeVfTphStModeN(ro) - VFn TPH ST Mode
*/
#define NFP3800_PCIEX_CTRLCFG_VFTPH(_x)                      (0x00000100 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N7(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N7_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N6(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N6_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N5(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N5_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N4(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N4_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N3(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N3_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N2(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N2_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N1(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N1_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_VFTPH_PCIE_VF_TPH_ST_MODE_N_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieIntMsiMsgAborted - Reporting Requester ID and Vector number of a MSI msg aborted occurred.
    Bits: 14    PcieMsiMsgAbortedMask(rw) - When set it indicates a MSI message aborted will be masked
    Bits: 13    PcieMsiMsgAborted(w1c) - When set it indicates a MSI message aborted occurred. When cleared the Vector number and Requester ID fields are invalid
    Bits: 12:5  PcieMsiMsgAbortReqId(ro) - Requester id of aborted MSI message
    Bits:  4:0  PcieMsiMsgAbortVector(ro) - Vector number of aborted MSI message.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT         0x0000017c
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_MSG_ABORTED_MASK BIT(14)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_MSG_ABORTED BIT(13)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_ABORT_REQ_ID(_x) (((_x) & 0xff) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_ABORT_REQ_ID_of(_x) (((_x) >> 5) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_ABORT_VECTOR(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_INT_MSI_MSG_ABORT_PCIE_MSI_ABORT_VECTOR_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeStateChangeStat - Contains the state change interrupt and status
    Bits: 21    FuncStatusChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 20    PwrStateChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 19    VfBusMstrEnStateChangeIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 18    VfEnableStateChangeIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 17    LinkPwrStateChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 16    LinkStatusChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 15:8  CfgFuncNum(ro) - Contains the CONFIG_FUNCTION_NUM associated with the POWER_STATE_CHANGE_INTERRUPT.
    Bits:  5    FuncStatusChgInt(rw1c) - Interrupt status bit that indicates there was a change to the FUNCTION_STATUS bits from the PCIe core
    Bits:  4    PwrStateChgInt(rw1c) - Interrupt status bit that indicates there was a change to the FUNCTION_POWER_STATE or VF_POWER_STATE status from the PCIe core. Writing a 1 to this register asserts the POWER_STATE_CHANGE_ACK back to the PCIe Core.
    Bits:  3    VfBusMstrEnStateChangeInt(rw1c) - Interrupt status bit that indicates there was a change to the VF_BUS_MASTER_ENABLE status from the PCIe core
    Bits:  2    VfEnableStateChangeInt(rw1c) - Interrupt status bit that indicates there was a change to VF_ENABLE status from the PCIe core.
    Bits:  1    LinkPwrStateChgInt(rw1c) - Interrupt status bit that indicates the LINK_POWER_STATE has changed
    Bits:  0    LinkStatusChgInt(rw1c) - Interrupt status bit that indicates the LINK_STATUS has changed
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT            0x00000180
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_FUNC_STATUS_CHG_INT_MASK BIT(21)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_PWR_STATE_CHG_INT_MASK BIT(20)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_VF_BUS_MSTR_EN_STATE_CHG_INT_MASK BIT(19)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_VF_ENABLE_STATE_CHANGE_INT_MASK BIT(18)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_LINK_PWR_STATE_CHG_INT_MASK BIT(17)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_LINK_STATUS_CHG_INT_MASK BIT(16)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_CFG_FUNC_NUM(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_CFG_FUNC_NUM_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_FUNC_STATUS_CHG_INT BIT(5)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_PWR_STATE_CHG_INT BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_VF_BUS_MSTR_EN_STATE_CHG_INT BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_VF_ENABLE_STATE_CHANGE_INT BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_LINK_PWR_STATE_CHG_INT BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_STATE_CHG_STAT_LINK_STATUS_CHG_INT BIT(0)
/*----------------------------------------------------------------
  Register: PCIeMsiDropError - Contains MSI Req Drop status, mask and function of the request error
    Bits: 10    IsLegacy(ro) - This bit indicates that the MSI recieved went down as legacy and was dropped due to INTx disable.
    Bits:  9    MSIReqErrorMask(rw) - Set this bit to mask event generation when an MSI Request Error is detected. Clear this bit to enable MSI Request Error event generation.
    Bits:  8    MSIReqError(rw1c) - This bit is set when a VF MSI Interrupt is received from the attached PCIe Island for a function that is masked for MSI
    Bits:  7:0  MSIFunction(ro) - Function number associated with the MSIReqError
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR            0x00000184
#define   NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR_IS_LEGACY BIT(10)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR_MSI_REQ_ERROR_MASK BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR_REQ_ERROR BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR_MSIFUNCTION(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_MSI_DROP_ERROR_MSIFUNCTION_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop - Top level MSI Mask Change Status register.
    Bits: 11:8  MsiMaskChgStat(w1c) - PF MSI Mask Change status for PF 0-3. A set bit indicates there was a write to the PF MSI Mask register associated with a Physical Function
    Bits:  2:0  VfMsiMaskChgTopStat(ro) - Used by software to indicate which of the three PCIeVfMsiMaskChgStat registers contains a set bit. Bit 0 equals the logical 'or' of the PCIeVfMsiMaskChgStat0 register. Bit 1 equals the logical 'or' of the PCIeVfMsiMaskChgStat2 register. Bit 2 equals the logical 'or' of the PCIeVfMsiMaskChgStat3 register.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIE_MSI_MASK_CHG_STAT_TOP 0x00000188
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_MSI_MASK_CHG_STAT_TOP_MSI_MASK_CHG_STAT(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_MSI_MASK_CHG_STAT_TOP_MSI_MASK_CHG_STAT_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_MSI_MASK_CHG_STAT_TOP_VF_MSI_MASK_CHG_TOP_STAT(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_MSI_MASK_CHG_STAT_TOP_VF_MSI_MASK_CHG_TOP_STAT_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf0MsiMaskChgStat - VF MSI Mask Change Status register, VF# (27-0)
    Bits: 31:4  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF (27-0). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIE_VF0_MSI_MASK_CHG_STAT 0x0000018c
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF0_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF0_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf1MsiMaskChgStat - VF MSI Mask Change Status register VF# (59-28)
    Bits: 31:0  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF (59-28). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIE_VF1_MSI_MASK_CHG_STAT 0x00000190
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF1_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF1_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf2MsiMaskChgStat - VF MSI Mask Change Status register VF# (63-60)
    Bits:  3:0  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF(63-60). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIE_VF2_MSI_MASK_CHG_STAT 0x00000194
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF2_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIEMSIMASKCHGSTRUCT_PCIE_VF2_MSI_MASK_CHG_STAT_VF_MSI_MASK_CHG_STAT_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlrDone - Function Level Reset Done Registers
    Bits: 10:5  VfFlrDoneChannel(rw) - Virtual Function, Function Level Reset Done Channel
    Bits:  4    VfFlrDone(wo) - Virtual Function, Function Level Reset Done
    Bits:  2:1  FlrDoneChannel(rw) - Physical Function, Function Level Reset Done Channel
    Bits:  0    FlrDone(wo) - Physical Function, Function Level Reset Done
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE                  0x000001ac
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_VF_FLR_DONE_CHANNEL(_x) (((_x) & 0x3f) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_VF_FLR_DONE_CHANNEL_of(_x) (((_x) >> 5) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_VF_FLR_DONE    BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_FLR_DONE_CHANNEL(_x) (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_FLR_DONE_CHANNEL_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_FLR_DONE_FLR_DONE       BIT(0)
/*----------------------------------------------------------------
  Register: PCIeVf0TphReqEnable - Virtual Function TPH requester enable for VF 27-0.
    Bits: 31:4  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (27-0)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF0_TPH_REQ_EN            0x000001b0
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF0_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1TphReqEnable - Virtual Function TPH requester enable for VF# 59-28
    Bits: 31:0  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (59-28)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF1_TPH_REQ_EN            0x000001b4
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF1_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2TphReqEnable - Virtual Function TPH requester enable for VF# 63-0
    Bits:  3:0  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (63-60)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VF2_TPH_REQ_EN            0x000001b8
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VF2_TPH_REQ_EN_PCIE_VF_TPH_REQ_EN_N_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff0 - map presets to their coefficients. Preset 0
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF0                     0x000001d0
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF0_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF0_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF0_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF0_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff1 - map presets to their coefficients. Preset 1
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF1                     0x000001d4
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF1_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF1_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF1_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF1_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff2 - map presets to their coefficients. Preset 2
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF2                     0x000001d8
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF2_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF2_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF2_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF2_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff3 - map presets to their coefficients. Preset 3
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF3                     0x000001dc
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF3_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF3_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF3_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF3_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff4 - map presets to their coefficients. Preset 4
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF4                     0x000001e0
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF4_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF4_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF4_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF4_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff5 - map presets to their coefficients. Preset 5
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF5                     0x000001e4
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF5_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF5_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF5_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF5_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff6 - map presets to their coefficients. Preset 6
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF6                     0x000001e8
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF6_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF6_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF6_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF6_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff7 - map presets to their coefficients. Preset 7
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF7                     0x000001ec
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF7_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF7_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF7_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF7_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff8 - map presets to their coefficients. Preset 8
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF8                     0x000001f0
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF8_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF8_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF8_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF8_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff9 - map presets to their coefficients. Preset 9
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF9                     0x000001f4
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF9_RESERVED(_x)      (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF9_RESERVED_of(_x)   (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF9_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF9_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff10 - map presets to their coefficients. Preset 10
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIECOEFF10                    0x000001f8
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF10_RESERVED(_x)     (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF10_RESERVED_of(_x)  (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF10_PCIE_PRESET_COEFF(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECOEFF10_PCIE_PRESET_COEFF_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIeSramCtrlReg - Sram Ctrl Reg for LINK memories
    Bits: 31    PcieSramCtlWen(wo) - Write to 1 to initiate a write to the selected sram control register.
    Bits: 18:16 PCIeSramCtlSel(rw) - Selects which SRAM Control register to write to or read from.
    Bits: 10    TStab0(rw) - SRAM0: Stability test during Read operation. Low during functional mode.
    Bits:  9    TWbt0(rw) - SRAM0: Weak Bit Test. Low during functional mode. Used for margin test by implementing small speed up in Sense-amp timings during read operations and small decrease in Wordline pulse-width during write operation.
    Bits:  8    MaTpb0(rw) - SRAM0: Margin Adjust Port B.
    Bits:  7    MaTpa0(rw) - SRAM0: Margin Adjust Port A.
    Bits:  6:5  MaWras0(rw) - SRAM0: Margin Adjust: Write Assist timings.
    Bits:  4:3  MaWl0(rw) - SRAM0: Margin Adjust: Wordline pulse width only. See SRAMs specs.
    Bits:  2:1  MaSawl0(rw) - SRAM0: Margin Adjust: Sense-Amp timing and Wordline pulse width. See SRAMs specs.
    Bits:  0    MaWrasd0(rw) - SRAM0: Margin Adjust: Write Assist function disable. See SRAMs specs.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG             0x000001fc
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAMCTL_WEN BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_of(_x) (((_x) >> 16) & 0x7)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_PNPFIFORAM (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_REPLAYBUFFERRAM (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_COMPLFIFORAM (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_SCTABLERAM (3)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_SCTABLETIMERRAM (4)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_SCTABLEBCRAM (5)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_PCIE_SRAM_CTL_SEL_TPHRAM (6)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_T_STAB_0  BIT(10)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_T_WBT_0   BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_TPB_0  BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_TPA_0  BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_WRAS_0(_x) (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_WRAS_0_of(_x) (((_x) >> 5) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_WL_0(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_WL_0_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_SAWL_0(_x) (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_SAWL_0_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_SRAM_CTRL_REG_MA_WRASD_0 BIT(0)
/*----------------------------------------------------------------
  Register: PCIeLocalLowFreq[2] - Provides the Low Frequency (LF) values used for quad SERDES #X. These signals are only used at the 8.0 GT/s signaling rate.
    Bits: 31:24 Reserved(ro) - Reserved
    Bits: 23:18 LocalLf_lane_n3(rw) - Lane n3 Low Frequency (LF) value considered during TX equalization.
    Bits: 17:12 LocalLf_lane_n2(rw) - Lane n2 Low Frequency (LF) value considered during TX equalization.
    Bits: 11:6  LocalLf_lane_n1(rw) - Lane n1 Low Frequency (LF) value considered during TX equalization.
    Bits:  5:0  LocalLf_lane_n0(rw) - Lane n0 Low Frequency (LF) value considered during TX equalization.
*/
#define NFP3800_PCIEX_CTRLCFG_LOCALLF(_x)                    (0x00000200 + (0x4 * ((_x) & 0x1)))
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_RESERVEDLFS1(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_RESERVEDLFS1_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N3(_x) (((_x) & 0x3f) << 18)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N3_of(_x) (((_x) >> 18) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N2(_x) (((_x) & 0x3f) << 12)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N2_of(_x) (((_x) >> 12) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_1N(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_1N_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N0(_x) (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_LOCALLF_LOCAL_LF_LANE_N0_of(_x) (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIeLocalFullSwing[2] - Provides the Full Swing values used for quad SERDES #X. These signals are only used at the 8.0 GT/s signaling rate.
    Bits: 31:24 Reserved(ro) - Reserved
    Bits: 23:18 LocalFs_lane_n3(rw) - Lane n3 Low Frequency (FS) value considered during TX equalization.
    Bits: 17:12 LocalFs_lane_n2(rw) - Lane n2 Low Frequency (FS) value considered during TX equalization.
    Bits: 11:6  LocalFs_lane_n1(rw) - Lane n1 Low Frequency (FS) value considered during TX equalization.
    Bits:  5:0  LocalFs1_lane_n0(rw) - Lane n0 Low Frequency (FS) value considered during TX equalization.
*/
#define NFP3800_PCIEX_CTRLCFG_LOCALFS(_x)                    (0x00000208 + (0x4 * ((_x) & 0x1)))
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_RESERVEDLFS1(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_RESERVEDLFS1_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N3(_x) (((_x) & 0x3f) << 18)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N3_of(_x) (((_x) >> 18) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N2(_x) (((_x) & 0x3f) << 12)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N2_of(_x) (((_x) >> 12) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_1N(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_1N_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N0(_x) (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_LOCALFS_LOCAL_FS_LANE_N0_of(_x) (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIeCtrlIntOutSel - Legacy interrupt select for PF0-PF7
    Bits:  7:6  InterruptOutSelectPF3(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  5:4  InterruptOutSelectPF2(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  3:2  InterruptOutSelectPF1(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  1:0  InterruptOutSelectPF0(rw) - Selects which interrupt pin legacy interrupts are mapped to.
*/
#define NFP3800_PCIEX_CTRLCFG_INT_SEL                        0x00000220
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3(_x)      (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3_of(_x)   (((_x) >> 6) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3_INTA   (0)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3_INTB   (1)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3_INTC   (2)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF3_INTD   (3)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2(_x)      (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2_of(_x)   (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2_INTA   (0)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2_INTB   (1)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2_INTC   (2)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF2_INTD   (3)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1(_x)      (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1_of(_x)   (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1_INTA   (0)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1_INTB   (1)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1_INTC   (2)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF1_INTD   (3)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0(_x)      (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0_of(_x)   (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0_INTA   (0)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0_INTB   (1)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0_INTC   (2)
#define     NFP3800_PCIEX_CTRLCFG_INT_SEL_INT_SEL_PF0_INTD   (3)
/*----------------------------------------------------------------
  Register: PCIeVsecCtrl0 - VSEC Ctrl inputs to the controller PF0-PF3
    Bits: 31:24 VsecCtrlPF3(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits: 23:16 VsecCtrlPF2(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits: 15:8  VsecCtrlPF1(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits:  7:0  VsecCtrlPF0(rw) - VSEC Ctrl input to Pcie Controller Core.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L                0x00000224
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF3(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF3_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF2(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF2_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_VSEC_CTR0L_VSEC_CTRL_PF0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCtrlAsrtCfg - Link Assertion Config
    Bits: 17:16 PcieAsrtCfgEnableFsms(rw) - Set to enable FSM assertions, one bit for each of the 2 assertion drive modules.
    Bits:  1:0  PcieAsrtCfgDisableAssertions(rw) - Set to disable the assertions, one bit for each of the 2 assertion drive modules.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_ASRT_CFG             0x000002a0
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_ASRT_CFG_PCIE_ASRT_CFG_ENABLE_FSMS(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_ASRT_CFG_PCIE_ASRT_CFG_ENABLE_FSMS_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_ASRT_CFG_PCIE_ASRT_CFG_DISABLE_ASSERTIONS(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_ASRT_CFG_PCIE_ASRT_CFG_DISABLE_ASSERTIONS_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: MsiMaskChangeEventEn - Set this bit to enable event generation for MSI Mask changes.
    Bits:  0    MsiMaskChangeEventEn(rw) - Set this bit to enable event generation for MSI mask changes.
*/
#define NFP3800_PCIEX_CTRLCFG_MSI_MASK_CHANGE_EVENT_EN       0x000002a4
#define   NFP3800_PCIEX_CTRLCFG_MSI_MASK_CHANGE_EVENT_EN_MSI_MASK_CHANGE_EVENT_EN BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlResetStat - Link Reset status
    Bits:  4    PcieRawResetStatus(ro) - Live status of the raw reset.
    Bits:  3    PcieRawResetFallingMask(rw) - Bit to Mask the event generation for a falling edge on the raw reset.
    Bits:  2    PcieRawResetFalling(rc) - Set to 1 if there has been a falling edge on the raw reset.
    Bits:  1    PcieRawResetRisingMask(rw) - Bit to Mask the event generation for a rising edge on the raw reset.
    Bits:  0    PcieRawResetRising(rc) - Set to 1 if there has been a rising edge on the raw reset.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT           0x000002ac
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT_PCIE_RAW_RESET_STATUS BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT_PCIE_RAW_RESET_FALLING_MASK BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT_PCIE_RAW_RESET_FALLING BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT_PCIE_RAW_RESET_RISING_MASK BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_RESET_STAT_PCIE_RAW_RESET_RISING BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlPerfCfg - Link Performance Mux Control Register
    Bits: 20:18 AuxSelect(None) - Module select for module 3.
    Bits: 17:14 HiMuxSelect(None) - High 16 to 1 mux select
    Bits: 13:10 MidMuxSelect(None) - Middle 16 to 1 mux select.
    Bits:  9:6  LowMuxSelect(None) - Low 16 to 1 mux select.
    Bits:  5:4  LaneSelectHi(None) - Lane select for bits [32;64]
    Bits:  3:2  LaneSelectMid(None) - Lane select for bits [32;32]
    Bits:  1:0  LaneSelectLo(None) - Lane select for bits [32;0]
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG             0x000002b0
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_AUX_SELECT(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_AUX_SELECT_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_HI_MUX_SELECT(_x) (((_x) & 0xf) << 14)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_HI_MUX_SELECT_of(_x) (((_x) >> 14) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_MID_MUX_SELECT(_x) (((_x) & 0xf) << 10)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_MID_MUX_SELECT_of(_x) (((_x) >> 10) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LOW_MUX_SELECT(_x) (((_x) & 0xf) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LOW_MUX_SELECT_of(_x) (((_x) >> 6) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI_DESELECT (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI_LOWSELECT (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI_MIDSELECT (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_HI_HISELECT (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID_DESELECT (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID_LOWSELECT (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID_MIDSELECT (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_MID_HISELECT (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO_DESELECT (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO_LOWSELECT (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO_MIDSELECT (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_PERF_CFG_LANE_SELECT_LO_HISELECT (3)
/*----------------------------------------------------------------
  Register: PCIeCtrlSwCreditLimit0 - SW credit limits for credit trackers in HAL switch
    Bits: 14:12 PcieHalmComplOutletCt(rw) - SW limit for halm compl outlet Fifo.
    Bits: 11:3  PcieHalmComplBurstComplCt(rw) - SW limit for halm compl Burst Compl Fifo.
    Bits:  2:0  PciemHalmComplC1Ct(rw) - SW limit for pciem halm compl fifo.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT      0x00000300
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIE_HALM_COMPL_OUTLET_CT(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIE_HALM_COMPL_OUTLET_CT_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIE_HALM_COMPL_BURST_COMPL_CT(_x) (((_x) & 0x1ff) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIE_HALM_COMPL_BURST_COMPL_CT_of(_x) (((_x) >> 3) & 0x1ff)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIEM_HALM_COMPL_C1_CT(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIE_CTRL_SW_CREDIT_LIMIT_PCIEM_HALM_COMPL_C1_CT_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: SerDesCtrl - Control Register for serdes registers' read write operations.
    Bits: 31    SerDesErrorW12C(rw1c) - Gives the status of the serdes error, w12c
    Bits: 21:2  SerDesAddr(rw) - Address [19:0] of the serdes AHB address
    Bits:  1    SerDesRNW(rw) - 1=Read, 0=Write
    Bits:  0    SerDesBusy(rw) - Write 1 to this bit to start the serdes operation. Self clears after ack. Read this bit before writing a new op again
*/
#define NFP3800_PCIEX_CTRLCFG_SERDES_CTRL                    0x00000260
#define   NFP3800_PCIEX_CTRLCFG_SERDES_CTRL_SERDES_ERROR_W12C BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_CTRL_SERDES_ADDR(_x)  (((_x) & 0xfffff) << 2)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_CTRL_SERDES_ADDR_of(_x) (((_x) >> 2) & 0xfffff)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_CTRL_SERDES_RNW       BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_CTRL_SERDES_BUSY      BIT(0)
/*----------------------------------------------------------------
  Register: SerDesWrData - Write port to serdes registers.
    Bits: 31:0  SerDesWrData(rw) - Write Data for serdes registers
*/
#define NFP3800_PCIEX_CTRLCFG_SERDES_WRDATA                  0x00000264
#define   NFP3800_PCIEX_CTRLCFG_SERDES_WRDATA_SERDES_WR_DATA(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_WRDATA_SERDES_WR_DATA_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: SerDesRdData - Read return data for serdes.
    Bits: 31:0  SerDesRdData(ro) - Read Data for serdes registers
*/
#define NFP3800_PCIEX_CTRLCFG_SERDES_RDDATA                  0x00000268
#define   NFP3800_PCIEX_CTRLCFG_SERDES_RDDATA_SERDES_RD_DATA(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_SERDES_RDDATA_SERDES_RD_DATA_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlVscLastVf0 - PCI Vendor Specific Capability Last VF register, used for PF0-3
    Bits: 31    Pf3LastVfRsvd(ro) - Reserved
    Bits: 30:24 Pf3LastVF(rw) - Last VF[6;0] associated with Physical function 3
    Bits: 23    Pf2LastVfRsvd(ro) - Reserved
    Bits: 22:16 Pf2LastVF(rw) - Last VF[6;0] associated with Physical function 2
    Bits: 15    Pf1LastVfRsvd(ro) - Reserved
    Bits: 14:8  Pf1LastVF(rw) - Last VF[6;0] associated with Physical function 1
    Bits:  7    Pf0LastVfRsvd(ro) - Reserved
    Bits:  6:0  Pf0LastVF(rw) - Last VF[6;0] associated with Physical function 0
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_VSC_LAST_VF0 0x00000330
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF3_LAST_VF_RSVD BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF3_LASTVF(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF3_LASTVF_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF2_LAST_VF_RSVD BIT(23)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF2_LASTVF(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF2_LASTVF_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF1_LAST_VF_RSVD BIT(15)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF1_LASTVF(_x) (((_x) & 0x7f) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF1_LASTVF_of(_x) (((_x) >> 8) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF0_LAST_VF_RSVD BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF0_LASTVF(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_LAST_VF0_PF0_LASTVF_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlVscRegionEna - PCI Vendor Specific Capability Region Enables
    Bits: 19:16 MsixOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting MSI-X configuration registers at offset 0xb0-0xbc. There is one enable per physical function.
    Bits: 11:8  MsiOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting MSI configuration registers at offset 0x90-0xac. There is one enable per physical function.
    Bits:  3:0  PwrOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting power-management configuration registers at offset 0x88-0x8c. There is one enable per physical function.
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_VSC_REGION_ENA 0x00000338
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_MSIX_OVRD_ENA(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_MSIX_OVRD_ENA_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_MSI_OVRD_ENA(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_MSI_OVRD_ENA_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_PWR_OVRD_ENA(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIE_CTRL_VSC_REGION_ENA_PWR_OVRD_ENA_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlPF0VscCfg[32] - PF0 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF1VscCfg[32] - PF1 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF2VscCfg[32] - PF2 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF3VscCfg[32] - PF3 PCI Vendor Specific Capablity Register X
    Bits: 31:0  PCIeVendorSpecificCapabilityReg(rw) - Programmable Vendor Specific Capability Registers
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_PF0_VSC_CFG(_x) (0x00000390 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_PF1_VSC_CFG(_x) (0x00000410 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_PF2_VSC_CFG(_x) (0x00000490 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIE_CTRL_PF3_VSC_CFG(_x) (0x00000510 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIECTRLVSCCFG_PCIE_VEND_SPECIFIC_CAP_REG(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIECTRLVSCMAP_PCIECTRLVSCCFG_PCIE_VEND_SPECIFIC_CAP_REG_of(_x) (((_x) >> 0) & 0xffffffff)

#else /* NFP3800_LONGNAMES */

/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeToCppExpansionBAR_[3]_[8] - PCIe to CPP Translation Expansion BARs for a Physical Function BAR X
    Bits: 31:29 MapType(rw) - Map Type
    Bits: 28:27 LengthSelect(rw) - Used to select the weighting of the CPP length field.
    Bits: 26:23 Target_BaseAddress(rw) - MapType 0, 1 and 2 this field specifies TargetID, otherwise upper portion of Base Address.
    Bits: 22:21 Token_BaseAddress(rw) - MapType 0 and 1 this field specifies CPP Token, otherwise upper portion of Base Address.
    Bits: 20:16 Action_BaseAddress(rw) - MapType 0 this field specifies Action, otherwise upper portion of Base Address.
    Bits: 15:0  BaseAddress(rw) - Base address. Each mapping uses a varying number of bits, always starting at the most significant bit. Remaining least significant bits are ignored.
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR(_x, _y, _z) (0x00000000 + (0xc0 * ((_x) & 0x7)) + (0x20 * ((_y) & 0x3)) + (0x4 * ((_z) & 0x7)))
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_of(_x) (((_x) >> 29) & 0x7)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_FIXED (0)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_BULK (1)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_TARGET (2)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_GENERAL (3)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_EXPLICIT0 (4)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_ROCE (5)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_MapType_TRAP (6)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_LengthSelect(_x) (((_x) & 0x3) << 27)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_LengthSelect_of(_x) (((_x) >> 27) & 0x3)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_LengthSelect_32BIT (0)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_LengthSelect_64BIT (1)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_LengthSelect_0BYTE (3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Target_BaseAddress(_x) (((_x) & 0xf) << 23)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Target_BaseAddress_of(_x) (((_x) >> 23) & 0xf)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Token_BaseAddress(_x) (((_x) & 0x3) << 21)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Token_BaseAddress_of(_x) (((_x) >> 21) & 0x3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Action_BaseAddress(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_Action_BaseAddress_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_BaseAddress(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBAR_BaseAddress_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeToCppExpansionBARVf_[3]_[2] - PCIe to CPP Translation for Virtual Function BAR X
    Bits: 31:30 LengthSelect(rw) - Used to select the weighting of the CPP length field.
    Bits: 29:26 Target(rw) - Specifies Target ID.
    Bits: 25:24 Token(rw) - Specifies CPP Token.
    Bits: 23:22 MapType(rw) - Map Type selects memory mapped or internal peripheral target mapping
    Bits: 21:0  BaseAddress(rw) - Base address. Each aperture uses a varying number of bits, always starting at the most significant bit of the BaseAddr field. Remaining least significant bits of BaseAddr are ignored. NOTE: Trap Mode uses bits [20:16] for CPP Action
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf(_x, _y, _z) (0x00000060 + (0xc0 * ((_x) & 0x7)) + (0x8 * ((_y) & 0x3)) + (0x4 * ((_z) & 0x1)))
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_LengthSelect(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_LengthSelect_of(_x) (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_LengthSelect_32BIT (0)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_LengthSelect_64BIT (1)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_LengthSelect_0BYTE (3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_Target(_x) (((_x) & 0xf) << 26)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_Target_of(_x) (((_x) >> 26) & 0xf)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_Token(_x) (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_Token_of(_x) (((_x) >> 24) & 0x3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType_of(_x) (((_x) >> 22) & 0x3)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType_MEM (0)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType_ROCE (1)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType_QCTL (2)
#define     NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_MapType_TRAP (3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_BaseAddress(_x) (((_x) & 0x3fffff) << 0)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeToCppExpansionBARVf_BaseAddress_of(_x) (((_x) >> 0) & 0x3fffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR0 - PCIe to CPP Explicit Command BAR 0
    Bits: 31:30 SignalType(rw) - Signal type to expect from CPP target. Set 1 bit for each signal expected. If 0 this implies the PCIe component should expect no CPP signal and will complete the PCIe request immediately, potentially before the CPP request completes. This use case is reserved for 3rd party Mastering and Signaling. Ensure all Explicit CPP Command fields (Data/Signal Master, Data/Signal Ref) are configured properly for the intended Master/Target combination.
    Bits: 29:28 Token(rw) - CPP command token
    Bits: 23:0  Address(rw) - This field represents bits [39:22] of CPP command address, starting with the msb and truncating unnecessary lsb bits, depending on the size of the aperture. See figure 2.2 for more detail of address bit muxing.
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0(_x, _y) (0x00000080 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_SignalType(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_SignalType_of(_x) (((_x) >> 30) & 0x3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_Token(_x) (((_x) & 0x3) << 28)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_Token_of(_x) (((_x) >> 28) & 0x3)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_Address(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR0_Address_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR1 - PCIe to CPP Explicit Command BAR 1
    Bits: 30:24 SignalRef(rw) - CPP command signal reference, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
    Bits: 23:14 DataMaster(rw) - CPP command data master, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
    Bits: 13:0  DataRef(rw) - CPP command data reference, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1(_x, _y) (0x00000084 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_SignalRef(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_SignalRef_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_DataMaster(_x) (((_x) & 0x3ff) << 14)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_DataMaster_of(_x) (((_x) >> 14) & 0x3ff)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_DataRef(_x) (((_x) & 0x3fff) << 0)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR1_DataRef_of(_x) (((_x) >> 0) & 0x3fff)
/*----------------------------------------------------------------
  Register: PcieToCppExpansionBar_PF[8]_PCIeExplicitCmd_[4]_PCIeExplicitCmdBAR2 - PCIe to CPP Explicit Command BAR 2
    Bits: 31:28 Target(rw) - CPP command target ID
    Bits: 27:23 Action(rw) - CPP Command Action Encoding
    Bits: 22:18 Length(rw) - CPP command length
    Bits: 17:10 ByteMask(rw) - CPP command byte mask
    Bits:  9:0  SignalMaster(rw) - CPP command signal master, when SigType is 0, otherwise RESERVED BY HW, dont care for SW
*/
#define NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2(_x, _y) (0x00000088 + (0xc0 * ((_x) & 0x7)) + (0x10 * ((_y) & 0x3)))
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Target(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Target_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Action(_x) (((_x) & 0x1f) << 23)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Action_of(_x) (((_x) >> 23) & 0x1f)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Length(_x) (((_x) & 0x1f) << 18)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_Length_of(_x) (((_x) >> 18) & 0x1f)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_ByteMask(_x) (((_x) & 0xff) << 10)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_ByteMask_of(_x) (((_x) >> 10) & 0xff)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_SignalMaster(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_BAR_PcieToCppExpansionBar_PF_PCIeExplicitCmd_PCIeExplicitCmdBAR2_SignalMaster_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: CPPToPCIeBAR[8] - CPP to PCIe translation BAR
    Bits: 31:30 MapType(rw) - Map Type
    Bits: 29    OverrideRID(rw) - Set if, Requester ID in PCIe TLP header should be overridden.
    Bits: 28:21 RequesterID(rw) - Value for Requester ID (if OverrideRID is set) to use in PCIe TLP header. Otherwise ignored.
    Bits: 20:0  Address(rw) - PCIe address bits [47:27] for 32-bit mode and [20:8] map to bits [47:35] for 40-bit mode. NOTE: For Type-1 Configuration cycles to the PCIe bus, bit [3] of this field should be set to '1'.
*/
#define NFP3800_PCIE_BAR_CPPToPCIeBAR(_x)                    (0x00000600 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_MapType(_x)          (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_MapType_of(_x)       (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_BAR_CPPToPCIeBAR_MapType_MEM        (0)
#define     NFP3800_PCIE_BAR_CPPToPCIeBAR_MapType_IO         (1)
#define     NFP3800_PCIE_BAR_CPPToPCIeBAR_MapType_CFG        (2)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_OverrideRID          BIT(29)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_RequesterID(_x)      (((_x) & 0xff) << 21)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_RequesterID_of(_x)   (((_x) >> 21) & 0xff)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_Address(_x)          (((_x) & 0x1fffff) << 0)
#define   NFP3800_PCIE_BAR_CPPToPCIeBAR_Address_of(_x)       (((_x) >> 0) & 0x1fffff)
/*----------------------------------------------------------------
  Register: CPPToPCIeBaseExt[8] - CPP to PCIe BAR Base Address extension
    Bits: 15:0  Cpp2Pcie_Base_Addr_Ext(rw) - An extension of the Base Address field of the Cpp2PCIe BAR to form a 64-bit PCIe address.
*/
#define NFP3800_PCIE_BAR_CPPToPCIeBaseExt(_x)                (0x00000620 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_BAR_CPPToPCIeBaseExt_Cpp2Pcie_Base_Addr_Ext(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_BAR_CPPToPCIeBaseExt_Cpp2Pcie_Base_Addr_Ext_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeMsixInterruptGenerator_PcieMsiSwGenEntry[256] - Used by Software to generate MSI Interrupts. Must be in MSI mode. msi_ctrl_reg register MSIEn=1. The offset into the table is used to generate the 8-bit function number
    Bits:  4:0  MsiVectorNum(wo) - The MSI Vector number to use when software is generating MSI Interrupts.
*/
#define NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsiSwGenEntry(_x) (0x00060000 + (0x4 * ((_x) & 0xff)))
#define   NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsiSwGenEntry_MsiVectorNum(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsiSwGenEntry_MsiVectorNum_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeMsixInterruptGenerator_PcieMsixSwGenEntry[256] - Used by software to generate MSIX Interrupts. Must be in MSIX mode. msix_ctrl register MSIxEn=1
    Bits:  7:0  MsixVectorNum(wo) - The MSIX Vector number to use when software is generating MSIX Interrupts.
*/
#define NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsixSwGenEntry(_x) (0x00060000 + (0x4 * ((_x) & 0xff)))
#define   NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsixSwGenEntry_MsixVectorNum(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_MSIX_PCIeMsixInterruptGenerator_PcieMsixSwGenEntry_MsixVectorNum_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeTargetFuncCfgLUT[64] - Lookup table that stores for each VF the base addr of its queue region, number of queues and which associated PF
    Bits: 31    EntryValid(rw) - A valid bit to indicate the table entry has been initialized.
    Bits: 29:28 PhysFuncNum(rw) - PF number associated with the VF.
    Bits: 24:16 QueueCount(rw) - The 9-bit count of queues assigned to VF, used to check if queue request is valid or out of range, where the queue count is specified as number of queues minus 1
    Bits:  8:0  QueueBaseAddr(rw) - The 9-bit base addr of where VF queues start.
*/
#define NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT(_x)          (0x00070000 + (0x4 * ((_x) & 0x3f)))
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_EntryValid BIT(31)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_PhysFuncNum(_x) (((_x) & 0x3) << 28)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_PhysFuncNum_of(_x) (((_x) >> 28) & 0x3)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_QueueCount(_x) (((_x) & 0x1ff) << 16)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_QueueCount_of(_x) (((_x) >> 16) & 0x1ff)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_QueueBaseAddr(_x) (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIE_VFLUT_PCIeTargetFuncCfgLUT_QueueBaseAddr_of(_x) (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven0 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd0 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven0 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd0 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd0 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven0 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd0 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven0 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd0 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven0 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd0 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:0  CPPAddressLo(wo) - Lower 32-bits of 40-bit CPP bus address unless ModeSelect==3 and DmaMode[13]==1 (Packet Mode). In Packet Mode this field contains the {SequenceNumber[15:00],2h0,TotalLength[13:0]}. The SequenceNumber is copied to the metadata written to the CTM. The TotalLength is the total number of bytes of a Packet Mode Gather DMA and must be equal to the total of each stage of the DMA operation. (refer to the DMA section of the EAS).
*/
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIeven0            0x00000000
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIodd0             0x00000010
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIeven0           0x00000020
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIodd0            0x00000030
#define NFP3800_PCIE_DMA_DmaCmdInsertLoToPCIodd0             0x00000040
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIeven0           0x00000060
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIodd0            0x00000070
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIeven0          0x00000080
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIodd0           0x00000090
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIeven0           0x000000a0
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIodd0            0x000000b0
#define   NFP3800_PCIE_DMA_DMADescrLegacy0_CPPAddressLo(_x)  (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMADescrLegacy0_CPPAddressLo_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven1 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd1 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven1 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd1 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd1 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven1 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd1 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven1 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd1 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven1 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd1 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:30 ModeSelect(wo) - Selects what type of signaling, AutoPush or Event, or indicates Packet Mode, also see DMA Mode field
    Bits: 29:14 DmaMode(wo) - Indicates Signal or Event to generate on completed command or can be DMA descriptor extension for Data Gather support, depending on ModeSelect bits
    Bits: 13:12 CppToken(wo) - Specifies CPP Token to be used when issuing CPP commands for the transfer.
    Bits: 11:8  DmaConfigRegIndex(wo) - Index register for CPP transaction. Used to index from which register to get supplemental DMA descriptor configuration. NOTE: lsb chooses low or high half of 4B configuration register
    Bits:  7:0  CPPAddressHi(wo) - Upper 8-bits of 40-bit CPP bus address unless ModeSelect==3 and DmaMode[13]==1 (Packet Mode). In Packet Mode this field is the 8-bit QID copied to the metadata written to the CTM (refer to the DMA section of the EAS).
*/
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIeven1            0x00000004
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIodd1             0x00000014
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIeven1           0x00000024
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIodd1            0x00000034
#define NFP3800_PCIE_DMA_DmaCmdInsertLoToPCIodd1             0x00000044
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIeven1           0x00000064
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIodd1            0x00000074
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIeven1          0x00000084
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIodd1           0x00000094
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIeven1           0x000000a4
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIodd1            0x000000b4
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect(_x)    (((_x) & 0x3) << 30)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect_of(_x) (((_x) >> 30) & 0x3)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect_0    (0)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect_1    (1)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect_2    (2)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_ModeSelect_3    (3)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode(_x)       (((_x) & 0xffff) << 14)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode_of(_x)    (((_x) >> 14) & 0xffff)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode_0       (0)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode_1       (1)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode_2       (2)
#define     NFP3800_PCIE_DMA_DMADescrLegacy1_DmaMode_3       (3)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_CppToken(_x)      (((_x) & 0x3) << 12)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_CppToken_of(_x)   (((_x) >> 12) & 0x3)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_DmaConfigRegIndex(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_DmaConfigRegIndex_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_CPPAddressHi(_x)  (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMADescrLegacy1_CPPAddressHi_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven2 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd2 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven2 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd2 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd2 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven2 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd2 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven2 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd2 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven2 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd2 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:0  PCIeAddressLo(wo) - Lower 32 bits of 40-bit PCIe address
*/
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIeven2            0x00000008
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIodd2             0x00000018
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIeven2           0x00000028
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIodd2            0x00000038
#define NFP3800_PCIE_DMA_DmaCmdInsertLoToPCIodd2             0x00000048
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIeven2           0x00000068
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIodd2            0x00000078
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIeven2          0x00000088
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIodd2           0x00000098
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIeven2           0x000000a8
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIodd2            0x000000b8
#define   NFP3800_PCIE_DMA_DMADescrLegacy2_PCIeAddressLo(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMADescrLegacy2_PCIeAddressLo_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DmaCmdInsertHiToPCIeven3 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertHiToPCIodd3 - Insert legacy-format command into HiToPCIe DMA command queue or Write pointer for HiToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIeven3 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertMedToPCIodd3 - Insert legacy-format command into MedToPCIe DMA command queue or Write pointer for MedToPCIe DMA command queue
  Register: DmaCmdInsertLoToPCIodd3 - Insert legacy-format command into LoToPCIe DMA command queue or Write pointer for LoToPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIeven3 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertHiFrmPCIodd3 - Insert legacy-format command into HiFrmPCIe DMA command queue or Write pointer for HiFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIeven3 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertMedFrmPCIodd3 - Insert legacy-format command into MedFrmPCIe DMA command queue or Write pointer for MedFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIeven3 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
  Register: DmaCmdInsertLoFrmPCIodd3 - Insert legacy-format command into LoFrmPCIe DMA command queue or Write pointer for LoFrmPCIe DMA command queue
    Bits: 31:20 XferLength(wo) - Size of transfer. Specified as number of bytes minus 1.
    Bits: 19:12 RequesterID(wo) - 8-bit Requester ID to use (if OverrideRID is set)
    Bits: 11    OverrideRID(wo) - If set the value of RequesterID will be used for the Requester-ID in the PCIe TLP header
    Bits: 10:8  TransClass(wo) - Indicates the transaction class.
    Bits:  7:0  PCIeAddressHi(wo) - Upper 8 bits of 40-bit PCIe address
*/
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIeven3            0x0000000c
#define NFP3800_PCIE_DMA_DmaCmdInsertHiToPCIodd3             0x0000001c
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIeven3           0x0000002c
#define NFP3800_PCIE_DMA_DmaCmdInsertMedToPCIodd3            0x0000003c
#define NFP3800_PCIE_DMA_DmaCmdInsertLoToPCIodd3             0x0000004c
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIeven3           0x0000006c
#define NFP3800_PCIE_DMA_DmaCmdInsertHiFrmPCIodd3            0x0000007c
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIeven3          0x0000008c
#define NFP3800_PCIE_DMA_DmaCmdInsertMedFrmPCIodd3           0x0000009c
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIeven3           0x000000ac
#define NFP3800_PCIE_DMA_DmaCmdInsertLoFrmPCIodd3            0x000000bc
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_XferLength(_x)    (((_x) & 0xfff) << 20)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_XferLength_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_RequesterID(_x)   (((_x) & 0xff) << 12)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_RequesterID_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_OverrideRID       BIT(11)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_TransClass(_x)    (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_TransClass_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_PCIeAddressHi(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMADescrLegacy3_PCIeAddressHi_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMADescrConfig0 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig1 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig2 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig3 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig4 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig5 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig6 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
  Register: DMADescrConfig7 - Specifies additional DMA configuration information to supplement incoming descriptor, CPP Target, 32- or 64-bit target, CPP Token, padding depth, and PCIe descriptor attribute.
    Bits: 30    FrmPcieCppRnd8BOdd(rw) - When set, the length of the CPP portion of the From PCIe DMA is rounded up to the nearest 8 bytes. This bit has no effect on To PCIe DMAs.
    Bits: 29    FreeCtmPacketOdd(rw) - When set, a ToPCIe DMA issues a free packet command as part of the packet completion process to free the packet in the CTM packet engine
    Bits: 28    SignalOnlyOdd(rw) - Specifies if DMA is a signal-only, no data transferred.
    Bits: 27:26 EndPaddingOdd(rw) - Specifies if 0-padding should be inserted at the end of DMA transfers to PCIe.
    Bits: 25:24 StartPaddingOdd(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits: 23    IdBasedOrderingOdd(rw) - Specifies if ID-Based Ordering attribute should be set for PCIe request.
    Bits: 22    RelaxedOrderingOdd(rw) - Specifies if Relaxed Ordering attribute should be set for PCIe request.
    Bits: 21    NoSnoopOdd(rw) - Specifies if No Snoop attribute should be set for PCIe request.
    Bits: 20    Target64bitOdd(rw) - Specifies if CPP Target is 64-bit or 32-bit, default is 32-bit.
    Bits: 19:16 CppTargetIDOdd(rw) - Selects CPP Target to be used for DMA.
    Bits: 14    FrmPcieCppRnd8BEven(rw) - When set, the length of the CPP portion of the From PCIe DMA is rounded up to the nearest 8 bytes. This bit has no effect on To PCIe DMAs.
    Bits: 13    FreeCtmPacketEven(rw) - When set, a ToPCIe DMA issues a free packet command as part of the packet completion process to free the packet in the CTM packet engine
    Bits: 12    SignalOnlyEven(rw) - Specifies if DMA is a signal-only, no data transferred.
    Bits: 11:10 EndPaddingEven(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits:  9:8  StartPaddingEven(rw) - Specifies if 0-padding should be inserted in front of DMA transfers to PCIe.
    Bits:  7    IdBasedOrderingEven(rw) - Specifies if ID-Based Ordering attribute should be set for PCIe request.
    Bits:  6    RelaxedOrderingEven(rw) - Specifies if Relaxed Ordering attribute should be set for PCIe request.
    Bits:  5    NoSnoopEven(rw) - Specifies if No Snoop attribute should be set for PCIe request.
    Bits:  4    Target64bitEven(rw) - CPP target is 64-bit. Set if target supports 64-bit transactions, or cleared if target only supports 32-bit transaction.
    Bits:  3:0  CppTargetIDEven(rw) - Selects CPP Target to be used for DMA.
*/
#define NFP3800_PCIE_DMA_DMADescrConfig0                     0x000000c0
#define NFP3800_PCIE_DMA_DMADescrConfig1                     0x000000c4
#define NFP3800_PCIE_DMA_DMADescrConfig2                     0x000000c8
#define NFP3800_PCIE_DMA_DMADescrConfig3                     0x000000cc
#define NFP3800_PCIE_DMA_DMADescrConfig4                     0x000000d0
#define NFP3800_PCIE_DMA_DMADescrConfig5                     0x000000d4
#define NFP3800_PCIE_DMA_DMADescrConfig6                     0x000000d8
#define NFP3800_PCIE_DMA_DMADescrConfig7                     0x000000dc
#define   NFP3800_PCIE_DMA_DMADescrConfig_FrmPcieCppRnd8BOdd BIT(30)
#define   NFP3800_PCIE_DMA_DMADescrConfig_FreeCtmPacketOdd   BIT(29)
#define   NFP3800_PCIE_DMA_DMADescrConfig_SignalOnlyOdd      BIT(28)
#define   NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd(_x)  (((_x) & 0x3) << 26)
#define   NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd_of(_x) (((_x) >> 26) & 0x3)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd_16B (1)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd_64B (2)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingOdd_128B (3)
#define   NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd(_x) (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd_of(_x) (((_x) >> 24) & 0x3)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd_16B (1)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd_64B (2)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingOdd_128B (3)
#define   NFP3800_PCIE_DMA_DMADescrConfig_IdBasedOrderingOdd BIT(23)
#define   NFP3800_PCIE_DMA_DMADescrConfig_RelaxedOrderingOdd BIT(22)
#define   NFP3800_PCIE_DMA_DMADescrConfig_NoSnoopOdd         BIT(21)
#define   NFP3800_PCIE_DMA_DMADescrConfig_Target64bitOdd     BIT(20)
#define   NFP3800_PCIE_DMA_DMADescrConfig_CppTargetIDOdd(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_DMADescrConfig_CppTargetIDOdd_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_DMADescrConfig_FrmPcieCppRnd8BEven BIT(14)
#define   NFP3800_PCIE_DMA_DMADescrConfig_FreeCtmPacketEven  BIT(13)
#define   NFP3800_PCIE_DMA_DMADescrConfig_SignalOnlyEven     BIT(12)
#define   NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven_of(_x) (((_x) >> 10) & 0x3)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven_16B (1)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven_64B (2)
#define     NFP3800_PCIE_DMA_DMADescrConfig_EndPaddingEven_128B (3)
#define   NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven_of(_x) (((_x) >> 8) & 0x3)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven_DISABLED (0)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven_16B (1)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven_64B (2)
#define     NFP3800_PCIE_DMA_DMADescrConfig_StartPaddingEven_128B (3)
#define   NFP3800_PCIE_DMA_DMADescrConfig_IdBasedOrderingEven BIT(7)
#define   NFP3800_PCIE_DMA_DMADescrConfig_RelaxedOrderingEven BIT(6)
#define   NFP3800_PCIE_DMA_DMADescrConfig_NoSnoopEven        BIT(5)
#define   NFP3800_PCIE_DMA_DMADescrConfig_Target64bitEven    BIT(4)
#define   NFP3800_PCIE_DMA_DMADescrConfig_CppTargetIDEven(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIE_DMA_DMADescrConfig_CppTargetIDEven_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: DMAQStatToPCI0 - Queue status for ToPCIe DMA command queues
    Bits: 31:24 DmaLoQueAvail(ro) - DMA Low priority queue space available
    Bits: 23:16 DmaLoQueWrPtr(ro) - DMA Low priority queue write pointer
    Bits: 13    DisAriError(rw) - Setting this bit disables VF Access errors from dropping DMAs. When this bit is clear VF Access Errors cause DMAs using the errored VF to be dropped
    Bits: 12    ResetDMA(w1c) - Setting this bit clears the DMA Queue Read/Write Pointers. This bit can only be written after software writes a 1 to the QueueStop register. Software should only set this bit after waiting for any inflight DMAs to complete.
    Bits: 11    MultiBitError(rw1c) - When non-zero, A multi-bit error was detected while reading from the DMA Descriptor memory.
    Bits: 10    DisDmaDescMultiBitErr(rw) - When set, DMA Engine ingores Descriptor multibit errors.
    Bits:  9    HaltOnPfDmaError(rw) - When set, DMA Engine will halt on a physical function access error.
    Bits:  8    HaltOnRdMultiBitError(rw) - When set, DMA Engine will halt on a DMA Descriptor multibit error.
    Bits:  7:6  DmaError(rw1c) - When non-zero, DMA had an error. Bit 0 indicates a virtual function access error. Bit 1 indicates a physical function access error.
    Bits:  5:4  QueueOverflow(rw1c) - When non-zero, DMA queue descriptor is written to a full queue.
    Bits:  3    HaltOnFull(rw) - When non-zero, DMA Engine will halt when full
    Bits:  2    HighQueueStop(rw) - Set when the DMA engine High Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  1    MediumQueueStop(rw) - Set when the DMA engine Medium Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  0    LowQueueStop(rw) - Set when the DMA engine Low Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
*/
#define NFP3800_PCIE_DMA_DMAQStatToPCI0                      0x000000e0
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaLoQueAvail(_x)  (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaLoQueAvail_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaLoQueWrPtr(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaLoQueWrPtr_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DisAriError        BIT(13)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_ResetDMA           BIT(12)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_MultiBitError      BIT(11)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DisDmaDescMultiBitErr BIT(10)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_HaltOnPfDmaError   BIT(9)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_HaltOnRdMultiBitError BIT(8)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaError(_x)       (((_x) & 0x3) << 6)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_DmaError_of(_x)    (((_x) >> 6) & 0x3)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow(_x)  (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow_NoOvfl (0)
#define     NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow_LowOvfl (1)
#define     NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow_MedOvfl (2)
#define     NFP3800_PCIE_DMA_DMAQStatToPCI0_QueueOverflow_HighOvfl (3)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_HaltOnFull         BIT(3)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_HighQueueStop      BIT(2)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_MediumQueueStop    BIT(1)
#define   NFP3800_PCIE_DMA_DMAQStatToPCI0_LowQueueStop       BIT(0)
/*----------------------------------------------------------------
  Register: DMAQStatToPCI1 - Queue status for ToPCIe DMA command queues
  Register: DMAQStatFrmPCI1 - Queue status for FrmPCIe DMA command queues
    Bits: 31:24 DmaHiQueAvail(ro) - DMA High priority queue space available
    Bits: 23:16 DmaHiQueWrPtr(ro) - DMA High priority queue write pointer
    Bits: 15:8  DmaMedQueAvail(ro) - DMA Medium priority queue space available
    Bits:  7:0  DmaMedQueWrPtr(ro) - DMA Medium priority queue write pointer
*/
#define NFP3800_PCIE_DMA_DMAQStatToPCI1                      0x000000e4
#define NFP3800_PCIE_DMA_DMAQStatFrmPCI1                     0x000000ec
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaHiQueAvail(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaHiQueAvail_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaHiQueWrPtr(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaHiQueWrPtr_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaMedQueAvail(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaMedQueAvail_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaMedQueWrPtr(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMAQueueStatus1_DmaMedQueWrPtr_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMAQStatFrmPCI0 - Queue status for FrmPCIe DMA command queues
    Bits: 31:24 DmaLoQueAvail(ro) - DMA Low priority queue space available
    Bits: 23:16 DmaLoQueWrPtr(ro) - DMA Low priority queue write pointer
    Bits: 15:14 PktModeStgError(rw1c) - When non-zero, DMA detected a packet mode descriptor stage was in error. This indicates a start stage was received for a context that was still in use or a middle or end packet mode stage was detected with no previus start stage. In both cases the descriptors are dropped.
    Bits: 13    DisAriError(rw) - Setting this bit disables VF Access errors from dropping DMAs. When this bit is clear VF Access Errors cause DMAs using the errored VF to be dropped
    Bits: 12    ResetDMA(w1c) - Setting this bit clears the DMA Queue Read/Write Pointers. This bit can only be written after software writes a 1 to the QueueStop register. Software should only set this bit after waiting for any inflight DMAs to complete.
    Bits: 11    MultiBitError(rw1c) - When non-zero, A multi-bit error was detected while reading from the DMA Descriptor memory.
    Bits: 10    DisDmaDescMultiBitErr(rw) - When set, DMA Engine ingores Descriptor multibit errors.
    Bits:  9    HaltOnPfDmaError(rw) - When set, DMA Engine will halt on a physical function access error.
    Bits:  8    HaltOnRdMultiBitError(rw) - When set, DMA Engine will halt on a DMA Descriptor multibit error.
    Bits:  7:6  DmaError(rw1c) - When non-zero, DMA had an error. Bit 0 indicates a virtual function access error. Bit 1 indicates a physical function access error.
    Bits:  5:4  QueueOverflow(rw1c) - When non-zero, DMA queue descriptor is written to a full queue.
    Bits:  3    HaltOnFull(rw) - When non-zero, DMA Engine will halt when full
    Bits:  2    HighQueueStop(rw) - Set when the DMA engine High Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  1    MediumQueueStop(rw) - Set when the DMA engine Medium Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
    Bits:  0    LowQueueStop(rw) - Set when the DMA engine Low Queue is stopped due to an error, or if DMA engine is explicitly stopped by writing a 1 to this bit.
*/
#define NFP3800_PCIE_DMA_DMAQStatFrmPCI0                     0x000000e8
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaLoQueAvail(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaLoQueAvail_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaLoQueWrPtr(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaLoQueWrPtr_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError_of(_x) (((_x) >> 14) & 0x3)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError_NoPmStgErr (0)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError_LowPmStgErr (1)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError_MedPmStgErr (2)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_PktModeStgError_HighPmStgErr (3)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DisAriError       BIT(13)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_ResetDMA          BIT(12)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_MultiBitError     BIT(11)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DisDmaDescMultiBitErr BIT(10)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_HaltOnPfDmaError  BIT(9)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_HaltOnRdMultiBitError BIT(8)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaError(_x)      (((_x) & 0x3) << 6)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_DmaError_of(_x)   (((_x) >> 6) & 0x3)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow_NoOvfl (0)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow_LowOvfl (1)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow_MedOvfl (2)
#define     NFP3800_PCIE_DMA_DMAQStatFrmPCI0_QueueOverflow_HighOvfl (3)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_HaltOnFull        BIT(3)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_HighQueueStop     BIT(2)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_MediumQueueStop   BIT(1)
#define   NFP3800_PCIE_DMA_DMAQStatFrmPCI0_LowQueueStop      BIT(0)
/*----------------------------------------------------------------
  Register: DMACntrlConfig1 - DMA performance configure, cpp and pcie request issue rates
    Bits: 31:28 DmaFrmCppRate(rw) - DMA FromPCIe rate at which requests are issued to CPP
    Bits: 27:24 DmaToPcieRate(rw) - DMA ToPCIe rate at which requests are issued to CPP
    Bits: 23:20 DmaToCppRate(rw) - DMA ToPCIe rate at which requests are issued to PCIe
    Bits: 19:16 DmaFrmPcieRate(rw) - DMA FromPCIe rate at which requests are issued to PCIe
    Bits: 15:12 DmaFrmPcieIssueLoad(rw) - DMA FromPCIe issue rate load value. Controls rate at which requests are issued to PCIe
    Bits:  0    DmaRateLimitSelect(rw) - Selects the type of rate limiting used by the DMA engine.
*/
#define NFP3800_PCIE_DMA_DMACntrlConfig1                     0x000000f8
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmCppRate(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmCppRate_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaToPcieRate(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaToPcieRate_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaToCppRate(_x)  (((_x) & 0xf) << 20)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaToCppRate_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmPcieRate(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmPcieRate_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmPcieIssueLoad(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaFrmPcieIssueLoad_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig1_DmaRateLimitSelect BIT(0)
#define     NFP3800_PCIE_DMA_DMACntrlConfig1_DmaRateLimitSelect_BWRateLimit (0 << 0)
#define     NFP3800_PCIE_DMA_DMACntrlConfig1_DmaRateLimitSelect_IssueRateLimit BIT(0)
/*----------------------------------------------------------------
  Register: DMACntrlConfig2 - DMA Bandwidth configuration, cpp and pcie request bandwidth control
    Bits: 31:28 DmaToCppTh(rw) - Selects the threshold of the rate limiter in 256 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 27:24 DmaToPcieTh(rw) - Selects the threshold of the rate limiter in 512 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 23:20 DmaFrmCppTh(rw) - Selects the threshold of the rate limiter in 512 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 19:16 DmaFrmPcieTh(rw) - Selects the threshold of the rate limiter in 256 byte increments. A value of 0 equals a threshold of 256 bytes. A value of 15 equates to a threshold of 4KB.
    Bits: 14:12 DmaRate(rw) - Controls the number of cycles between credit decrements in all of the Token bucket rate shapers. A value of 0 equates to 1 cycle. A value of 7 equates to 8 cycles.
    Bits: 11:9  DmaToCppCredit(rw) - Controls bandwidth of CPP Reads when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  8:6  DmaToPcieCredit(rw) - Controls bandwidth of PCIe Writes when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  5:3  DmaFrmCppCredit(rw) - Controls bandwidth of CPP Reads when in BWRateLimitMode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
    Bits:  2:0  DmaFrmPcieCredit(rw) - Controls bandwidth of PCIe Reads when in BWRateLimit mode. Equals the number of 8-byte credits + 1 that are decremented every (DmaRate + 1) cycles.
*/
#define NFP3800_PCIE_DMA_DMACntrlConfig2                     0x000000fc
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToCppTh(_x)    (((_x) & 0xf) << 28)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToCppTh_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToPcieTh(_x)   (((_x) & 0xf) << 24)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToPcieTh_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmCppTh(_x)   (((_x) & 0xf) << 20)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmCppTh_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmPcieTh(_x)  (((_x) & 0xf) << 16)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmPcieTh_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaRate(_x)       (((_x) & 0x7) << 12)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaRate_of(_x)    (((_x) >> 12) & 0x7)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToCppCredit(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToCppCredit_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToPcieCredit(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaToPcieCredit_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmCppCredit(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmCppCredit_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmPcieCredit(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_DMACntrlConfig2_DmaFrmPcieCredit_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: DMADescrTPHConfig[8] - Specifies additional DMA configuration information to supplement incoming descriptor, TPH Value and Steering Tag settings.
    Bits: 26    TphCtrlEnaOdd(rw) - When set the TPH Value and associated TPH Steering Tag are used during the all DMA TLPs. When clear the TPH and TPH Steering Tag are not used for DMA TLPs
    Bits: 25:24 TphOdd(rw) - TPH Value used in all DMA TLPs when TphCtrlEnaOdd bit is set.
    Bits: 23:16 TphStOdd(rw) - TPH Steering Tag used in all DMA TLPs when TphCtrlEnaOdd bit is set.
    Bits: 10    TphCtrlEnaEven(rw) - When set the TPH Value and associated TPH Steering Tag are used during the all DMA TLPs. When clear the TPH and TPH Steering Tag are not used for DMA TLPs
    Bits:  9:8  TphEven(rw) - TPH Value used in all DMA TLPs when TphCtrlEnaEven bit is set.
    Bits:  7:0  TphStEven(rw) - TPH Steering Tag used in all DMA TLPs when TphCtrlEnaEven bit is set.
*/
#define NFP3800_PCIE_DMA_DMADescrTPHConfig(_x)               (0x00000100 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphCtrlEnaOdd   BIT(26)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphOdd(_x)      (((_x) & 0x3) << 24)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphOdd_of(_x)   (((_x) >> 24) & 0x3)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphStOdd(_x)    (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphStOdd_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphCtrlEnaEven  BIT(10)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphEven(_x)     (((_x) & 0x3) << 8)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphEven_of(_x)  (((_x) >> 8) & 0x3)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphStEven(_x)   (((_x) & 0xff) << 0)
#define   NFP3800_PCIE_DMA_DMADescrTPHConfig_TphStEven_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: DMAAllocCtrl - Packet Mode DMA Allocatoin Control CSR
    Bits: 22    muPtrOffsetCtrl(rw) - During Split packets - this bit determines the address offset to start DMAing the packet to the Memory unit buffer. This bit must be set to the value used in the NBI NbiCtrl Register for proper operation.
    Bits: 21:20 AllocLookaheadNeg256bCredit(rw) - Threshold to control the number of 256B credits a CTM can use after the buffer credit is negative.
    Bits: 19:18 AllocLookaheadNegBufCredit(rw) - Controls how much the buffer credit can go negative by.
    Bits: 17    AllocLookaheadEna(rw) - Enables the support for packet allocation lookahead.
    Bits: 16    PacketColorEnable(rw) - When set, the DMA engine adds 2-bit packet color in packet mode DMA metadata based on the CTM's credit level.
    Bits: 15    ResetDMAState(rw) - Set this bit to reset DMA Context State registers used in packet mode DMA. This bit will only have an effect after all FromPcie DMA Stop bits are set by software. Software should only set this bit after any inflight DMAs have completed
    Bits: 14    PollRespNoWaitEna(rw) - When set, CTM Polling command responses are processed as they arrive. When cleared, CTM Polling command responses are processed after all outstanding responses have arrived
    Bits: 12    NonDepWrBeatsReadEna(rw) - Allows non dependent writes to pass reads in the CTM bulk Engine. Copied to bit 30 of the CPP address field during Packet Mode DMAs to the CTM
    Bits: 11    DisBdRamErr(rw) - Controls how the BLQ logic handles multi-bit ECC errors received from the Buffer Descriptor RAM
    Bits: 10    DisRxPushLastErr(rw) - Controls how the hardware responds to a push bus input protocol error for allocation response transactions
    Bits:  9    DisRxAllocInErr(rw) - Controls how the hardware responds to a push bus input error for allocation response transactions.
    Bits:  8    DisRxBlqWrInErr(rw) - Controls how the hardware responds to a push bus input error for BLQ writes transactions.
    Bits:  7:5  PCIeNum(rw) - This field is placed in the 3 lsbits of the Packet Allocation Command Address field. It is used by the CTM to identify the source of the command. It must be a different value for each source.
    Bits:  4    CtmPollEna(rw) - Configures whether the polling function is enabled or disabled.
    Bits:  3:2  CtmPollIntvl(rw) - Configures the minimum amount of time between packet allocation poll commands in clock cycles.
    Bits:  1:0  PollCmdIssueRate(rw) - Configures the space between CPP Polling commands issues after the polling interval has expired
*/
#define NFP3800_PCIE_DMA_DMAAllocCtrl                        0x00000120
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_muPtrOffsetCtrl      BIT(22)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_muPtrOffsetCtrl_SplitOffset (0 << 22)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_muPtrOffsetCtrl_NoOffset BIT(22)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit(_x) (((_x) & 0x3) << 20)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit_of(_x) (((_x) >> 20) & 0x3)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit_16 (0)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit_32 (1)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit_48 (2)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNeg256bCredit_64 (3)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit_of(_x) (((_x) >> 18) & 0x3)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit_NONE (0)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit__1 (1)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit__2 (2)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadNegBufCredit__3 (3)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_AllocLookaheadEna    BIT(17)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PacketColorEnable    BIT(16)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_ResetDMAState        BIT(15)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PollRespNoWaitEna    BIT(14)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_NonDepWrBeatsReadEna BIT(12)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_DisBdRamErr          BIT(11)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisBdRamErr_Enable (0 << 11)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisBdRamErr_Disable BIT(11)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxPushLastErr     BIT(10)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxPushLastErr_Enable (0 << 10)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxPushLastErr_Disable BIT(10)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxAllocInErr      BIT(9)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxAllocInErr_Enable (0 << 9)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxAllocInErr_Disable BIT(9)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxBlqWrInErr      BIT(8)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxBlqWrInErr_Enable (0 << 8)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_DisRxBlqWrInErr_Disable BIT(8)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PCIeNum(_x)          (((_x) & 0x7) << 5)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PCIeNum_of(_x)       (((_x) >> 5) & 0x7)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollEna           BIT(4)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollEna_Disable (0 << 4)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollEna_Enable  BIT(4)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl(_x)     (((_x) & 0x3) << 2)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl_of(_x)  (((_x) >> 2) & 0x3)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl_128   (0)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl_256   (1)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl_512   (2)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_CtmPollIntvl_1024  (3)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate_4 (0)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate_8 (1)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate_12 (2)
#define     NFP3800_PCIE_DMA_DMAAllocCtrl_PollCmdIssueRate_16 (3)
/*----------------------------------------------------------------
  Register: DMABlqEvent - DMA Buffer List Queue Event Control
    Bits: 22    ReducedThresh(rw) - If set lowers the blq event thresholds to 4, 8, 16 and 32.
    Bits: 20    DisBLQEventFifoFullAssert(rw) - Set this bit to disable the BLQ Event FIFO overflow assertion
    Bits: 19:18 BLQEventThreshold3(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 17:16 BLQEventThreshold2(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 15:14 BLQEventThreshold1(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits: 13:12 BLQEventThreshold0(rw) - An event is generated every N buffer descriptors written to buffer list queue3, where N is configurable from 16 to 128 or 4 to 32 if Reduced BLQ Threshold is set..
    Bits:  7:4  BLQEventNotFullEnable(rw) - One bit per buffer list queue. Enables the generation of BLQ Events when the queue transitions from full to not full. Disabled when clear. The event type value used is 0x1 (event_type_fifo_not_full)
    Bits:  3:0  BLQEventStatusEnable(rw) - One bit per buffer list queue. Enables BLQ Status Events when set. Disabled when clear. A Status Event is sent when the number of entries read from the queue reaches the programmed value in the BLQEventThreshold register. The event type value used is 0x5 (event_type_value_update)
*/
#define NFP3800_PCIE_DMA_DMABlqEvent                         0x00000124
#define   NFP3800_PCIE_DMA_DMABlqEvent_ReducedThresh         BIT(22)
#define   NFP3800_PCIE_DMA_DMABlqEvent_DisBLQEventFifoFullAssert BIT(20)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3_of(_x) (((_x) >> 18) & 0x3)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3_16_or_4 (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3_32_or_8 (1)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3_64_or_16 (2)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold3_128_or_32 (3)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2_of(_x) (((_x) >> 16) & 0x3)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2_16_or_4 (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2_32_or_8 (1)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2_64_or_16 (2)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold2_128_or_32 (3)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1_of(_x) (((_x) >> 14) & 0x3)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1_16_or_4 (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1_32_or_8 (1)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1_64_or_16 (2)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold1_128_or_32 (3)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0_of(_x) (((_x) >> 12) & 0x3)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0_16_or_4 (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0_32_or_8 (1)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0_64_or_16 (2)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventThreshold0_128_or_32 (3)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventNotFullEnable(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventNotFullEnable_of(_x) (((_x) >> 4) & 0xf)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventNotFullEnable_Disable (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventNotFullEnable_Enable (1)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventStatusEnable(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIE_DMA_DMABlqEvent_BLQEventStatusEnable_of(_x) (((_x) >> 0) & 0xf)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventStatusEnable_Disable (0)
#define     NFP3800_PCIE_DMA_DMABlqEvent_BLQEventStatusEnable_Enable (1)
/*----------------------------------------------------------------
  Register: DMABpeChainEnd - DMA BPE Chain End Register
    Bits: 31:0  BpeChainEnd(rw) - Configures BPE module 'n' as the end of the buffer pool entry chain, where 'n' = 0 to 31.
*/
#define NFP3800_PCIE_DMA_DMABpeChainEnd                      0x00000128
#define   NFP3800_PCIE_DMA_DMABpeChainEnd_BpeChainEnd(_x)    (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMABpeChainEnd_BpeChainEnd_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DMABP[8]Cfg - DMA Buffer Pool X Configuration
    Bits: 24    BlqBypassEna(rw) - When set, selects to use a null buffer descriptor if the packet is not split.
    Bits: 23    BPRsvd(rw) - Reserved, Write to 0
    Bits: 22:19 CtmBufPad(rw) - Selects the number of 32 bytes to add to the allocation size of the packet. Allows padding to the allocated space in the CTM for smaller packets in increments of 32B. 0=32B, 1=64B, 0xf=512B.
    Bits: 18    CtmBufPadEna(rw) - Enables adding CtmBufPad bytes to the allocation size of the packet.
    Bits: 17:15 CtmOffsetMsb(rw) - This field represents the MSbits of CtmOffset and defines the offset to add to the data reference when starting to write packet data to the CTM. The space in front of the packet is for the rewrite script used by the packet modifier. Encoding of {CtmOffsetMsb[3;0],CtmOffset} are: 0000 = 32B, 0001=64B, 0010=96B, 0011 = 128B, 0100 = 160B, ... 1111 = 512B
    Bits: 13    CtmOffset(rw) - This field contains the LSbit of CtmOffset. See description of CtmOffsetMsb.
    Bits: 12:11 PriBList(rw) - Primary Buffer list number associated. There are 4 buffer lists available, which contain buffer descriptors that are used to store packet data in internal/external MUs.
    Bits: 10:9  SecBList(rw) - Secondary Buffer list number associated. There are 4 buffer lists available, which contain buffer descriptors that are used to store packet data in internal/external MUs.
    Bits:  8:5  SplitLength(rw) - Encoded packet size used when deciding to split packets between CTM and internal/external MUs. Values 7,12-15 are reserved
    Bits:  4:0  BpeHead(rw) - Pointer to the first Buffer Pool Entry register in the list associated with this buffer pool.
*/
#define NFP3800_PCIE_DMA_DMABPCfg(_x)                        (0x00000130 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMABPCfg_BlqBypassEna             BIT(24)
#define   NFP3800_PCIE_DMA_DMABPCfg_BPRsvd                   BIT(23)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmBufPad(_x)            (((_x) & 0xf) << 19)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmBufPad_of(_x)         (((_x) >> 19) & 0xf)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmBufPadEna             BIT(18)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmOffsetMsb(_x)         (((_x) & 0x7) << 15)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmOffsetMsb_of(_x)      (((_x) >> 15) & 0x7)
#define   NFP3800_PCIE_DMA_DMABPCfg_CtmOffset                BIT(13)
#define   NFP3800_PCIE_DMA_DMABPCfg_PriBList(_x)             (((_x) & 0x3) << 11)
#define   NFP3800_PCIE_DMA_DMABPCfg_PriBList_of(_x)          (((_x) >> 11) & 0x3)
#define   NFP3800_PCIE_DMA_DMABPCfg_SecBList(_x)             (((_x) & 0x3) << 9)
#define   NFP3800_PCIE_DMA_DMABPCfg_SecBList_of(_x)          (((_x) >> 9) & 0x3)
#define   NFP3800_PCIE_DMA_DMABPCfg_SplitLength(_x)          (((_x) & 0xf) << 5)
#define   NFP3800_PCIE_DMA_DMABPCfg_SplitLength_of(_x)       (((_x) >> 5) & 0xf)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_256        (0)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_512        (1)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_1K         (2)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_2K         (3)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_4K         (4)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_8K         (5)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_16K        (6)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_6K         (8)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_10K        (9)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_12K        (10)
#define     NFP3800_PCIE_DMA_DMABPCfg_SplitLength_14K        (11)
#define   NFP3800_PCIE_DMA_DMABPCfg_BpeHead(_x)              (((_x) & 0x1f) << 0)
#define   NFP3800_PCIE_DMA_DMABPCfg_BpeHead_of(_x)           (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: BLQueCtrl0Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl0Lo                        0x00000150
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLEntryCntLo(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLEntryCntLo_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLHdPtr(_x)          (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLHdPtr_of(_x)       (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLTlPtr(_x)          (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Lo_BLTlPtr_of(_x)       (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl0Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl0Hi                        0x00000154
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQEventFullCnt(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQEventFullCnt_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BDFifoEntryCnt(_x)   (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BDFifoEntryCnt_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQFull              BIT(7)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQEmpty             BIT(6)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize(_x)          (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize_of(_x)       (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize_256        (0)
#define     NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize_512        (1)
#define     NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize_1K         (2)
#define     NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLQSize_2K         (3)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLEntryCntHi(_x)     (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl0Hi_BLEntryCntHi_of(_x)  (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl1Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl1Lo                        0x00000158
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLEntryCntLo(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLEntryCntLo_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLHdPtr(_x)          (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLHdPtr_of(_x)       (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLTlPtr(_x)          (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Lo_BLTlPtr_of(_x)       (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl1Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl1Hi                        0x0000015c
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQEventFullCnt(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQEventFullCnt_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BDFifoEntryCnt(_x)   (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BDFifoEntryCnt_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQFull              BIT(7)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQEmpty             BIT(6)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize(_x)          (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize_of(_x)       (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize_256        (0)
#define     NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize_512        (1)
#define     NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize_1K         (2)
#define     NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLQSize_2K         (3)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLEntryCntHi(_x)     (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl1Hi_BLEntryCntHi_of(_x)  (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl2Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl2Lo                        0x00000160
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLEntryCntLo(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLEntryCntLo_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLHdPtr(_x)          (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLHdPtr_of(_x)       (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLTlPtr(_x)          (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Lo_BLTlPtr_of(_x)       (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl2Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl2Hi                        0x00000164
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQEventFullCnt(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQEventFullCnt_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BDFifoEntryCnt(_x)   (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BDFifoEntryCnt_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQFull              BIT(7)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQEmpty             BIT(6)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize(_x)          (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize_of(_x)       (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize_256        (0)
#define     NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize_512        (1)
#define     NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize_1K         (2)
#define     NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLQSize_2K         (3)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLEntryCntHi(_x)     (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl2Hi_BLEntryCntHi_of(_x)  (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BLQueCtrl3Lo - Configures the buffer list circular queue and provides status
    Bits: 31:24 BLEntryCntLo(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
    Bits: 22:12 BLHdPtr(rw) - Buffer List Queue Head Pointer. Points to the next entry to be read by hardware.
    Bits: 10:0  BLTlPtr(rw) - Buffer List Queue Tail Pointer. Points to the next entry to be written at the tail.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl3Lo                        0x00000168
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLEntryCntLo(_x)     (((_x) & 0xff) << 24)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLEntryCntLo_of(_x)  (((_x) >> 24) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLHdPtr(_x)          (((_x) & 0x7ff) << 12)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLHdPtr_of(_x)       (((_x) >> 12) & 0x7ff)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLTlPtr(_x)          (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Lo_BLTlPtr_of(_x)       (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: BLQueCtrl3Hi - Configures the buffer list circular queue and provides status
    Bits: 23:16 BLQEventFullCnt(rc) - Debug counter that increments when a BLQ Event is dropped due to a full BLQ Event FIFO. This counter saturates at all 1's
    Bits: 10:8  BDFifoEntryCnt(ro) - Number of buffer descriptors resident in the buffer descriptor register FIFO
    Bits:  7    BLQFull(ro) - The Queue is full when set.
    Bits:  6    BLQEmpty(ro) - The queue is empty when set.
    Bits:  5:4  BLQSize(rw) - Defines the Size of the Circular Buffer List Queue
    Bits:  2:0  BLEntryCntHi(ro) - Hardware calculated value of the number of entries on the Buffer List Queue. A full Buffer List Queue has an entry count equal to zero, with the BLQFull flag set. An empty Buffer List Queue has an entry count equal to zero with the BLQEmpty flag set.
*/
#define NFP3800_PCIE_DMA_BLQueCtrl3Hi                        0x0000016c
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQEventFullCnt(_x)  (((_x) & 0xff) << 16)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQEventFullCnt_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BDFifoEntryCnt(_x)   (((_x) & 0x7) << 8)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BDFifoEntryCnt_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQFull              BIT(7)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQEmpty             BIT(6)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize(_x)          (((_x) & 0x3) << 4)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize_of(_x)       (((_x) >> 4) & 0x3)
#define     NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize_256        (0)
#define     NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize_512        (1)
#define     NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize_1K         (2)
#define     NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLQSize_2K         (3)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLEntryCntHi(_x)     (((_x) & 0x7) << 0)
#define   NFP3800_PCIE_DMA_BLQueCtrl3Hi_BLEntryCntHi_of(_x)  (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: BlqNullMuPtr - Value to use in MuPtr field when bypassing the BLQ in packet mode DMAs
    Bits: 28:0  BlqNullMuPtr(rw) - Programmable Null Memory Buffer Pointer.
*/
#define NFP3800_PCIE_DMA_BlqNullMuPtr                        0x00000174
#define   NFP3800_PCIE_DMA_BlqNullMuPtr_BlqNullMuPtr(_x)     (((_x) & 0x1fffffff) << 0)
#define   NFP3800_PCIE_DMA_BlqNullMuPtr_BlqNullMuPtr_of(_x)  (((_x) >> 0) & 0x1fffffff)
/*----------------------------------------------------------------
  Register: PcieDmaRsvd[2] - Reserved
*/
#define NFP3800_PCIE_DMA_PcieDmaRsvd(_x)                     (0x00000178 + (0x4 * ((_x) & 0x1)))
/*----------------------------------------------------------------
  Register: DMABpe[32]Cfg - DMA Buffer Pool Entry X Configuration
    Bits: 31:27 BpeNum(rwl) - Buffer Pool Entry Number. When the register is written this value is the latched version of the buffer pool register number 0-31. Used for debug purposes.
    Bits: 26:21 Ctm(rw) - CTM number to use
    Bits: 20:10 PktCredit(rw) - Configures the number of packets allocated to the CTM
    Bits:  9:0  BufCredit(rw) - Configures the number of buffer credits in 2K byte increments associated with the CTM. The msbit is the sign bit and must be cleared during configuration.
*/
#define NFP3800_PCIE_DMA_DMABpeCfg(_x)                       (0x00000180 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIE_DMA_DMABpeCfg_BpeNum(_x)              (((_x) & 0x1f) << 27)
#define   NFP3800_PCIE_DMA_DMABpeCfg_BpeNum_of(_x)           (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIE_DMA_DMABpeCfg_Ctm(_x)                 (((_x) & 0x3f) << 21)
#define   NFP3800_PCIE_DMA_DMABpeCfg_Ctm_of(_x)              (((_x) >> 21) & 0x3f)
#define   NFP3800_PCIE_DMA_DMABpeCfg_PktCredit(_x)           (((_x) & 0x7ff) << 10)
#define   NFP3800_PCIE_DMA_DMABpeCfg_PktCredit_of(_x)        (((_x) >> 10) & 0x7ff)
#define   NFP3800_PCIE_DMA_DMABpeCfg_BufCredit(_x)           (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_DMA_DMABpeCfg_BufCredit_of(_x)        (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: DMAPmHeader[16]_DMAPMHeaderLo - Used to populate various packet mode meta-data fields
    Bits: 31:0  PMHeaderDataLo(rw) - Used to populate various packet mode meta-data fields
*/
#define NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderLo(_x)       (0x00000200 + (0x8 * ((_x) & 0xf)))
#define   NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderLo_PMHeaderDataLo(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderLo_PMHeaderDataLo_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: DMAPmHeader[16]_DMAPMHeaderHi - Used to populate various packet mode meta-data fields
    Bits: 31:0  PMHeaderDataHi(rw) - Used to populate various packet mode meta-data fields
*/
#define NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderHi(_x)       (0x00000204 + (0x8 * ((_x) & 0xf)))
#define   NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderHi_PMHeaderDataHi(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIE_DMA_DMAPmHeader_DMAPMHeaderHi_PMHeaderDataHi_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: AbortStatus[8] - DMA Packet Mode Abort Status Register for DMA Context N and N + 1 where N = X
    Bits: 31:23 PckNumOdd(ro) - Latched packet number of an aborted packet. Only valid when the Valid field is set in this register.
    Bits: 22:17 CtmOdd(ro) - Latched CTM number of an aborted packet, Only valid when the Valid field is set in this register.
    Bits: 16    ValidOdd(rw1c) - When set the contents of this register contain the MuPtr, CTM number and packet number of an aborted packet.
    Bits: 15:7  PckNumEven(ro) - Latched packet number of an aborted packet. Only valid when the Valid field is set in this register.
    Bits:  6:1  CtmEven(ro) - Latched CTM number of an aborted packet, Only valid when the Valid field is set in this register.
    Bits:  0    ValidEven(rw1c) - When set the contents of this register contain the MuPtr, CTM number and packet number of an aborted packet.
*/
#define NFP3800_PCIE_DMA_AbortStatus(_x)                     (0x00000280 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_AbortStatus_PckNumOdd(_x)         (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIE_DMA_AbortStatus_PckNumOdd_of(_x)      (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIE_DMA_AbortStatus_CtmOdd(_x)            (((_x) & 0x3f) << 17)
#define   NFP3800_PCIE_DMA_AbortStatus_CtmOdd_of(_x)         (((_x) >> 17) & 0x3f)
#define   NFP3800_PCIE_DMA_AbortStatus_ValidOdd              BIT(16)
#define   NFP3800_PCIE_DMA_AbortStatus_PckNumEven(_x)        (((_x) & 0x1ff) << 7)
#define   NFP3800_PCIE_DMA_AbortStatus_PckNumEven_of(_x)     (((_x) >> 7) & 0x1ff)
#define   NFP3800_PCIE_DMA_AbortStatus_CtmEven(_x)           (((_x) & 0x3f) << 1)
#define   NFP3800_PCIE_DMA_AbortStatus_CtmEven_of(_x)        (((_x) >> 1) & 0x3f)
#define   NFP3800_PCIE_DMA_AbortStatus_ValidEven             BIT(0)
/*----------------------------------------------------------------
  Register: DMABP[8]CtmCrThresh - NBI DMA Buffer Pool CTM Credit Thresholds.
    Bits: 29:20 Threshold2(rw) - Configures Threshold2 for the CTM credits. The packet color value is 2b11 if: credit < Threshold2. Only lower 9 bits are used, the top bit should be cleared.
    Bits: 19:10 Threshold1(rw) - Configures Threshold1 for the CTM credits. The packet color value is 2b10 if: Threshold2 <= credit < Threshold1. Only lower 9 bits are used, the top bit should be cleared.
    Bits:  9:0  Threshold0(rw) - Configures Threshold0 for the CTM credits. The packet color value is 2b01 if : Threshold1 <= credit < Threshold0, else it remains 2b00 if credit >= Threshold0. Only lower 9 bits are used, the top bit should be cleared.
*/
#define NFP3800_PCIE_DMA_DMABPCtmCrThresh(_x)                (0x000002a0 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold2(_x)   (((_x) & 0x3ff) << 20)
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold2_of(_x) (((_x) >> 20) & 0x3ff)
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold1(_x)   (((_x) & 0x3ff) << 10)
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold1_of(_x) (((_x) >> 10) & 0x3ff)
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold0(_x)   (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIE_DMA_DMABPCtmCrThresh_Threshold0_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: DMATotalCreditCnt - Buffer Allocation Total Packet and Buffer Credits in use counters
    Bits: 31:16 TotalPktCredit(rw1c) - Contains the total number of packet credits in use by the DMA buffer allocation logic
    Bits: 15:0  TotalBufCredit(rw1c) - Contains the total number of buffer credits in use by the DMA buffer allocation logic
*/
#define NFP3800_PCIE_DMA_DMATotalCreditCnt                   0x000002c0
#define   NFP3800_PCIE_DMA_DMATotalCreditCnt_TotalPktCredit(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIE_DMA_DMATotalCreditCnt_TotalPktCredit_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIE_DMA_DMATotalCreditCnt_TotalBufCredit(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_DMA_DMATotalCreditCnt_TotalBufCredit_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: DMAChksSumEna - Enable per Packet Mode DMA Context to calculate packet checksum
    Bits: 15:0  DMAChksumEna(rw) - There are 16-bits of DMAChksumEna, selected by the DMA Context of the Packet mode DMA. Set this bit to enable calculation of packet checksum. Clear this bit to disable checksum calculation
*/
#define NFP3800_PCIE_DMA_DMAChksSumEna                       0x000002c4
#define   NFP3800_PCIE_DMA_DMAChksSumEna_DMAChksumEna(_x)    (((_x) & 0xffff) << 0)
#define   NFP3800_PCIE_DMA_DMAChksSumEna_DMAChksumEna_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeCompConfig0 - Configures operation mode for PCIe component
    Bits: 30    QctlOneShotEnable(rw) - Automatically disable all notifications after the first event or RingPut, i.e. a one-shot mode
    Bits: 29    QctlCppCmdBusPrefDis(rw) - Disable the Qctl CLS Ring selection of the CPP Master Command Bus preference. When enabled, even CLS Ring Put requests will go out on Cmd Bus A/0, odd uses Cmd Bus B/1.
    Bits: 28    PCIeTargetComplIdEn(rw) - When set PCIe Target overrides Completer ID
    Bits: 25    PcietCppCmdBusPrefDis(rw) - Disable the PCIe Target Expansion BAR selection of the CPP Master Command Bus preference. When enabled, even Expansion BAR requests will go out on Cmd Bus A/0, odd uses Cmd Bus B/1.
    Bits: 24    ClrPciemHalmAriError(w1c) - Write 1 to clear the VF ARI Error status reg in PCIe Master
    Bits: 23    ClrDmaAriError(w1c) - Write 1 to clear the VF ARI Error status reg in DMA
    Bits: 22:20 PciemDMASramReadCredit(rw) - Sets the outstanding number of DMA reads to SRAM in increments of 8 with a starting offset of 7. Setting the value above 3 has no effect as the hardware limit of the credit tracker is set to 32. The minimum value of 0 equates to a credit limit of 7 requests.
    Bits: 19:12 PciemPciReadCredit(rw) - Controls the amout of outstanding PCIe read requests that can be issued. Value is in increments of 256 bytes. The minimum value that should be used is 4KB or 16(dec).
    Bits: 10    RC_mode_IO_CFG_write_CPL_rec(rw1c) - Pcie completed IO or Config Write operation.
    Bits:  9    Pcie_Msix_Pba_Debug(rw) - Provide ability to override read only behavior and temporarily allow write access of MSI-X PBA structure from the PCIe link for debug purpose only
    Bits:  7    PcieTrapDropped(w1c) - Indicates a trap request has been dropped due to exceeding size of targeted WorkQ spec'd by selected ExpBAR LengthSelect field.
    Bits:  6    PcieTrapTimeout(w1c) - Indicates that a trap read request has not completed in the amount of time spec'd by PcieTrapTypeTimeout register.
    Bits:  5:4  PcieTagCtrl(rw) - Controls the number of tags used for Master requests.
    Bits:  3    PciemWriteStatsEn(rw) - Enables the PCIe Master to count write data transmit cycles
    Bits:  2    PciemReadStatsEn(rw) - Enables the PCIe Master to count read data receive cycles
    Bits:  1    PcieCompConfig0Rsvd(rw) - Reserved. Software must write this bit to 0.
    Bits:  0    CPPAddrMode(rw) - Configure whether to interpret the CPP address bits as 32-bit or 40-bit.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCompConfig0                0x00000000
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_QctlOneShotEnable BIT(30)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_QctlCppCmdBusPrefDis BIT(29)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PCIeTargetComplIdEn BIT(28)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcietCppCmdBusPrefDis BIT(25)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_ClrPciemHalmAriError BIT(24)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_ClrDmaAriError BIT(23)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemDMASramReadCredit(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemDMASramReadCredit_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemPciReadCredit(_x) (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemPciReadCredit_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_RC_mode_IO_CFG_write_CPL_rec BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_Pcie_Msix_Pba_Debug BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTrapDropped BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTrapTimeout BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTagCtrl(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTagCtrl_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTagCtrl_DEFAULT (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTagCtrl_32TAGS (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieTagCtrl_16TAGS (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemWriteStatsEn BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PciemReadStatsEn BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_PcieCompConfig0Rsvd BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_CPPAddrMode  BIT(0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_CPPAddrMode_40 (0 << 0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig0_CPPAddrMode_32 BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCompConfig1 - Configures operation mode for PCIe component
    Bits: 31:24 PCIeTargetComplIdBus(rw) - Sets the Completer ID Bus number to be used when in RC Mode or when override set
    Bits: 23:16 PCIeTargetComplIdDevFunc(rw) - Sets the Completer ID Dev and Function numbers to be used when in RC Mode or when override set
    Bits: 15:8  PCIeMasterReqIdBus(rw) - Sets the Requester ID Bus number to be used when PCIe Master generates requests in RC Mode
    Bits:  7:0  PCIeMasterReqIdFunc(rw) - Sets the Requester ID Function number to be used when PCIe Master generates requests in RC Mode
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCompConfig1                0x00000004
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeTargetComplIdBus(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeTargetComplIdBus_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeTargetComplIdDevFunc(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeTargetComplIdDevFunc_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeMasterReqIdBus(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeMasterReqIdBus_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeMasterReqIdFunc(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig1_PCIeMasterReqIdFunc_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCompConfig2 - Configures operation mode for PCIe component
    Bits: 28:24 CppTargetSramReadCredit(rw) - Sets the number of outstanding read requests the CPP Target can make to the shared SRAM
    Bits: 10    CpptDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the CPP Target push data bus.
    Bits:  9    CpptDisPullDataError(rw) - When set data errors received from the CPP Target Pull Data bus are not forwarded to the internal target or PCIE Master Interface.
    Bits:  8    PciemDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the PCIE Master Interface.
    Bits:  7    PciemDisHalDataError(rw) - When set data errors received from the HAL interface are not forwarded to the internal target or CPP Target.
    Bits:  6    PcietDisIntDataError(rw) - When set data errors received from the internal target are not forwarded to the PCIE Target HAL interface.
    Bits:  5    PcietDisHalDataError(rw) - When set data errors received from the HAL interface are not forwarded to the CPP Master interface or internal target
    Bits:  4:0  PcieTargetSramReadCredit(rw) - Sets the number of outstanding read requests the PCIe Target can make to the shared SRAM
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCompConfig2                0x00000008
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_CppTargetSramReadCredit(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_CppTargetSramReadCredit_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_CpptDisIntDataError BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_CpptDisPullDataError BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PciemDisIntDataError BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PciemDisHalDataError BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PcietDisIntDataError BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PcietDisHalDataError BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PcieTargetSramReadCredit(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig2_PcieTargetSramReadCredit_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeCompConfig3 - Configures operation mode for PCIe component
    Bits: 31:24 DmaAriInError(ro) - DMA ARI number that last had an error
    Bits: 23:21 PciemHalComplCode(ro) - PCIe Master HAL Completion code that is latched when PciemAccessError is asserted
    Bits: 20    DmaFromAccessErrorVf(ro) - DMA FromPCIe Virtual Function Access Error.
    Bits: 19    DmaFromAccessErrorPf(ro) - DMA FromPCIe Physical Function Access Error.
    Bits: 18    DmaFromDescrOvflHi(ro) - DMA FromPcie High Priority Descriptor Queue Overflow.
    Bits: 17    DmaFromDescrOvflMed(ro) - DMA FromPcie Medium Priority Descriptor Queue Overflow.
    Bits: 16    DmaFromDescrOvflLo(ro) - DMA FromPcie Low Priority Descriptor Queue Overflow.
    Bits: 15    CppmIoArbMode(rw) - When set, changes arb scheme for granting internal IO device requests btwn CPP Target and PCIe Target from 75/25 to 50/50.
    Bits: 14    DmaToAccessErrorVf(ro) - DMA ToPCIe Virtual Function Access Error.
    Bits: 13    DmaToAccessErrorPf(ro) - DMA ToPCIe Physical Function Access Error.
    Bits: 12    DmaToDescrOvflHi(ro) - DMA ToPcie High Priority Descriptor Queue Overflow.
    Bits: 11    DmaToDescrOvflMed(ro) - DMA ToPcie Medium Priority Descriptor Queue Overflow.
    Bits: 10    DmaToDescrOvflLo(ro) - DMA ToPcie Low Priority Descriptor Queue Overflow.
    Bits:  9    PcietVfQctlRangeErr(rw1c) - PCIE Target VF Qctl access Que Out of Range w.r.t. CfgLUT entry.
    Bits:  8    CpptAccessError(rw1c) - Cpp Target Access Error Status bit indicates error received over the CPP intf.
    Bits:  7    MsixPfMaskChanged(rw1c) - Indicates that a PF MSI-X mask bit changed. SW should check the MSI-X PF Mask Changed Status register.
    Bits:  6    CpptPullDataError(rw1c) - Cpp Target Pull Data Error status bit indicates an error was received on the CPP Pull data interface
    Bits:  5    PciemAccessError(rw1c) - Pcie Master Access Error Status bit indicates access error received from the link.
    Bits:  4    PcietVfCfgLutInitErr(rw1c) - PCIE Target VF access through uninitialized CfgLUT Entry.
    Bits:  3    PciemHalDataError(rw1c) - PCIE Master detected a data error from the HAL interface.
    Bits:  2    PcietAccessError(rw1c) - Pcie Target Access Error Status bit indicates access error received from the link.
    Bits:  1    MsixVectorChangeStatus(rw1c) - Indicates that the MSI-X Vector Table has been updated. SW should check the MSI-X Vector Change Summary register.
    Bits:  0    PcietHalDataError(rw1c) - PCIE Target detected a data error from the HAL interface
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCompConfig3                0x0000000c
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaAriInError(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaAriInError_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PciemHalComplCode(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PciemHalComplCode_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaFromAccessErrorVf BIT(20)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaFromAccessErrorPf BIT(19)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaFromDescrOvflHi BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaFromDescrOvflMed BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaFromDescrOvflLo BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_CppmIoArbMode BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaToAccessErrorVf BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaToAccessErrorPf BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaToDescrOvflHi BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaToDescrOvflMed BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_DmaToDescrOvflLo BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PcietVfQctlRangeErr BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_CpptAccessError BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_MsixPfMaskChanged BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_CpptPullDataError BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PciemAccessError BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PcietVfCfgLutInitErr BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PciemHalDataError BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PcietAccessError BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_MsixVectorChangeStatus BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig3_PcietHalDataError BIT(0)
/*----------------------------------------------------------------
  Register: PcieRxMsgInt - PCIe Received Message Interrupts and Masks.
    Bits: 18    PcieSSPwrMsgIntMask(rw) - Set to mask PcieSSPwrMsgValid Interrupt.
    Bits: 17    PciePMEMsgIntMask(rw) - Set to mask PciePMEPwrMsgValid Interrupt.
    Bits: 16    PcieVMsgIntMask(rw) - Set to mask PciePwrVMsgValid Interrupt.
    Bits:  2    PcieSSPwrMsgValid(rw1c) - Interrupt status bit that indicates a PCIe Set Slot Power message has been received. The message is stored in the PcieSSPwrMsgHeader0-3 and PcieSSPwrMsgData CSRs.
    Bits:  1    PciePMEMsgValid(rw1c) - Interrupt status bit that indicates a PCIe PME message has been received. The message is stored in the PciePMEMsgHeader0-3 CSRs.
    Bits:  0    PcieVMsgValid(rw1c) - Interrupt status bit that indicates a PCIe vendor defined message has been received. The message is stored in the PcieVendorMsgHeader and PcieVendorMsgData CSRs.
*/
#define NFP3800_PCIEX_COMPCFG_PcieRxMsgInt                   0x00000010
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PcieSSPwrMsgIntMask BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PciePMEMsgIntMask BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PcieVMsgIntMask BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PcieSSPwrMsgValid BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PciePMEMsgValid BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PcieRxMsgInt_PcieVMsgValid   BIT(0)
/*----------------------------------------------------------------
  Register: PCIePciemStatTotal - Status of total cycle count since stats enable in PCIe Master interface
  Register: PCIePciemStatWrite - Status of write data cycle count since stats enable in PCIe Master interface
  Register: PCIePciemStatRead - Status of read data cycle count since stats enable in PCIe Master interface
    Bits: 31:0  PCIePciemStat(ro) - General use register.
*/
#define NFP3800_PCIEX_COMPCFG_PCIePciemStatTotal             0x00000018
#define NFP3800_PCIEX_COMPCFG_PCIePciemStatWrite             0x0000001c
#define NFP3800_PCIEX_COMPCFG_PCIePciemStatRead              0x00000020
#define   NFP3800_PCIEX_COMPCFG_PCIePciemStat_PCIePciemStat(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIePciemStat_PCIePciemStat_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeFrmPcieDwrrArbCtrl - Control of From PCIe DMA DWRR Arbitration for selection of CPP port and Bus
    Bits: 28    BusGteArbDis(rw) - Set to disable selection of bus with greatest credit value
    Bits: 27    BusSelect(rw) - Controls which bus DWRR arbiter is selected when writing to configure DWRR weights. There are two Bus DWRR arbiters, one per port. Each port's bus DWRR arbiter selects between bus a/b for that port.
    Bits: 26    BusDwrrDisable(rw) - When set, the DWRR arbitration is disabled for both bus A and B selection. When clear, the DWRR weights are used to proportionaly control the arbitration process. This bit controls the disable for both port's bus select DWRR arbiters.
    Bits: 25    BusDwrrLoad(w1c) - When set the value of BusDwrrWrData is loaded into the selected credit allotment register. This bit self clears.
    Bits: 24    BusDwrrSelect(rw) - Used to select 1 of the 2 credit allotment registers
    Bits: 23:16 BusDwrrWrData(rw) - Controls the value written to the selected credit allotment register in the Bus select DWRR arbiter.
    Bits: 14    PortGteArbDis(rw) - Set to disable selection of port with greatest or equal credit value
    Bits: 13    PortDwrrDisable(rw) - When set, the DWRR arbitration is disabled for CPP port selection. When clear, the DWRR weights are used to proportionaly control the arbitration process.
    Bits: 12    PortDwrrLoad(w1c) - When set the value of BusDwrrWrData is loaded into the selected credit allotment register. This bit self clears.
    Bits: 11    PortDwrrSelect(rw) - Used to select 1 of the 2 credit allotment registers
    Bits: 10:0  PortDwrrWrData(rw) - Controls the value written to the selected credit allotment register in the Port select DWRR arbiter.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl         0x00000024
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusGteArbDis BIT(28)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusSelect BIT(27)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusDwrrDisable BIT(26)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusDwrrLoad BIT(25)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusDwrrSelect BIT(24)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusDwrrWrData(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_BusDwrrWrData_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortGteArbDis BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortDwrrDisable BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortDwrrLoad BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortDwrrSelect BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortDwrrWrData(_x) (((_x) & 0x7ff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeFrmPcieDwrrArbCtrl_PortDwrrWrData_of(_x) (((_x) >> 0) & 0x7ff)
/*----------------------------------------------------------------
  Register: PCIeARIError0 - Status of Virtual Functions that had errors
  Register: PCIeARIError1 - Status of Virtual Functions that had errors
  Register: PCIeARIError2 - Status of Virtual Functions that had errors
  Register: PCIeARIError3 - Status of Virtual Functions that had errors
  Register: PCIeARIError4 - Status of Virtual Functions that had errors
  Register: PCIeARIError5 - Status of Virtual Functions that had errors
  Register: PCIeARIError6 - Status of Virtual Functions that had errors
  Register: PCIeARIError7 - Status of Virtual Functions that had errors
    Bits: 31:0  PCIeAriErr(rw1c) - ARI Error status.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeARIError0                  0x00000028
#define NFP3800_PCIEX_COMPCFG_PCIeARIError1                  0x0000002c
#define NFP3800_PCIEX_COMPCFG_PCIeARIError2                  0x00000030
#define NFP3800_PCIEX_COMPCFG_PCIeARIError3                  0x00000034
#define NFP3800_PCIEX_COMPCFG_PCIeARIError4                  0x00000038
#define NFP3800_PCIEX_COMPCFG_PCIeARIError5                  0x0000003c
#define NFP3800_PCIEX_COMPCFG_PCIeARIError6                  0x00000040
#define NFP3800_PCIEX_COMPCFG_PCIeARIError7                  0x00000044
#define   NFP3800_PCIEX_COMPCFG_PCIeAriErr_PCIeAriErr(_x)    (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeAriErr_PCIeAriErr_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcietVFerror - Pcie target VF access error
    Bits:  7:0  PcietVFerror(ro) - Pcie target VF access error function number
*/
#define NFP3800_PCIEX_COMPCFG_PcietVFerror                   0x0000005c
#define   NFP3800_PCIEX_COMPCFG_PcietVFerror_PcietVFerror(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcietVFerror_PcietVFerror_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCntrlrConfig0 - Selects operation mode for PCIe DMA controller and PCIe Master Interface
    Bits: 31:26 DmaSplitWrite512Thresh(rw) - When DmaSplitWrite512Addr=0, and DMA Length > (DmaSplitWrite512Thresh*64B + 64B), split the DMA write requests when the PCIe address crosses a 512 byte address boundary, else split write requests when the PCIe address crosses a 4K address boundary (max transfer size is 512B). If this field is 0, then DMA write splitting is controlled by DmaSplitWrite512Addr.
    Bits: 25:20 DmaSplitReadMrrsThresh(rw) - When DmaSplitReadMrrsAddr=0, and DMA Length > (DmaSplitReadMrrsThresh*64B + 64B), split the DMA read requests when the PCIe address crosses a max read request sized address boundary, else split read requests when the PCIe address crosses a 4K address boundary (max read request is controlled by MRRS). If this field is 0, then DMA read splitting is controlled by DmaSplitReadMrrsAddr.
    Bits: 19    DmaSplitWrite512Addr(rw) - Setting this bit forces the ToPCIe DMA engine to split write requests when the PCIe Address crosses a 512 byte address boundary. When clear the ToPCIe DMA engine splits write requests when the PCIe address crosses a 4K address boundry else the size is a max of 512 bytes. Note: The PCIe controller splits 512B writes into MPS sized writes.
    Bits: 18    DmaSplitReadMrrsAddr(rw) - Setting this bit forces the FromPCIe DMA engine to split read requests when the PCIe address crosses a max read request sized address boundary. When clear the FromPCIe DMA engine splits read requests when the PCIe address crosses a 4K address boundary.
    Bits: 17    DmaDisBpCreditChk(rw) - Setting this bit disabled the DMA logic from checking a buffer pools credits prior to allowing a DMA Packet Mode Start Stage Descriptor from being processed. Normally this bit should be cleared as this check prevents buffer pools with low credits from blocking non packet mode DMAs from higher priority queues from being processed. This bit only effects the FromPCIe DMA engine
    Bits: 16    DmaFragSize2kOvrd(rw) - Setting this bit enables 2KB fragment size with DmaFragThreshold = 2KB or 3KB
    Bits: 15    DmaFragDisAlignFrmPcie(rw) - Setting this bit disables aligning FromPCIe 1st DMA Fragments PCIe address to the DmaFragSize address boundary.
    Bits: 14    DmaFragDisAlignToPcie(rw) - Setting this bit disables aligning ToPCIe 1st DMA Fragments PCIe address to the DmaFragSize address boundary.
    Bits: 13:12 DmaFragThreshold(rw) - Threshold at which DMAs are fragmented.
    Bits: 11    DmaFragSize(rw) - Sets the fragment size of the DMA.
    Bits: 10    DmaFragEnableFrmPcie(rw) - Setting this bit enabled the DMA engine to fragment FrmPCIe (Reads) DMAs larger than the DmaMaxFragSize setting.
    Bits:  9    DmaFragEnableToPcie(rw) - Setting this bit enabled the DMA engine to fragment ToPCIe (Writes) DMAs larger than the DmaMaxFragSize setting.
    Bits:  8    DmaFragEnablePacketMode(rw) - Setting this bit along with the DmaFragEnableFrmPcie bit enables FromPcie Packet Mode DMAs to be fragmented. Clearing this bit disables packet mode DMAs from being fragmented.
    Bits:  6    MasterHoldIfDisabled(rw) - When in Endpoint mode, the PCIe Master logic hold back all PCIe Master transactions when this bit is set and the FUNCTION_STATUS bit 2 from the PCIe core indicates the Bus Master is not enabled. The MasterDropIfDisabled must also be cleared.
    Bits:  4    MasterDropIfDisabled(rw) - When in Endpoint mode, the PCIe Master logic drops all PCIe Master transactions when this bit is set and the FUNCTION_STATUS bit 2 from the PCIe core indicates the Bus Master is not enabled. This bit has no effect in Root Complex mode.
    Bits:  0    ChksumByteSwapEn(rw) - Set this bit to byte swap the checksum data
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0              0x00000060
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitWrite512Thresh(_x) (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitWrite512Thresh_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitReadMrrsThresh(_x) (((_x) & 0x3f) << 20)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitReadMrrsThresh_of(_x) (((_x) >> 20) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitWrite512Addr BIT(19)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaSplitReadMrrsAddr BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaDisBpCreditChk BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragSize2kOvrd BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragDisAlignFrmPcie BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragDisAlignToPcie BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragThreshold(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragThreshold_of(_x) (((_x) >> 12) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragThreshold_1KB (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragThreshold_2KB (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragThreshold_3KB (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragSize BIT(11)
#define     NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragSize_512 (0 << 11)
#define     NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragSize_1K BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragEnableFrmPcie BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragEnableToPcie BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_DmaFragEnablePacketMode BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_MasterHoldIfDisabled BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_MasterDropIfDisabled BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIeCntrlrConfig0_ChksumByteSwapEn BIT(0)
/*----------------------------------------------------------------
  Register: QueueRingCfg_[8] - Queue Controller registers to define RingPut operation upon queue status change
    Bits: 31:26 RingClsIsl(rw) - CLS Island ID for Ring Op
    Bits: 25:22 RingSigMaster(rw) - CPP Signal Master to send for CLS Ring Op
    Bits: 21:15 RingSigRef(rw) - CPP Signal Ref to send for CLS Ring Op
    Bits: 14:13 RingToken(rw) - CPP Token to send for CLS Ring Op
    Bits: 12:9  RingTarget(rw) - CPP Target ID to send for CLS Ring Op
    Bits:  8:4  RingAction(rw) - CPP Action to send for CLS Ring Op
    Bits:  3:0  RingIndex(rw) - Ring index determines which ring
*/
#define NFP3800_PCIEX_COMPCFG_QueueRingCfg(_x)               (0x00000064 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingClsIsl(_x)  (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingClsIsl_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingSigMaster(_x) (((_x) & 0xf) << 22)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingSigMaster_of(_x) (((_x) >> 22) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingSigRef(_x)  (((_x) & 0x7f) << 15)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingSigRef_of(_x) (((_x) >> 15) & 0x7f)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingToken(_x)   (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingToken_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingTarget(_x)  (((_x) & 0xf) << 9)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingTarget_of(_x) (((_x) >> 9) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingAction(_x)  (((_x) & 0x1f) << 4)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingAction_of(_x) (((_x) >> 4) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingIndex(_x)   (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_COMPCFG_QueueRingCfg_RingIndex_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeCompConfig4 - Configures operation mode for PCIe component, Expansion ROM Expansion BAR access
    Bits: 15:14 Pf7_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits: 13:12 Pf6_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits: 11:10 Pf5_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  9:8  Pf4_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  7:6  Pf3_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  5:4  Pf2_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  3:2  Pf1_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
    Bits:  1:0  Pf0_Expansion_ROM_BAR_Select(rw) - Selects which Expansion BAR should be used for PCIe Target requests received through Expansion ROM BAR
*/
#define NFP3800_PCIEX_COMPCFG_PCIeCompConfig4                0x00000084
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf7_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf7_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 14) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf7_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf7_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf7_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf6_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf6_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 12) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf6_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf6_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf6_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf5_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf5_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 10) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf5_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf5_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf5_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf4_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf4_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 8) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf4_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf4_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf4_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf3_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf3_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 6) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf3_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf3_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf3_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf2_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf2_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf2_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf2_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf2_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf1_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf1_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf1_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf1_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf1_Expansion_ROM_BAR_Select_BAR4 (2)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf0_Expansion_ROM_BAR_Select(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf0_Expansion_ROM_BAR_Select_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf0_Expansion_ROM_BAR_Select_BAR0 (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf0_Expansion_ROM_BAR_Select_BAR2 (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeCompConfig4_Pf0_Expansion_ROM_BAR_Select_BAR4 (2)
/*----------------------------------------------------------------
  Register: PcieTrapTypeTimeout - 32-bit Cycle counter used to detect when trapped PCIe mem read request has been lost and completion should be aborted
    Bits:  9:8  TrapTimeoutRange(rw) - A timeout granularity setting used as a multiplier with the TrapTimeout field value for all Trap VirtIO read requests, programmed by SW, represented in microseconds. Read requests that timeout will complete with an error.
    Bits:  4:0  TrapTimeout(rw) - The count value for Trap VirtIO read requests, programmed by SW, multiplied by the TrapTimeoutRange used to calculate the approx number of microseconds for a timeout. NOTE: Valid values are 0x0 through 0x1e. A value of 0 disables the timeout check. NOTE: Read requests that timeout will complete with a Completer Abort.
*/
#define NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout            0x00000088
#define   NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeoutRange(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeoutRange_of(_x) (((_x) >> 8) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeoutRange_1us (0)
#define     NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeoutRange_8us (1)
#define     NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeoutRange_128us (2)
#define   NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeout(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieTrapTypeTimeout_TrapTimeout_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIePerfCfg - Performance Mux Control Register
    Bits: 20:18 AuxSelect(None) - Module select for module 3.
    Bits: 17:14 HiMuxSelect(None) - High 16 to 1 mux select
    Bits: 13:10 MidMuxSelect(None) - Middle 16 to 1 mux select.
    Bits:  9:6  LowMuxSelect(None) - Low 16 to 1 mux select.
    Bits:  5:4  LaneSelectHi(None) - Lane select for bits [32;64]
    Bits:  3:2  LaneSelectMid(None) - Lane select for bits [32;32]
    Bits:  1:0  LaneSelectLo(None) - Lane select for bits [32;0]
*/
#define NFP3800_PCIEX_COMPCFG_PCIePerfCfg                    0x00000100
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_AuxSelect(_x)    (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_AuxSelect_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_HiMuxSelect(_x)  (((_x) & 0xf) << 14)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_HiMuxSelect_of(_x) (((_x) >> 14) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_MidMuxSelect(_x) (((_x) & 0xf) << 10)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_MidMuxSelect_of(_x) (((_x) >> 10) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LowMuxSelect(_x) (((_x) & 0xf) << 6)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LowMuxSelect_of(_x) (((_x) >> 6) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi_Deselect (0)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi_LowSelect (1)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi_MidSelect (2)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectHi_HiSelect (3)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid_Deselect (0)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid_LowSelect (1)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid_MidSelect (2)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectMid_HiSelect (3)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo_Deselect (0)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo_LowSelect (1)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo_MidSelect (2)
#define     NFP3800_PCIEX_COMPCFG_PCIePerfCfg_LaneSelectLo_HiSelect (3)
/*----------------------------------------------------------------
  Register: PCIeSpare2[2] - Spare register address, no hw implemented
  Register: PCIeSpare3[6] - Spare register address, no hw implemented
  Register: PCIeSpare41 - Spare register address, no hw implemented
  Register: PCIeSpare4 - Spare register address, no hw implemented
*/
#define NFP3800_PCIEX_COMPCFG_PCIeSpare2(_x)                 (0x00000108 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_COMPCFG_PCIeSpare3(_x)                 (0x000001c0 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_COMPCFG_PCIeSpare41                    0x000001dc
#define NFP3800_PCIEX_COMPCFG_PCIeSpare4                     0x000001e0
/*----------------------------------------------------------------
  Register: PcieEventIntFuncMap_[32] - Defines the MSI/MSIX/Legacy function number and message attributes for event filter X
    Bits: 31:9  Reserved(rw) - Reserved.
    Bits:  8    MaskEvent(rw) - Specifies to mask the event from generating an MSI.
    Bits:  7:0  FunctionNumber(rw) - Specifies the function number to be sent as ReqID with MSI/MSIX/Legacy message or when used with Legacy interrupts the physical function number associated with the Interrupt request. Physical Functions are in the range of 0x0-0x3. Only physical functions allowed for MSIX and Legacy
*/
#define NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap(_x)        (0x00000110 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap_Reserved(_x) (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap_Reserved_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap_MaskEvent BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap_FunctionNumber(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieEventIntFuncMap_FunctionNumber_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxPendBitArray_[8] - Shows the status of 32 of the 256 MSI-X interrupt vectors Pending Bit Array, PBA
    Bits: 31:0  MsixPba(ro) - Status of the MSI-X Pending Bit Array.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeMSIxPendBitArray(_x)       (0x00000190 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxPendBitArray_MsixPba(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxPendBitArray_MsixPba_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieVendorMsgCtrl - PCIe Vendor Message Control Register
    Bits: 31    Full(ro) - When set all 32 buffers are occupied with vendor defined messages. When clear the SRAM buffer is not full
    Bits: 30    Empty(ro) - When set no vendor defined messages are currently stored in SRAM,. When clear there is at least one message stored in the SRAM buffer
    Bits: 28:24 AddToRdPtr(wo) - Software writes a value to this field to increment the read pointer by n+1 and free up SRAM buffers. The write will also update the EntryCnt, Full and Empty flags. Software should not write a value larger than the number of entries currently in the buffer or an underflow error assertion will fire and the read pointer increment will be limted by the current EntryCnt value. Software should only update the read pointer after the vendor defined messages have been read from SRAM.
    Bits: 21:16 EntryCnt(ro) - Indicates the number of vendor defined messages currently stored in SRAM
    Bits: 12:8  WrPtr(ro) - Write Pointer increments when a Vendor Defined Message has been written in the SRAM buffer
    Bits:  4:0  RdPtr(ro) - Read pointer. Software increments this pointer by writing to the RdPtrInc Field
*/
#define NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl              0x000001b0
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_Full       BIT(31)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_Empty      BIT(30)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_AddToRdPtr(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_AddToRdPtr_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_EntryCnt(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_EntryCnt_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_WrPtr(_x)  (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_WrPtr_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_RdPtr(_x)  (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgCtrl_RdPtr_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PcieVendorMsgStat - PCIe Vendor Message Statistic Register
    Bits: 31:24 DropCnt(rc) - Vendor Defined Message Drop Counter. Increments when a vendor defined message is dropped due to lack of SRAM buffers. This counter saturates at all 1's and clears on reads
    Bits: 23:0  RxCnt(rc) - Vendor Defined Message receive counter. Increments after a vendor defined message is received and stored in SRAM. This counter clears on reads.
*/
#define NFP3800_PCIEX_COMPCFG_PcieVendorMsgStat              0x000001b4
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgStat_DropCnt(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgStat_DropCnt_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgStat_RxCnt(_x)  (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieVendorMsgStat_RxCnt_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: PcieMasterSwCreditLimit - PCIe Master Sw Credit Limit Register
    Bits: 12:9  pciem_compl_cppt_fifo_sw_credit_limit(rw) - Software credit limit for the pcie master compl cppt fifo
    Bits:  8:6  pciem_compl_dma_sw_credit_limit(rw) - Software credit limit for the pcie master compl dma fifo
    Bits:  5:3  pciem_compl_aligned_sw_credit_limit(rw) - Software credit limit for the pcie master compl aligned fifo
    Bits:  2:0  pciem_halm_req_fifo_sw_credit_limit(rw) - Software credit limit for the pcie master hal master req fifo
*/
#define NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit        0x000001bc
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_cppt_fifo_sw_credit_limit(_x) (((_x) & 0xf) << 9)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_cppt_fifo_sw_credit_limit_of(_x) (((_x) >> 9) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_dma_sw_credit_limit(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_dma_sw_credit_limit_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_aligned_sw_credit_limit(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_compl_aligned_sw_credit_limit_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_halm_req_fifo_sw_credit_limit(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieMasterSwCreditLimit_pciem_halm_req_fifo_sw_credit_limit_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieRoceCounters - Pcie Roce doorbell statistics
    Bits: 31:16 PcieDoorbellDropCount(rc) - Counter that keeps a track of the dropped doorbells. Saturates if not read
    Bits: 15:0  PcieDoorBellCount(rc) - Counter that keeps a track of the number of doorbells. Saturates if not read
*/
#define NFP3800_PCIEX_COMPCFG_PcieRoceCounters               0x000001e4
#define   NFP3800_PCIEX_COMPCFG_PcieRoceCounters_PcieDoorbellDropCount(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceCounters_PcieDoorbellDropCount_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceCounters_PcieDoorBellCount(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceCounters_PcieDoorBellCount_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PcieRoceAutoPushInterval - Waiting time before sending second cycle autopush with zeros
    Bits: 25:23 PcieRoceDoorbellFifoSWCredits(rw) - Software credit limit for the Roce Doorbell FIFO.
    Bits: 21:16 PcieRoceWorkqFifoSWCredits(rw) - Software credit limit for the Roce workq FIFO.
    Bits:  7:0  PcieRoceAutoPushInterval(rw) - Number of cycles to wait for the second doorbell after the first one, before sending sending zeroes on second autopush cycle
*/
#define NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval       0x000001e8
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceDoorbellFifoSWCredits(_x) (((_x) & 0x7) << 23)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceDoorbellFifoSWCredits_of(_x) (((_x) >> 23) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceWorkqFifoSWCredits(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceWorkqFifoSWCredits_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceAutoPushInterval(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceAutoPushInterval_PcieRoceAutoPushInterval_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PcieRoceInterruptStatus - Information regarding the event
    Bits: 15    PcieRoceWorkqState(ro) - 0 -> Workq FIFO stores Threads. 1 -> Workq FIFO stores doorbells
    Bits: 14:8  PcieRoceWorkqFifoStatus(ro) - Indicates the level of the WorkQ FIFO.
    Bits:  7    PcieRoceEventMaskDropDoorbells(rw) - Mask bit for Dropping Doorbells event.
    Bits:  6    PcieRoceEventMaskDropThreads(rw) - Mask bit for Dropping Threads event.
    Bits:  5    PcieRoceEventMaskFull(rw) - Mask bit for WorkQ FIFO Full event.
    Bits:  4    PcieRoceEventMask34Full(rw) - Mask bit for WorkQ FIFO 3/4th Full event.
    Bits:  3    PcieRoceDropDoorbells(rw1c) - Indicates that the WorkQ FIFO is Full of doorbells and the doorbells are being dropped. Write 1 to clear.
    Bits:  2    PcieRoceDropThreads(rw1c) - Indicates that the WorkQ FIFO is Full and the incoming threads is being dropped. Write 1 to clear.
    Bits:  1    PcieRoceWorkqFull(rw1c) - Indicates that the WorkQ FIFO is Full. Write 1 to clear.
    Bits:  0    PcieRoceWorkq34Full(rw1c) - Indicates that the WorkQ FIFO is 3/4th Full. Write 1 to clear.
*/
#define NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus        0x000001ec
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceWorkqState BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceWorkqFifoStatus(_x) (((_x) & 0x7f) << 8)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceWorkqFifoStatus_of(_x) (((_x) >> 8) & 0x7f)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceEventMaskDropDoorbells BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceEventMaskDropThreads BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceEventMaskFull BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceEventMask34Full BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceDropDoorbells BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceDropThreads BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceWorkqFull BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PcieRoceInterruptStatus_PcieRoceWorkq34Full BIT(0)
/*----------------------------------------------------------------
  Register: PCIePfMSIxMaskChange - Summary register of the change in the PF MSI-X mask
    Bits:  7:0  MsixPfMaskChngStatus(rc) - Status of the MSI-X PF Mask Change, where each bit represents a PF Mask change state, NOTE: changed status not the actual mask value. These bits are clear-on-read.
*/
#define NFP3800_PCIEX_COMPCFG_PCIePfMSIxMaskChange           0x000001f8
#define   NFP3800_PCIEX_COMPCFG_PCIePfMSIxMaskChange_MsixPfMaskChngStatus(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIePfMSIxMaskChange_MsixPfMaskChngStatus_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxSummary - Summary register where each bit is a wire-OR of 32 of the 256 status bits as a hint to SW for which register(s) to read
    Bits: 15:8  MsixPbaIdx(ro) - Indirect status summary of the MSI-X PBA registers, where 1 bit represents 32 PBA status bits. Bit 0 being set would indicate that at least 1 bit is set for PBA bits 0 thru 31. Bit 1 represents PBA 32 thru 63, and so on.
    Bits:  7:0  MsixVectorChngIdx(ro) - Indirect status summary of the MSI-X Vector Change registers, where 1 bit represents 32 mask change status bits. Bit 0 being set would indicate that at least 1 bit is set for MSI-X Vector Change bits 0 thru 31. Bit 1 represents Vectors 32 thru 63, and so on.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeMSIxSummary                0x000001fc
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxSummary_MsixPbaIdx(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxSummary_MsixPbaIdx_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxSummary_MsixVectorChngIdx(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxSummary_MsixVectorChngIdx_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMSIxVectorMaskChange_[8] - Status of 32 of the 256 MSI-X Vector Mask bits that have recently changed
    Bits: 31:0  MsixMaskChng(rc) - Status of the MSI-X Vector Mask Change. Clear on read.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeMSIxVectorMaskChange(_x)   (0x00000200 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxVectorMaskChange_MsixMaskChng(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeMSIxVectorMaskChange_MsixMaskChng_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader0 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader0 - The TLP Header of the received Set Slot Power message
    Bits: 31:16 ReqId(ro) - Received message header, Requestor ID field.
    Bits: 15:8  Tag(ro) - Received message header, Tag field
    Bits:  7:0  MsgCode(ro) - Received message header Message, Code field
*/
#define NFP3800_PCIEX_COMPCFG_PciePMEMsgHeader0              0x00000240
#define NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgHeader0            0x00000250
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_ReqId(_x)     (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_ReqId_of(_x)  (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_Tag(_x)       (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_Tag_of(_x)    (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_MsgCode(_x)   (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader0_MsgCode_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader1 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader1 - The TLP Header of the received Set Slot Power message
    Bits: 20:18 Type(ro) - Received message header, Transaction Type field
    Bits: 17:15 Tclass(ro) - Received message header, Traffic Class field.
    Bits: 14:12 Attr(ro) - Received message header, Attribute field.
    Bits:  9:0  Length(ro) - Received message header length field. Length is in bytes.
*/
#define NFP3800_PCIEX_COMPCFG_PciePMEMsgHeader1              0x00000244
#define NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgHeader1            0x00000254
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Type(_x)      (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Type_of(_x)   (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Tclass(_x)    (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Tclass_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Attr(_x)      (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Attr_of(_x)   (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Length(_x)    (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader1_Length_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader2 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader2 - The TLP Header of the received Set Slot Power message
    Bits: 31:0  HeaderBytes12_15(ro) - Received message header bytes {12,13,14,15}
*/
#define NFP3800_PCIEX_COMPCFG_PciePMEMsgHeader2              0x00000248
#define NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgHeader2            0x00000258
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader2_HeaderBytes12_15(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader2_HeaderBytes12_15_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePMEMsgHeader3 - The TLP Header of the received PME message
  Register: PcieSSPwrMsgHeader3 - The TLP Header of the received Set Slot Power message
    Bits: 31:0  HeaderBytes8_11(ro) - Received message header bytes {8,9,10,11}
*/
#define NFP3800_PCIEX_COMPCFG_PciePMEMsgHeader3              0x0000024c
#define NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgHeader3            0x0000025c
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader3_HeaderBytes8_11(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieMsgHeader3_HeaderBytes8_11_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieSSPwrMsgData - The Data portion of the set slot power message data.
    Bits: 31:0  PcieMsgData(ro) - The data payload of the received message
*/
#define NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgData               0x00000260
#define   NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgData_PcieMsgData(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieSSPwrMsgData_PcieMsgData_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PciePmeRegister0 - Indicates the activity in pcie. A value of zero indicate everything is idle.
    Bits: 31    DmaItpStateFsmBusy(ro) - dma_itp_state_fsm_busy
    Bits: 30    DmaRtpStateFsmBusy(ro) - dma_rtp_state_fsm_busy
    Bits: 29    DmaIfpStateFsmBusy(ro) - dma_ifp_state_fsm_busy
    Bits: 28    DmaRfpStateFsmBusy(ro) - dma_rfp_state_fsm_busy
    Bits: 27    DmaRfpCStateFsmBusy(ro) - dma_rfp_c_state_fsm_busy
    Bits: 26    DmaRtpCStateFsmBusy(ro) - dma_rtp_c_state_fsm_busy
    Bits: 25    AllTokensFree(ro) - all_tokens_free
    Bits: 24    AllContextsFree(ro) - all_contexts_free
    Bits: 23    FrmPcieFifoEmpty(ro) - frm_pcie_fifo_empty
    Bits: 22    ToPcieFifoEmpty(ro) - to_pcie_fifo_empty
    Bits: 21    ToPcieCompletionFifoEmpty(ro) - to_pcie_completion_fifo_empty
    Bits: 20    FrmPcieCompletionFifoEmpty(ro) - frm_pcie_completion_fifo_empty
    Bits: 19    FrmPciePmCmdFifoEmpty(ro) - frm_pcie_pm_cmd_fifo_empty
    Bits: 18    PciemPcieMasterHalmComplReorderFifoArrayValid(ro) - pciem_pcie_master_halm_compl_reorder_fifo_array_valid
    Bits: 17    PciemPciemHalmReqFifoValid(ro) - pciem_pciem_halm_req_fifo_valid
    Bits: 16    PciemSharedMemReqFifoValid(ro) - pciem_shared_mem_req_fifo_valid
    Bits: 15    PciemPciemCpptReqFifoValid(ro) - pciem_pciem_cppt_req_fifo_valid
    Bits: 14    PciemPciemHalmReqStateIdle(ro) - pciem_pciem_halm_req_state_idle
    Bits: 13    CpptCommandHandlerCmdValid(ro) - cppt_command_handler_cmd_valid
    Bits: 12    CpptPush2targetInletFifoValid(ro) - cppt_push2target_inlet_fifo_valid
    Bits: 11    CpptCpptDequeuedCmdFifoValid(ro) - cppt_cppt_dequeued_cmd_fifo_valid
    Bits: 10    CpptSharedMemReqFifoValid(ro) - cppt_shared_mem_req_fifo_valid
    Bits:  9    CpptSmPushIdFifoValid(ro) - cppt_sm_push_id_fifo_valid
    Bits:  8    CpptSmPushDataFifoValid(ro) - cppt_sm_push_data_fifo_valid
    Bits:  7    CpptIoselSmPushDataFifoValid(ro) - cppt_iosel_sm_push_data_fifo_valid
    Bits:  6    CpptPciemPushDataFifoValid(ro) - cppt_pciem_push_data_fifo_valid
    Bits:  5    CpptCpptComplStateIdle(ro) - cppt_cppt_compl_state_idle
    Bits:  4    PcietWriteSharedMemBusy(ro) - pciet_write_shared_mem_busy
    Bits:  3    PcietPcieReqStateFsmBusy(ro) - pciet_pcie_req_state_fsm_busy
    Bits:  2    PcietPcietSramReadStateFsmBusy(ro) - pciet_pciet_sram_read_state_fsm_busy
    Bits:  1    PcietPcietReadComplStateFsmBusy(ro) - pciet_pciet_read_compl_state_fsm_busy
    Bits:  0    PcietHalComplCstateBusy(ro) - pciet_hal_compl_cstate_busy
*/
#define NFP3800_PCIEX_COMPCFG_PciePmeRegister0               0x00000270
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaItpStateFsmBusy BIT(31)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaRtpStateFsmBusy BIT(30)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaIfpStateFsmBusy BIT(29)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaRfpStateFsmBusy BIT(28)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaRfpCStateFsmBusy BIT(27)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_DmaRtpCStateFsmBusy BIT(26)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_AllTokensFree BIT(25)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_AllContextsFree BIT(24)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_FrmPcieFifoEmpty BIT(23)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_ToPcieFifoEmpty BIT(22)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_ToPcieCompletionFifoEmpty BIT(21)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_FrmPcieCompletionFifoEmpty BIT(20)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_FrmPciePmCmdFifoEmpty BIT(19)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PciemPcieMasterHalmComplReorderFifoArrayValid BIT(18)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PciemPciemHalmReqFifoValid BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PciemSharedMemReqFifoValid BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PciemPciemCpptReqFifoValid BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PciemPciemHalmReqStateIdle BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptCommandHandlerCmdValid BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptPush2targetInletFifoValid BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptCpptDequeuedCmdFifoValid BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptSharedMemReqFifoValid BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptSmPushIdFifoValid BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptSmPushDataFifoValid BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptIoselSmPushDataFifoValid BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptPciemPushDataFifoValid BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_CpptCpptComplStateIdle BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PcietWriteSharedMemBusy BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PcietPcieReqStateFsmBusy BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PcietPcietSramReadStateFsmBusy BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PcietPcietReadComplStateFsmBusy BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister0_PcietHalComplCstateBusy BIT(0)
/*----------------------------------------------------------------
  Register: PciePmeRegister1 - Indicates the activity in pcie. A value of zero indicate everything is idle.
    Bits: 17    HaltPcietReqFifoValid(ro) - halt_pciet_req_fifo_valid
    Bits: 16    HaltPcietReqCaFifoValid(ro) - halt_pciet_req_ca_fifo_valid
    Bits: 15    HalComplDescrFifoValid(ro) - hal_compl_descr_fifo_valid
    Bits: 14    HalComplReadyFifoValid(ro) - hal_compl_ready_fifo_valid
    Bits: 13    HalRequestReadyFifoValid(ro) - HAL_REQUEST_READY_FIFO_VALID
    Bits: 12    SharedMemReqFifoValid(ro) - shared_mem_req_fifo_valid
    Bits: 11    SharedMemRdReqFifoValid(ro) - shared_mem_rd_req_fifo_valid
    Bits: 10    SharedMemWrReqFifoValid(ro) - shared_mem_wr_req_fifo_valid
    Bits:  9    HaltPcietReqInletFifoValid(ro) - halt_pciet_req_inlet_fifo_valid
    Bits:  8    IntIoReadDataFifoValid(ro) - int_io_read_data_fifo_valid
    Bits:  7    SramReadDataFifoValid(ro) - sram_read_data_fifo_valid
    Bits:  6    ReadComplOrderFifoValid(ro) - read_compl_order_fifo_valid
    Bits:  5    CppMasterReqFifoValid(ro) - cpp_master_req_fifo_valid
    Bits:  4    IntReadReqFifoValid(ro) - int_read_req_fifo_valid
    Bits:  3    PcieReqState(ro) - pcie_req_state
    Bits:  2    PcietSramReadState(ro) - pciet_sram_read_state
    Bits:  1    PcietReadComplState(ro) - pciet_read_compl_state
    Bits:  0    IntDummy(ro) - int_dummy
*/
#define NFP3800_PCIEX_COMPCFG_PciePmeRegister1               0x00000274
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HaltPcietReqFifoValid BIT(17)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HaltPcietReqCaFifoValid BIT(16)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HalComplDescrFifoValid BIT(15)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HalComplReadyFifoValid BIT(14)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HalRequestReadyFifoValid BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_SharedMemReqFifoValid BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_SharedMemRdReqFifoValid BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_SharedMemWrReqFifoValid BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_HaltPcietReqInletFifoValid BIT(9)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_IntIoReadDataFifoValid BIT(8)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_SramReadDataFifoValid BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_ReadComplOrderFifoValid BIT(6)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_CppMasterReqFifoValid BIT(5)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_IntReadReqFifoValid BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_PcieReqState BIT(3)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_PcietSramReadState BIT(2)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_PcietReadComplState BIT(1)
#define   NFP3800_PCIEX_COMPCFG_PciePmeRegister1_IntDummy    BIT(0)
/*----------------------------------------------------------------
  Register: PcieCppMstrSwCreditLimit - Programmable Credit limit control for the CPP Master Abiter logic
    Bits: 27:24 BlqWrCmdSwCreditLimit(rw) - Controls the software credit limit value for the BLQWR Command output interface of the CPP Master Arbiter Block
    Bits: 21:16 AllocRespSwCreditLimit(rw) - Controls the software credit limit value for the Allocation Response output interface of the CPP Master Arbiter block.
    Bits: 14:12 P7CmdSwCreditLimit(rw) - Controls the software credit limit value for Command Bus B output of the CPP Master Arbiter block.
    Bits: 10:8  P6CmdSwCreditLimit(rw) - Controls the software credit limit value for Command Bus A output of the CPP Master Arbiter block.
    Bits:  7:6  P7BSmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P7B Credit Tracker.
    Bits:  5:4  P7ASmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P7A Credit Tracker
    Bits:  3:2  P6BSmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P6B Credit Tracker
    Bits:  1:0  P6ASmCppDataSwCreditLimit(rw) - Controls the software credit limit value for Push bus to shared Master port P6A Credit Tracker
*/
#define NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit       0x00000278
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_BlqWrCmdSwCreditLimit(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_BlqWrCmdSwCreditLimit_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_AllocRespSwCreditLimit(_x) (((_x) & 0x3f) << 16)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_AllocRespSwCreditLimit_of(_x) (((_x) >> 16) & 0x3f)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7CmdSwCreditLimit(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7CmdSwCreditLimit_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6CmdSwCreditLimit(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6CmdSwCreditLimit_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7BSmCppDataSwCreditLimit(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7BSmCppDataSwCreditLimit_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7ASmCppDataSwCreditLimit(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P7ASmCppDataSwCreditLimit_of(_x) (((_x) >> 4) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6BSmCppDataSwCreditLimit(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6BSmCppDataSwCreditLimit_of(_x) (((_x) >> 2) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6ASmCppDataSwCreditLimit(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PcieCppMstrSwCreditLimit_P6ASmCppDataSwCreditLimit_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: PciePmDmaSwCreditLimit - Programmable Credit limit control for the DMA engine
    Bits: 29:27 PmCreditChkSwCreditLimit(rw) - Controls the software credit limit for the DMA Descriptor Packet Mode Credit Check Credit Tracker.
    Bits: 26:24 P2DSwCreditLimit(rw) - Controls the software credit limit for the P2D Command interface between the FromPCIe DMA engine and buffer allocation logic
    Bits: 23:20 ToPcieBufferSwCreditLimit(rw) - Controls the software credit limit for the toPcie DMA SRAM allocation space in increments of 8 buffers
    Bits: 19:16 FrmPcieBufferSwCreditLimit(rw) - Controls the software credit limit for the fromPcie DMA SRAM allocation space in increments of 8 buffers
    Bits: 13    AllocCmdSwCreditLimit(rw) - Controls the software credit limit for the allocation command interface within the buffer allocation logic
    Bits: 12    AllocMstrCmdSwCreditLimit(rw) - Controls the software credit limit for the allocation master command interface between the buffer allocation logic and the CPP Master Arbiter block
    Bits: 11    DmaCmdSwCreditLimit(rw) - Controls software credit limit for the DMA command interface between the buffer allocation logic and the PCIe Master Interface.
    Bits: 10    BufRetCreditSwCreditLimit(rw) - Controls the Buffer Credit Return interface software credit limit within the Buffer allocation logic
    Bits:  9:8  BdFifoSwCreditLimit(rw) - Controls BLQ buffer descriptor FIFO credit limit value
    Bits:  7:6  McrRespSwCreditLimit(rw) - Controls the software credit limit for the MCR response interface between the buffer allocation BLQ logic and the DMA CSR block
    Bits:  5:4  DmaPmAddToWrkQSwCreditLimit(rw) - Controls the software credit limit for the packet mode add to workQ and read completion command from the DMA engine to the CPP Master Arbiter block
    Bits:  1:0  DmaFreePktSwCreditLimit(rw) - Controls the software credit limit value for the free pkt command i/f from the DMA engine to the CPP Master Arbiter block.
*/
#define NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit         0x0000027c
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_PmCreditChkSwCreditLimit(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_PmCreditChkSwCreditLimit_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_P2DSwCreditLimit(_x) (((_x) & 0x7) << 24)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_P2DSwCreditLimit_of(_x) (((_x) >> 24) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_ToPcieBufferSwCreditLimit(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_ToPcieBufferSwCreditLimit_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_FrmPcieBufferSwCreditLimit(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_FrmPcieBufferSwCreditLimit_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_AllocCmdSwCreditLimit BIT(13)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_AllocMstrCmdSwCreditLimit BIT(12)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_DmaCmdSwCreditLimit BIT(11)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_BufRetCreditSwCreditLimit BIT(10)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_BdFifoSwCreditLimit(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_BdFifoSwCreditLimit_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_McrRespSwCreditLimit(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_McrRespSwCreditLimit_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_DmaPmAddToWrkQSwCreditLimit(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_DmaPmAddToWrkQSwCreditLimit_of(_x) (((_x) >> 4) & 0x3)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_DmaFreePktSwCreditLimit(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_COMPCFG_PciePmDmaSwCreditLimit_DmaFreePktSwCreditLimit_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: DMAPacketAllocationActiveStat - Active Packet Allocation Status
    Bits: 31:0  Active(rc) - When a packet allocation context becomes active the bit that corresponds to the packet allocation context is set. Clears on read
*/
#define NFP3800_PCIEX_COMPCFG_DMAPacketAllocationActiveStat  0x00000288
#define   NFP3800_PCIEX_COMPCFG_DMAPacketAllocationActiveStat_Active(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_DMAPacketAllocationActiveStat_Active_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaRateMeterCtrl - DMA Rate Meter Control and status
    Bits: 31:16 RateMeterRdData(ro) - Measured rate from selected DMA rate meter. Value/(32768*(CLK PERIOD in secs)*(10**6)) = Millions of packets/sec or bit rate. If selecting FrmPcieBitRate or ToPcieBitRate multiply the value by the (DmaPcieCredit+1)*8*8, where the DmaPcieCredit is either the DmaToPcieCredit or DmaToPcieCredit from the DMACntrlCfg2 register.
    Bits:  7    DisSigOnlyCnt(rw) - When set, signal only DMAs are not counted for pkt rate meter measurements and packet count increments.
    Bits:  6:5  DmaRateMeterRdSel(rw) - Selects the DMA Rate meter to read from
    Bits:  4    DmaPktRateMuxSel(rw) - Used to select the increment signal for rate meter measurements and packet/byte count increments.
    Bits:  3:1  DmaRateResolution(rw) - When programmed to a value of N, the rate meters will have a resolution of 1/(2**(15-N)*(CLK PERIOD in secs)*(10**6)) Million Packets Per Sec
    Bits:  0    DmaRateMeterEna(rw) - When programmed to 1, enables the rate meters. Disabling the rate meters will freeze the values so that they can be read one at a time, but represent a snapshot in time.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl           0x0000028c
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_RateMeterRdData(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_RateMeterRdData_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DisSigOnlyCnt BIT(7)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel(_x) (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel_of(_x) (((_x) >> 5) & 0x3)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel_FrmPciePktRate (0)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel_FrmPcieBitRate (1)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel_ToPciePktRate (2)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterRdSel_ToPcieBitRate (3)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaPktRateMuxSel BIT(4)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaPktRateMuxSel_DmaDescFragPost (0 << 4)
#define     NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaPktRateMuxSel_DmaDescrFragPre BIT(4)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateResolution(_x) (((_x) & 0x7) << 1)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateResolution_of(_x) (((_x) >> 1) & 0x7)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaRateMeterCtrl_DmaRateMeterEna BIT(0)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktCntLo - DMA ToPCIe (Writes) packet counter low 32-bits. Software should read this register follwed by the PCIeDmaToPciePktCntHi register to get the 48-bit counter value.
  Register: PCIeDmaFrmPciePktCntLo - DMA ToPCIe (Writes) packet counter low 32-bits. Software should read this register follwed by the PCIeDmaFrmPciePktCntHi register to get the 48-bit counter value.
    Bits: 31:0  PCIeDmaPktCntLo(rc) - DMA Packet Counter Low 32-bits. SW should read this register followed by the high packet count regiser. Increments when a DMA Descriptor is popped from the DMA queue.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeDmaToPciePktCntLo          0x00000290
#define NFP3800_PCIEX_COMPCFG_PCIeDmaFrmPciePktCntLo         0x000002a0
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaPktCntLo_PCIeDmaPktCntLo(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaPktCntLo_PCIeDmaPktCntLo_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktCntHi - DMA ToPCIe (Writes) packet counter high 16-bits.
  Register: PCIeDmaFrmPciePktCntHi - DMA ToPCIe (Writes) packet counter high 16-bits.
    Bits: 15:0  PCIeDmaPktCntHi(ro) - DMA Packet Counter High Latched 16-bits. SW should read this register after reading the low packet count regiser.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeDmaToPciePktCntHi          0x00000294
#define NFP3800_PCIEX_COMPCFG_PCIeDmaFrmPciePktCntHi         0x000002a4
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaPktCntHi_PCIeDmaPktCntHi(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaPktCntHi_PCIeDmaPktCntHi_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktByteCntLo - DMA ToPCIe (Writes) packet byte counter low 32-bits. Software should read this register follwed by the PCIeDmaToPciePktCntHi register to get the 48-bit counter value.
  Register: PCIeDmaFrmPciePktByteCntLo - DMA ToPCIe (Writes) packet byte counter low 32-bits. Software should read this register follwed by the PCIeDmaFromPciePktCntHi register to get the 48-bit counter value.
    Bits: 31:0  PCIeDmaByteCntLo(rc) - DMA Packet Byte Counter Low 32-bits. SW should read this register followed by the high packet count regiser. Increments by the size of the DMA Descriptor when popped from the DMA queue.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeDmaToPciePktByteCntLo      0x00000298
#define NFP3800_PCIEX_COMPCFG_PCIeDmaFrmPciePktByteCntLo     0x000002a8
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaByteCntLo_PCIeDmaByteCntLo(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaByteCntLo_PCIeDmaByteCntLo_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeDmaToPciePktByteCntHi - DMA ToPCIe (Writes) packet byte counter high 16-bits.
  Register: PCIeDmaFrmPciePktByteCntHi - DMA ToPCIe (Writes) packet byte counter high 16-bits.
    Bits: 15:0  PCIeDmaByteCntHi(ro) - DMA Packet Byte Counter High Latched 16-bits. SW should read this register after reading the low byte count regiser.
*/
#define NFP3800_PCIEX_COMPCFG_PCIeDmaToPciePktByteCntHi      0x0000029c
#define NFP3800_PCIEX_COMPCFG_PCIeDmaFrmPciePktByteCntHi     0x000002ac
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaByteCntHi_PCIeDmaByteCntHi(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_COMPCFG_PCIeDmaByteCntHi_PCIeDmaByteCntHi_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_vendor_id_device_id -
    Bits: 31:16 DID(rw) - Device ID: Device ID assigned by the manufacturer of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
    Bits: 15:0  VID(rw) - Vendor ID: This is the Vendor ID assigned by PCI SIG to the manufacturer of the device.On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_vendor_id_device_id   0x00000000
#define   NFP3800_PCIEX_PF_i_pcie_base_i_vendor_id_device_id_DID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_vendor_id_device_id_DID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_vendor_id_device_id_VID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_vendor_id_device_id_VID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_command_status -
    Bits: 31    DPE(w1c) - Detected Parity Error: This bit is set when the Controller has received a poisoned TLP. The Parity Error Response enable bit (bit 6) has no effect on the setting of this bit. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 30    SSE(w1c) - Signaled System Error: If the SERR enable bit is 1, this bit is set when the Controller has sent out a fatal or non-fatal error message on the link to the Root Complex. If the SERR enable bit is 0, this bit remains 0. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 29    RMA(w1c) - Received Master Abort: This bit is set when the Controller has received a completion from the link with the Unsupported Request status. This field can also be cleared from the local management bus by writing a 1 into this bit position
    Bits: 28    RTA(w1c) - Received Target Abort: This bit is set when the Controller has received a completion from the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position
    Bits: 27    STA(w1c) - Signaled Target Abort: This bit is set when the Controller has sent a completion to the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 26:25 R6(ro) - Reserved: Reserved
    Bits: 24    MDPE(w1c) - Master Data Parity Error: When the Parity Error Response enable bit is 1, the Controller sets this bit when it detects the following error conditions: (i) The Controller receives a poisoned completion from the link in response to a request. (ii) The Controller sends out a poisoned write request on the link (this may be because an underflow occurred during the packet transfer at the host interface of the Controller.). This bit remains 0 when the Parity Error Response enable bit is 0. This field can also be cleared from the local management bus by writing a 1 into this bit position.
    Bits: 23:21 R5(ro) - Reserved: Reserved
    Bits: 20    CL(ro) - Capabilities List: Indicates the presence of PCI Extended Capabilities registers. This bit is hardwired to 1.
    Bits: 19    IS(ro) - Interrupt Status: This bit is valid only when the Controller is configured to support legacy interrupts. Indicates that the Controller has a pending interrupt, that is, the Controller has sent an Assert_INTx message but has not transmitted a corresponding Deassert_INTx message.
    Bits: 18:16 R4(ro) - Reserved: Reserved
    Bits: 15:11 R3(ro) - Reserved: Reserved
    Bits: 10    IMD(rw) - INTx Message Disabled: Enables or disables the transmission of INTx Assert and De-assert messages from the Controller. Setting this bit to 1 disables generation of INTx assert/de-assert messages in the Controller. This field can be written from the local management bus.
    Bits:  9    R2(ro) - Reserved: Reserved
    Bits:  8    SE(rw) - SERR Enable: Enables the reporting of fatal and non-fatal errors detected by the Controller to the Root Complex. This field can be written from the local management bus.
    Bits:  7    R1(ro) - Reserved: Reserved
    Bits:  6    PERE(rw) - Parity Error Response Enable: When this bit is 1, the Controller sets the Master Data Parity Error status bit when it detects the following error conditions: (i) The Controller receives a poisoned completion from the link in response to a request. (ii) The Controller sends out a poisoned write request on the link (this may be because an underflow occurred during the packet transfer at the host interface of the Controller.). When this bit is 0, the Master Data Parity Error status bit is never set. This field can be written from the local management bus.
    Bits:  5:3  R0(ro) - Reserved: Reserved
    Bits:  2    BE(rw) - Bus-Master Enable: Enables the device to issue memory and I/O requests from this Function. This field can be written from the local management bus.
    Bits:  1    MSE(rw) - Mem-Space Enable: Enables memory accesses through the Controller for this PCI Function. This field can be written from the local management bus.
    Bits:  0    ISE(rw) - IO-Space Enable: Enables IO accesses through the Controller for this PCI Function. This field can be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_command_status        0x00000004
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_DPE  BIT(31)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_SSE  BIT(30)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_RMA  BIT(29)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_RTA  BIT(28)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_STA  BIT(27)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R6(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R6_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_MDPE BIT(24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R5(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R5_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_CL   BIT(20)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_IS   BIT(19)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R4(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R4_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R3(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R3_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_IMD  BIT(10)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R2   BIT(9)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_SE   BIT(8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R1   BIT(7)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_PERE BIT(6)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R0(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_R0_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_BE   BIT(2)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_MSE  BIT(1)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_command_status_ISE  BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_revision_id_class_code -
    Bits: 31:24 CC(rw) - Class Code: Identifies the function of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus
    Bits: 23:16 SCC(rw) - Sub-Class Code: Identifies a sub-category within the selected function. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits: 15:8  PIB(rw) - Programming Interface Byte: Identifies the register set layout of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  RID(rw) - Revision ID: Assigned by the manufacturer of the device to identify the revision number of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code 0x00000008
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_CC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_CC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_SCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_SCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_PIB(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_PIB_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_RID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_revision_id_class_code_RID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_bist_header_latency_cache_line -
    Bits: 31:24 BR(rw) - BIST Register: BIST control register.It can be accessed using local management bus. This is a sticky field.
    Bits: 23    DT(ro) - Device Type: Identifies whether the device supports a single Function or multiple Functions. This bit is read as 0 when only Function 0 has been enabled in the Physical Function Configuration Register (in the local management block), and as 1 when more than one Function has been enabled.
    Bits: 22:16 HT(ro) - Header Type: Identifies format of header. This field is hardwired to 0.
    Bits: 15:8  LT(ro) - Latency Timer: This is an unused field and is hardwired to 0.
    Bits:  7:0  CLS(rw) - Cache Line Size: Cache Line Size Register defined in PCI Specifications 3.0. This field can be read or written, both from the link and from the local management bus, but its value is not used.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line 0x0000000c
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_BR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_BR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_DT BIT(23)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_HT(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_HT_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_LT(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_LT_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_CLS(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_bist_header_latency_cache_line_CLS_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_0 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 1 is treated as a continuation of the base address in BAR 0. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0           0x00000010
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_P0      BIT(3)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_S0      BIT(2)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_R7      BIT(1)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_0_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_1 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_1           0x00000014
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_1_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_1_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_2 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 3 is treated as a continuation of the base address in BAR 2. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2           0x00000018
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_P0      BIT(3)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_S0      BIT(2)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_R7      BIT(1)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_2_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_3 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_3           0x0000001c
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_3_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_3_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_4 -
    Bits: 31:24 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 23:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 5 is treated as a continuation of the base address in BAR 4. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI0(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4           0x00000020
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_BAMRW(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_BAMRW_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_BAMR0(_x) (((_x) & 0xffff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_BAMR0_of(_x) (((_x) >> 8) & 0xffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_R8(_x)  (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_P0      BIT(3)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_S0      BIT(2)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_R7      BIT(1)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_4_MSI0    BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_base_addr_5 -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_5           0x00000024
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_5_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_base_addr_5_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_rsvd_0A -
  Register: i_pcie_base_rsvd_0E -
  Register: i_MSI_cap_struct_rsvd_02A_02B_[2] -
  Register: i_MSIX_cap_struct_rsvd_02F -
  Register: i_PCIE_cap_struct_rsvd_035 -
  Register: i_PCIE_cap_struct_rsvd_036 -
  Register: i_PCIE_cap_struct_rsvd_037_038_[2] -
  Register: i_PCIE_cap_struct_rsvd_03D_03F_[3] -
  Register: i_AER_cap_struct_rsvd_04B_04D_[3] -
  Register: i_ARI_cap_struct_rsvd_052_053_[2] -
  Register: i_device_serial_num_cap_struct_rsvd_057 -
  Register: i_power_budgeting_cap_struct_rsvd_05C_05F_[4] -
  Register: i_SRIOV_cap_struct_rsvd_090_09C_[13] -
    Bits: 31:0  RSVD(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_pcie_base_rsvd_0A                 0x00000028
#define NFP3800_PCIEX_PF_i_pcie_base_rsvd_0E                 0x00000038
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_rsvd_02A_02B(_x)   (0x000000a8 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_rsvd_02F          0x000000bc
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_rsvd_035          0x000000d4
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_rsvd_036          0x000000d8
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_rsvd_037_038(_x)  (0x000000dc + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_rsvd_03D_03F(_x)  (0x000000f4 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_AER_cap_struct_rsvd_04B_04D(_x)   (0x0000012c + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_rsvd_052_053(_x)   (0x00000148 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_rsvd_057 0x0000015c
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_rsvd_05C_05F(_x) (0x00000170 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_rsvd_090_09C(_x) (0x00000240 + (0x4 * ((_x) & 0xf)))
#define   NFP3800_PCIEX_PF_i_pcie_base_PF_generic_reserved_reg_cl_RSVD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_PF_generic_reserved_reg_cl_RSVD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_subsystem_vendor_id_subsystem_i -
    Bits: 31:16 SID(rw) - Subsystem ID: Specifies the Subsystem ID assigned by the manufacturer of the device. On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits: 15:0  SVID(rw) - Subsystem Vendor ID: Specifies the Subsystem Vendor ID assigned by the PCI SIG to the manufacturer of the device.On power-up, the Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_subsystem_vendor_id_subsystem_i 0x0000002c
#define   NFP3800_PCIEX_PF_i_pcie_base_i_subsystem_vendor_id_subsystem_i_SID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_subsystem_vendor_id_subsystem_i_SID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_subsystem_vendor_id_subsystem_i_SVID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_subsystem_vendor_id_subsystem_i_SVID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_expan_rom_base_addr -
    Bits: 31:12 RBARW(rw) - ROM Base Address: Defines the base address and range of the expansion ROM address space. The number of writeable bits in this field determines the size of the range (BAR aperture). All other bits are not writeable, and are read as 0's.
    Bits: 11    RBARO(ro) - ROM Base Address: Defines the base address and range of the expansion ROM address space. The number of writeable bits in this field determines the size of the range (BAR aperture). All other bits are not writeable, and are read as 0's.
    Bits:  7:1  R14(ro) - Reserved: Reserved
    Bits:  0    ADE(rw) - Address Decode Enable: This bit must be set to 1 by the configuration software to enable the expansion ROM. This bit can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr   0x00000030
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_RBARW(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_RBARW_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_RBARO BIT(11)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_R14(_x) (((_x) & 0x7f) << 1)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_R14_of(_x) (((_x) >> 1) & 0x7f)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_expan_rom_base_addr_ADE BIT(0)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_capabilities_pointer -
    Bits: 31:8  R15(ro) - Reserved: Reserved
    Bits:  7:0  CP(rw) - Capabilities Pointer: Contains pointer to the first PCI Capability Structure. This field is set by default to the value defined in the RTL file reg_defaults.h. It can be re-written independently for every Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_capabilities_pointer  0x00000034
#define   NFP3800_PCIEX_PF_i_pcie_base_i_capabilities_pointer_R15(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_capabilities_pointer_R15_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_capabilities_pointer_CP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_capabilities_pointer_CP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_pcie_base_i_intrpt_line_intrpt_pin -
    Bits: 31:11 R16(ro) - Reserved: Reserved
    Bits: 10:8  IPR(rw) - Interrupt Pin Register: Identifies the interrupt input (A, B, C, D) to which this Functions interrupt output is connected to (01 = INTA, 02 = INTB, 03 = INTC, 04 = INTD). The assignment of interrupt inputs to Functions is fixed when the Controller is configured. This field can be re-written independently for each Function from the local management bus. Please see the `define macros den_db_Fx_INTR_PIN values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  7:0  ILR(rw) - Interrupt Line Register: Identifies the IRQx input of the interrupt controller at the Root Complex that is activated by this Functions interrupt (00 = IRQ0, ... , 0F = IRQ15, FF = unknown or not connected). This field is writable from the local management bus. Please see the `define macros den_db_Fx_INTR_LINE values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin 0x0000003c
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_R16(_x) (((_x) & 0x1fffff) << 11)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_R16_of(_x) (((_x) >> 11) & 0x1fffff)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_IPR(_x) (((_x) & 0x7) << 8)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_IPR_of(_x) (((_x) >> 8) & 0x7)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_ILR(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_pcie_base_i_intrpt_line_intrpt_pin_ILR_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_mgmt_cap_struct_i_pwr_mgmt_cap -
    Bits: 31    PSDCS(ro) - PME Support for D3(cold) State: Indicates whether the Function is capable of sending PME messages when in the D3cold state. Because the device does not have aux power, this bit is hardwired to 0.
    Bits: 30    PSDHS(rw) - PME Support for D3(hot) Statue: Indicates whether the Function is capable of sending PME messages when in the D3hot state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 29    PSD2S(ro) - PME Support for D2 State: Indicates whether the Function is capable of sending PME messages when in the D2 state. This bit is hardwired to 0 because D2 state is not supported.
    Bits: 28    PSD1S(rw) - PME Support for D1 State: Indicates whether the Function is capable of sending PME messages when in the D1 state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 27    PSD0S(rw) - PME Support for D0 State: Indicates whether the Function is capable of sending PME messages when in the D0 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 26    D2S(ro) - D2 Support: Set if the Function supports the D2 power state. Currently hardwired to 0.
    Bits: 25    D1S(rw) - D1 Support: Set if the Function supports the D1 power state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 24:22 MCRAPS(ro) - Max Current Required from Aux Power Supply: Specifies the maximum current drawn by the device from the aux power source in the D3cold state. This field is not implemented in devices not supporting PME notification when in the D3cold state, and is therefore hardwired to 0.
    Bits: 21    DSI(ro) - Device Specific Initialization Bit: This bit, when set, indicates that the device requires additional configuration steps beyond setting up its PCI configuration space, to bring it to the D0 active state from the D0 uninitialized state. This bit is hardwired to 0.
    Bits: 20    R0(ro) - Reserved: Reserved
    Bits: 19    PC(ro) - PME Clock: Not applicable to PCI Express. This bit is hardwired to 0.
    Bits: 18:16 VID(rw) - Version ID: Indicates the version of the PCI Bus Power Management Specifications that the Function implements. This field is set by default to 011 (Version 1.2). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(rw) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. The Controller sets it to the value defined in the RTL file reg_defaults.h. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  CID(rw) - Capability ID: Identifies that the capability structure is for Power Management. This field is set by default to 01 hex. It can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap 0x00000088
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSDCS BIT(31)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSDHS BIT(30)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD2S BIT(29)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD1S BIT(28)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD0S BIT(27)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_D2S BIT(26)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_D1S BIT(25)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_MCRAPS(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_MCRAPS_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_DSI BIT(21)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_R0 BIT(20)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_PC BIT(19)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_VID(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_VID_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_cap_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep -
    Bits: 31:24 DR(ro) - Data Register: This optional register is not implemented in the Cadence PCIe Controller. This field is hardwired to 0.
    Bits: 23:16 R1(ro) - Reserved: Reserved
    Bits: 15    PMES(rw) - PME Status: When PME notification is enabled, writing a 1 into this bit position from the local management bus sets this bit and causes the Controller to send a PME message from the associated Function. When the Root Complex processes this message, it will turn off this bit by writing a 1 into this bit position through a Config Write. This bit can be set or cleared from the local management bus, by writing a 1 or 0, respectively. It can only be cleared from the configuration path (by writing a 1). This is a sticky field.
    Bits: 14:9  R2(ro) - Reserved: Reserved
    Bits:  8    PE(rw) - PME Enable: Setting this bit enables the notification of PME events from the associated Function. This bit can be set also by writing into this register from the local management bus. This is a sticky field.
    Bits:  7:4  R3(ro) - Reserved: Reserved
    Bits:  3    NSR(rw) - No Soft Reset: When this bit is set to 1, the Function will maintain all its state in the PM state D3hot. The software is not required to re-initialize the Function registers on the transition back to D0. This bit is set to 1 by default, but can be modified independently for each PF from the local management bus.
    Bits:  2    R4(ro) - Reserved: Reserved
    Bits:  1:0  PS(rw) - Power State: Indicates the power state this Function is currently in. This field can be read by the software to monitor the current power state, or can be written to cause a transition to a new state. The valid settings are 00 (state D0), 01 (state D1) and 11 (state D3hot). The software should not write any other value into this field. This field can also be written from the local management bus independently for each Function.
*/
#define NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep 0x0000008c
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_DR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_DR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PMES BIT(15)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R2(_x) (((_x) & 0x3f) << 9)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R2_of(_x) (((_x) >> 9) & 0x3f)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PE BIT(8)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R3(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R3_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_NSR BIT(3)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R4 BIT(2)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PS(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_i_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PS_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_ctrl_reg -
    Bits: 31:25 R0(ro) - Reserved: Reserved
    Bits: 24    MC(rw) - MSI masking capable: can be modified using localmanagement interface
    Bits: 23    BAC64(rw) - 64-Bit Address Capable: Set to 1 to indicate that the device is capable of generating 64-bit addresses for MSI messages.Can be modified using local management interface
    Bits: 22:20 MME(rw) - Multiple Message Enable: Encodes the number of distinct messages that the Controller is programmed to generate for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). This setting must be based on the number of interrupt inputs of the Controller that are actually used by this Function. This field can be written from the local management bus.
    Bits: 19:17 MMC(rw) - Multiple Message Capable: Encodes the number of distinct messages that the Controller is capable of generating for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). Thus, this field defines the number of the interrupt vectors for this Function. The Controller allows up to 32 distinct messages, but the setting of this field must be based on the number of interrupt inputs of the Controller that are actually used by the client. For example, if the client logic uses 8 of the 32 distinct MSI interrupt inputs of the Controller for this Function, then the value of this field must be set to 011. This field can be written from the local management bus. Please see the `define den_db_Fx_MSI_MULTIPLE_MSG_CAPABLE values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 16    ME(rw) - MSI Enable: Set by the configuration program to enable the MSI feature. This field can also be written from the local management bus.
    Bits: 15:8  CP1(rw) - Capabilities Pointer: Pointer to the next PCI Capability Structure. This can be modified from the local management bus. This field can be written from the local management bus.
    Bits:  7:0  CID1(ro) - Capability ID: Specifies that the capability structure is for MSI. Hardwired to 05 hex.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg     0x00000090
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_R0(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_R0_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_MC BIT(24)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_BAC64 BIT(23)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_MME(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_MME_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_MMC(_x) (((_x) & 0x7) << 17)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_MMC_of(_x) (((_x) >> 17) & 0x7)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_ME BIT(16)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_CP1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_CP1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_CID1(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_ctrl_reg_CID1_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_low_addr -
    Bits: 31:2  MAL(rw) - Message Address Low: Lower bits of the address to be used in MSI messages. This field can also be written from the local management bus.
    Bits:  1:0  R1(ro) - Reserved: The two lower bits of the address are hardwired to 0 to align the address on a double-word boundary.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_low_addr 0x00000094
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_low_addr_MAL(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_low_addr_MAL_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_low_addr_R1(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_low_addr_R1_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_hi_addr -
    Bits: 31:0  MAH(rw) - Message Address High: Contains bits 63:32 of the 64-bit address to be used in MSI Messages. A value of 0 specifies that 32-bit addresses are to be used in the messages. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_hi_addr  0x00000098
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_hi_addr_MAH(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_hi_addr_MAH_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_msg_data -
    Bits: 31:16 R2(ro) - Reserved: Hardwired to 0
    Bits: 15:0  MD(rw) - Message Data: Message data to be used for this Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_data     0x0000009c
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_data_R2(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_data_R2_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_data_MD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_msg_data_MD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_mask -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MM(rw) - MSI Mask: Mask bits for MSI interrupts. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid mask bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Mask field also changes correspondingly
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_mask         0x000000a0
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_mask_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_mask_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_mask_MM    BIT(0)
/*----------------------------------------------------------------
  Register: i_MSI_cap_struct_i_msi_pending_bits -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MP(ro) - MSI Pending Bits: Pending bits for MSI interrupts. A read from the location returns the state of the MSI_PENDING_STATUS_IN inputs of the Controller. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid pending bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Pending Bits field also changes correspondingly
*/
#define NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_pending_bits 0x000000a4
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_pending_bits_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_pending_bits_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_i_MSI_cap_struct_i_msi_pending_bits_MP BIT(0)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_ctrl -
    Bits: 31    MSIXE(rw) - MSI-X Enable: Set by the configuration program to enable the MSI-X feature. This field can also be written from the local management bus.
    Bits: 30    FM(rw) - Function Mask: This bit serves as a global mask to all the interrupt conditions associated with this Function. When this bit is set, the Controller will not send out MSI-X messages from this Function. This field can also be written from the local management bus.
    Bits: 29:27 R0(ro) - Reserved: Reserved
    Bits: 26:16 MSIXTS(rw) - MSI-X Table Size: Specifies the size of the MSI-X Table, that is, the number of interrupt vectors defined for the Function. The programmed value is 1 minus the size of the table (that is, this field is set to 0 if the table size is 1.). It can be re-written independently for each Function from the local management bus. Please see the `define den_db_Fx_MSIX_TABLE_SIZE values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 15:8  CP(rw) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. This is set to point to the PCI Express Capability Structure at 30 hex. This can be rewritten independently for each Function from the local management bus.
    Bits:  7:0  CID(rw) - Capability ID: Identifies that the capability structure is for MSI-X. This field is set by default to 11 hex. It can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl       0x000000b0
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_MSIXE BIT(31)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_FM  BIT(30)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_R0(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_R0_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_MSIXTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_MSIXTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_ctrl_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_tbl_offset -
    Bits: 31:3  TO(rw) - Table Offset: Offset of the memory address where the MSI-X Table is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned. Please see the `define den_db_Fx_MSIX_TABLE_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the MSI-X Table is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). Please see the `define den_db_Fx_MSIX_TABLE_BIR values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_tbl_offset 0x000000b4
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_tbl_offset_TO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_tbl_offset_TO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_tbl_offset_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_tbl_offset_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_MSIX_cap_struct_i_msix_pending_intrpt -
    Bits: 31:3  PBAO(rw) - PBA Offset: Offset of the memory address where the PBA is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned. Please see the `define den_db_Fx_MSIX_PBA_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  2:0  BARI1(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register. Please see the `define den_db_Fx_MSIX_PBA_BIR values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_pending_intrpt 0x000000b8
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_pending_intrpt_PBAO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_pending_intrpt_PBAO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_pending_intrpt_BARI1(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_MSIX_cap_struct_i_msix_pending_intrpt_BARI1_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_cap_list -
    Bits: 31    R0(ro) - Reserved: Reserved
    Bits: 30    TRS(ro) - TCS Routing Supported: When set to 1, this bit indicates that the device supports routing of Trusted Configuration Requests. Not valid for Endpoints. Hardwired to 0.
    Bits: 29:25 IMN(ro) - Interrupt Message Number: Identifies the MSI or MSI-X interrupt vector for the interrupt message generated corresponding to the status bits in the Slot Status Register, Root Status Register, or this capability structure. This field must be defined based on the chosen interrupt mode - MSI or MSI-X. This field is hardwired to 0.
    Bits: 24    SS(ro) - Slot Status: Set to 1 when the link connected to a slot. Hardwired to 0.
    Bits: 23:20 DT(ro) - Device Type: Indicates the type of device implementing this Function. This field is hardwired to 0 in the EP mode.
    Bits: 19:16 PCV(rw) - Capability Version: Identifies the version number of the capability structure. This field is set to 2 by default to indicate that the Controller is compatible to PCI Express Base Specification Revision 3.0. This field can be modified through local management interface.
    Bits: 15:8  NCP(ro) - Next Capability Pointer: Points to the next PCI capability structure. Set to 0 because this is the last capability structure.
    Bits:  7:0  CID(ro) - Capability ID: Specifies Capability ID assigned by PCI SIG for this structure. This field is hardwired to 10 hex.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list   0x000000c0
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_R0 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_TRS BIT(30)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_IMN(_x) (((_x) & 0x1f) << 25)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_IMN_of(_x) (((_x) >> 25) & 0x1f)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_SS BIT(24)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_DT(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_DT_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_PCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_PCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_NCP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_NCP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_cap_list_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_cap -
    Bits: 31:29 R3(ro) - Reserved: Reserved
    Bits: 28    FC(rw) - FLR Capable: Set when device has Function-Level Reset capability. It is set by default to 1. It can be re-written independently for each Function from the local management bus.
    Bits: 27:26 CPLS(rw) - Captured Power Limit Scale: Specifies the scale used by Slot Power Limit Value. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 25:18 CSPLV(rw) - Captured Slot Power Limit Value: Specifies upper limit on power supplied by slot. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 17:16 R2(ro) - Reserved: Reserved
    Bits: 15    RBER(rw) - Role-Based Error Reporting: Enables role-based error reporting. It is hardwired to 1.It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 R1(ro) - Reserved: Reserved
    Bits: 11:9  AL1SL(rw) - Acceptable L1 Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L1 to L0. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits:  8:6  AL0SL(rw) - Acceptable L0S Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L0S to L0. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits:  5    ETFS(rw) - Extended Tag Field Supported: Set when device allows the tag field to be extended from 5 to 8 bits. It can be rewritten independently for each Function from the local management bus.
    Bits:  4:3  PFS(ro) - Phantom Functions Supported: This field is used to extend the tag field by combining unused Function bits with the tag bits. This field is hardwired to 00 to disable this feature.
    Bits:  2:0  MPS(rw) - Max Payload Size: Specifies maximum payload size supported by the device.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap    0x000000c4
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R3(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R3_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_FC BIT(28)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_CPLS(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_CPLS_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_CSPLV(_x) (((_x) & 0xff) << 18)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_CSPLV_of(_x) (((_x) >> 18) & 0xff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R2_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_RBER BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R1(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_R1_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_AL1SL(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_AL1SL_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_AL0SL(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_AL0SL_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_ETFS BIT(5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_PFS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_PFS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_MPS(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_MPS_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_ctrl_status -
    Bits: 31:22 R4(ro) - Reserved: Reserved
    Bits: 21    TP(ro) - Transaction Pending: Indicates if any of the Non-Posted requests issued by the Function are still pending.
    Bits: 20    APD(ro) - Aux Power Detected: Set when auxiliary power is detected by the device. This is an unused field.
    Bits: 19    URD(w1c) - Unsupported Request Detected: Set to 1 by the Controller when it receives an unsupported request, regardless of whether its reporting is enabled or not.
    Bits: 18    FED(w1c) - Fatal Error Detected: Set to 1 by the Controller when it detects a fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 17    NFED(w1c) - Non-Fatal Error Detected: Set to 1 by the Controller when it detects a non-fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 16    CED(w1c) - Correctable Error Detected: Set to 1 by the Controller when it detects a correctable error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 15    FLR(rw) - Function-Level Reset: Writing a 1 into this bit position generates a Function-Level Reset for the selected Function. This bit reads as 0.
    Bits: 14:12 MRRS(rw) - Max Read Request Size: Specifies the maximum size allowed in read requests generated by the device.
    Bits: 11    ENS(rw) - Enable No Snoop: When set to 1, the device is allowed to set the No Snoop bit in initiated transactions in which cache coherency is not needed.
    Bits: 10    EAP(ro) - Enable Aux Power: Used only when device used aux power. This field is hardwired to 0.
    Bits:  9    EPH(ro) - Enable Phantom Functions: This field is hardwired to 0 as the Controller does not support this feature.
    Bits:  8    ETFE(rw) - Extended Tag Field Enable: Enables the extension of the tag field from 5 to 8 bits.
    Bits:  7:5  MPS(rw) - Max Payload Size: Specifies the maximum TLP payload size configured. The device must be able to receive a TLP of this maximum size, and should not generate TLPs larger than this value. The configuration program sets this field based on the maximum payload size in the Device Capabilities Register, and the capability of the other side.
    Bits:  4    ERO(rw) - Enable Relaxed Ordering: When set, this bit indicates that the device is allowed to set the Relaxed Ordering bit in the Attributes field of transactions initiated from it, when the transactions do not require Strong Ordering.
    Bits:  3    EURR(rw) - Enable Unsupported Request Reporting: Enables the sending of error messages by the Controller on receiving unsupported requests.
    Bits:  2    EFER(rw) - Enable Fatal Error Reporting: Enables the sending of ERR_FATAL messages by the Controller on the detection of fatal errors.
    Bits:  1    ENFER(rw) - Enable Non-Fatal Error Reporting: Enables the sending of ERR_NONFATAL messages by the Controller on the detection of non-fatal errors.
    Bits:  0    ECER(rw) - Enable Correctable Error Reporting: Enables the sending of ERR_COR messages by the Controller on the detection of correctable errors.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status 0x000000c8
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_R4(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_R4_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_TP BIT(21)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_APD BIT(20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_URD BIT(19)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_FED BIT(18)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_NFED BIT(17)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_CED BIT(16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_FLR BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_MRRS(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_MRRS_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_ENS BIT(11)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_EAP BIT(10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_EPH BIT(9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_ETFE BIT(8)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_MPS(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_MPS_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_ERO BIT(4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_EURR BIT(3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_EFER BIT(2)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_ENFER BIT(1)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_ECER BIT(0)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_cap -
    Bits: 31:24 PN(ro) - Port Number: Specifies the port number assigned to the PCI Express link connected to this device.
    Bits: 23    R5(ro) - Reserved: Reserved
    Bits: 22    AOC(rw) - ASPM Optionality Compliance: Setting this bit indicates that the device supports the ASPM Optionality feature. It can be turned off by writing a 0 to this bit position through the local management bus.
    Bits: 21    LBNC(ro) - Link Bandwidth Notification Capability: A value of 1b indicates support for the Link Bandwidth Notification status and interrupt mechanisms. Reserved for Endpoint.
    Bits: 20    DLLARC(ro) - Data Link Layer Active Reporting Capability: Set to 1 if the device is capable of reporting that the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0, as this version of the Controller does not support the feature.
    Bits: 19    SDERC(ro) - Surprise Down Error Reporting Capability: Indicates the capability of the device to report a Surprise Down error condition. This bit is hardwired to 0, as this version of the Controller does not support the feature.
    Bits: 18    CPM(rw) - Clock Power Management: Indicates that the device supports removal of referenc clocks. It is set by default to the value of the define in reg_defaults.h. It can be re-written independently for each function from the local management bus.
    Bits: 17:15 L1EL(rw) - L1 Exit Latency: Specifies the exit latency from L1 state. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 L0SEL(rw) - L0S Exit Latency: Specifies the time required for the device to transition from L0S to L0. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 11:10 ASPM(rw) - Active State Power Management: Indicates the level of ASPM support provided by the device. This field can be re-written independently for each Function from the local management bus. When SRIS is enabled in local management register bit, L0s capability is not supported and is forced low.
    Bits:  9:4  MLW(ro) - Maximum Link Width: Indicates the maximum number of lanes supported by the device. This field is hardwired based on the setting of the LANE_COUNT_IN strap input.
    Bits:  3:0  MLS(ro) - Maximum Link Speed: Indicates the maximum speed supported by the link. (2.5 GT/s, 5 GT/s, 8 GT/s per lane). This field is hardwired to 0001 (2.5GT/s) when the strap input PCIE_GENERATION_SEL is set to 0, to 0010 (5 GT/s) when the strap is set to 1, and to 0011 (8 GT/s) when the strap input is set to 10.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap        0x000000cc
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_PN(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_PN_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_R5   BIT(23)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_AOC  BIT(22)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_LBNC BIT(21)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_DLLARC BIT(20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_SDERC BIT(19)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_CPM  BIT(18)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_L1EL(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_L1EL_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_L0SEL(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_L0SEL_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_ASPM(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_ASPM_of(_x) (((_x) >> 10) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_MLW(_x) (((_x) & 0x3f) << 4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_MLW_of(_x) (((_x) >> 4) & 0x3f)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_MLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_MLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_ctrl_status -
    Bits: 31    LABS(w1c) - Link Autonomous Bandwidth Status: This bit is Set by hardware to indicate that hardware has autonomously changed Link speed or width, without the Port transitioning through DL_Down status, for reasons other than to attempt to correct unreliable Link operation. This triggers an interrupt to be generated through PHY_INTERRUPT_OUT if enabled. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 30    LBMS(w1c) - Link Bandwidth Management Status: This bit is Set by hardware to indicate that either link training has completed following write to retrain link bit, or when HW has changed link speed or width to attempt to correct unreliable link operation. This triggers an interrupt to be generated through PHY_INTERRUPT_OUT if enabled. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 29    DLLA(ro) - Data Link Layer Active: Indicates the status of the Data Link Layer. Set to 1 when the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0 in this version of the Controller.
    Bits: 28    SCC(rw) - Slot Clock Configuration: This bit indicates that the component uses the same physical reference clock that the platform provides on the connector. If the device uses an independent clock irrespective of the presence of a reference clock on the connector, this bit must be clear. For PF0, this bit can also be written from the local management bus.
    Bits: 27    LTS(ro) - Link Training Status: This read-only bit indicates that the Physical Layer LTSSM is in the Configuration or Recovery state, or that 1b was written to the Retrain Link bit but Link training has not yet begun. Hardware clears this bit when the LTSSM exits the Configuration/Recovery state. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 26    R8(ro) - Reserved: Reserved
    Bits: 25:20 NLW(ro) - Negotiated Link Width: Set at the end of link training to the actual link width negotiated between the two sides. Value is undefined if this regsiters is accessed before link training.
    Bits: 19:16 NLS(ro) - Negotiated Link Speed: Negotiated link speed of the device. The only supported speed ids are 2.5 GT/s per lane (0001),5 GT/s per lane (0010),8 GT/s per lane (0011).
    Bits: 15:12 R15_12(ro) - Reserved: Reserved
    Bits: 11    LABIE(ro) - Link Autonomous Bandwidth Interrupt Enable: When Set, this bit enables the generation of an interrupt to indicate that the Link Autonomous Bandwidth Status bit has been Set. This enables an interrupt to be generated through PHY_INTERRUPT_OUT if triggered. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits: 10    LBMIE(ro) - Link Bandwidth Management Interrupt Enable: When Set, this bit enables the generation of an interrupt to indicate that the Link Bandwidth Management Status bit has been Set. This enables an interrupt to be generated through PHY_INTERRUPT_OUT if triggered. Hardwired to 0 if Link Bandwidth Notification Capability is 0. Not applicable to Endpoints where field is hardwired to 0.
    Bits:  9    HAWD(rw) - Hardware Autonomous Width Disable: When this bit is set, the local application must not request to change the operating width of the link, other than attempting to correct unreliable Link operation by reducing Link width.
    Bits:  8    ECPM(ro) - Enable Clock Power Management: When this bit is set to 1, the device may use the CLKREQ# pin on the PCIe connector to power manage the Link clock. This bit is writeable only when the Clock Power Management bit in the Link Capability Register is set to 1.
    Bits:  7    ES(rw) - Extended Synch: Set to 1 to extend the sequence of ordered sets transmitted while exiting from the L0S state.
    Bits:  6    CCC(rw) - Common Clock Configuration: A value of 0 indicates that the reference clock of this device is asynchronous to that of the upstream device. A value of 1 indicates that the reference clock is common.
    Bits:  5    RL(ro) - Retrain Link: Setting this bit to 1 causes the LTSSM to initiate link training. Reserved for Endpoint mode. This bit always reads as 0
    Bits:  4    LD(ro) - Link Disable: Writing a 1 to this bit position causes the LTSSM to go to the Disable Link state. The LTSSM stays in the Disable Link state while this bit is set.Reserved for Endpoint mode.
    Bits:  3    RCB(rw) - Read Completion Boundary: Indicates the Read Completion Boundary of the Root Port connected to this Endpoint (0 = 64 bytes, 1 = 128 bytes). This field can be written from the local management bus with the input signal MGMT_TYPE1_CONFIG_REG_ACCESS high.
    Bits:  2    R6(ro) - Reserved: Reserved
    Bits:  1:0  ASPMC(rw) - Active State Power Management Control: Controls the level of ASPM support on the PCI Express link associated with this Function. The valid setting are 00: ASPM disabled 01: L0s entry enabled, L1 disabled 10: L1 entry enabled, L0s disabled 11: Both L0s and L1 enabled.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status 0x000000d0
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LABS BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LBMS BIT(30)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_DLLA BIT(29)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_SCC BIT(28)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LTS BIT(27)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_R8 BIT(26)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_NLW(_x) (((_x) & 0x3f) << 20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_NLW_of(_x) (((_x) >> 20) & 0x3f)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_NLS(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_NLS_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_R15_12(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_R15_12_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LABIE BIT(11)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LBMIE BIT(10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_HAWD BIT(9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_ECPM BIT(8)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_ES BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_CCC BIT(6)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_RL BIT(5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_LD BIT(4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_RCB BIT(3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_R6 BIT(2)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_ASPMC(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_ASPMC_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_cap_2 -
    Bits: 31:24 R14(ro) - Reserved: Reserved
    Bits: 23:22 MEEP(ro) - Max End-End TLP Prefixes: Indicates the maximum number of End-End TLP Prefixes supported by the Function. The supported values are: 01b 1 End-End TLP Prefix 10b 2 End-End TLP Prefixes
    Bits: 21    EEPS(ro) - End-End TLP Prefix Supported: Indicates whether the Function supports End-End TLP Prefixes. A 1 in this field indicates that the Function supports receiving TLPs containing End-End TLP Prefixes.
    Bits: 20    EXFS(ro) - Extended Format Field Supported: Indicates that the Function supports the 3-bit definition of the Fmt field in the TLP header. This bit is hardwired to 1 for all Functions.
    Bits: 19:18 OPFFS(ro) - OBFF Supported: A 1 in this bit position indicates that the Function supports the Optimized Buffer Flush/Fill (OBFF) capability using message signaling.
    Bits: 15:14 R13(ro) - Reserved: Reserved
    Bits: 12    TCS(rw) - TPH Completer Supported: These bits, when set, indicate that the Function is capable of serving as a completer for requests with Transaction Processing Hints (TPH). It can be turned off for all Physical Functions by writing into PF 0. Defined Encodings are: 00b TPH and Extended TPH Completer not supported. 01b TPH Completer supported Extended TPH Completer not supported. 10b Reserved. 11b Both TPH and Extended TPH Completer supported. Extended Streering tag is not selected in this configuration. only bit 0 is writtable from client side.
    Bits: 11    LMS(rw) - LTR Mechanism Supported: A 1 in this bit position indicates that the Function supports the Latency Tolerance Reporting (LTR) Capability. This bit is set to 1 by default, but can be turned off for all Physical Functions by writing into PF 0.
    Bits: 10    R12(ro) - Reserved: Reserved
    Bits:  9    BAOCS128(rw) - 128-Bit CAS Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for the Compare-and- Swap (CAS) Atomic Operation with 128-bit operands. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  8    BAOCS64(rw) - 64-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 64-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  7    BAOCS32(rw) - 32-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 32-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  6    OPRS(ro) - OP routing supported: Atomic OP routing supported.
    Bits:  5    AFS(ro) - ARI forwarding support: ARI forwarding supported. This field is hard coded to zero
    Bits:  4    CTDS(rw) - Completion Timeout Disable Supported: A 1 in this field indicates that the associated Function supports the capability to turn off its Completion timeout. This bit is set to 1 by default, but can be re-written independently for each Function from the local management bus.
    Bits:  3:0  CTR(rw) - Completion Timeout Ranges: Specifies the Completion Timeout values supported by the device. This field is set by default to 0010 (10 ms - 250 ms). The actual timeout values are in two programmable local management registers, which allow the timeout settings of the two sub-ranges within Range B to be programmed independently.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2  0x000000e4
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_R14(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_R14_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_MEEP(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_MEEP_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_EEPS BIT(21)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_EXFS BIT(20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_OPFFS(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_OPFFS_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_R13(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_R13_of(_x) (((_x) >> 14) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_TCS BIT(12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_LMS BIT(11)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_R12 BIT(10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS128 BIT(9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS64 BIT(8)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS32 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_OPRS BIT(6)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_AFS BIT(5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_CTDS BIT(4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_CTR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_cap_2_CTR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2 -
    Bits: 31:15 R18(ro) - Reserved: Reserved
    Bits: 14:13 OBFFE(ro) - OBFF Enable: Enables the Optimized Buffer Flush/Fill (OBFF) capability in the device. This field is implemented only in PF 0. Valid settings are 00 (disabled), 01 (Variation A) and 10 (Variation B). This field can also be written from the local management bus. RW if OBFF capability is supported, RO otherwise.
    Bits: 11    R17(ro) - Reserved: Reserved
    Bits: 10    LTRME(rw) - LTR Mechanism Enable: This must be set to 1 to enable the Latency Tolerance Reporting Mechanism. This bit is implemented only in PF 0. Its default value is 1, but can be modified from the local management bus. This bit is read-only in PF 1.
    Bits:  9    IDOCE(rw) - IDO Completion Enable: When this bit is 1, the Function is allowed to set the ID-based Ordering (IDO) Attribute bit in the Completions it generates.
    Bits:  8    IDORE(rw) - IDO Request Enable: When this bit is 1, the Function is allowed to set the ID-based Ordering (IDO) Attribute bit in the requests it generates.
    Bits:  7    R16(ro) - Reserved: Reserved
    Bits:  6    AORE(rw) - Atomic Op Requester Enable: This bit must be set to enable the generation of Atomic Op Requests from the Function. If the client logic attempts to send an Atomic Op for a Function for which this bit is not set, logic in the Controller will nullify the TLP on its way to the link. This bit can also be written from the local management bus.
    Bits:  5    AFE(ro) - ARI forwarding enable: ARI forwarding enable
    Bits:  4    CTD(rw) - Completion Timeout Disable: Setting this bit disables Completion Timeout in the device. This bit can also be written from the local management bus.
    Bits:  3:0  CTV(rw) - Completion Timeout Value: Specifies the Completion Timeout value for the device. Allowable values are 0101 (sub-range 1) and 0110 (sub-range 2). The corresponding timeout values are stored in the local management registers Completion Timeout Interval Registers 0 and 1, respectively. Value of 0selects completion timeout from Completion-Timeout-Interval-Registers-0 in local managementregister.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2 0x000000e8
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_R18(_x) (((_x) & 0x1ffff) << 15)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_R18_of(_x) (((_x) >> 15) & 0x1ffff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_OBFFE(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_OBFFE_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_R17 BIT(11)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_LTRME BIT(10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_IDOCE BIT(9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_IDORE BIT(8)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_R16 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_AORE BIT(6)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_AFE BIT(5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_CTD BIT(4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_CTV(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_pcie_dev_ctrl_status_2_CTV_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_cap_2_reg -
    Bits: 31    R31(ro) - DRS Supported: Indicates support for the optional Device Readiness Status (DRS) capability. This capability is currently not supported in the Controller.
    Bits: 30:25 R25(ro) - Reserved: Reserved
    Bits: 24:23 R23(ro) - Reserved: Reserved
    Bits: 22:20 R3(ro) - Reserved: Reserved
    Bits: 18:16 LSORSSV(rw) - Lower SKP OS Reception Supported Speeds Vector: If this field is non-zero, it indicates that the Port, when operating at the indicated speed(s) supports SRIS and also supports receiving SKP OS at the rate defined for SRNS while running in SRIS.
    Bits: 15:12 R2(ro) - Reserved: Reserved
    Bits: 11:9  LSOGSSV(rw) - Lower SKP OS Generation Supported Speeds Vector: If this field is non-zero, it indicates that the Port, when operating at the indicated speed(s) supports SRIS and also supports software control of the SKP Ordered Set transmission scheduling rate.
    Bits:  8:5  R1(ro) - Reserved: Reserved
    Bits:  3:1  SLSV(rw) - Supported Link Speeds Vector: This field indicates the supported link speeds of the Controller. For each bit, a value of 1 indicates that the corresponding link speed is supported, while a value of 0 indicates that the corresponding speed is not supported. The bits corresponding to various link speeds are: Bit 1 = Link Speed 2.5 GT/s, Bit 2 = Link Speed 5 GT/s, Bit 3 = Link Speed 8 GT/s. This field is hardwired to 0001 (2.5 GT/s) when the PCIE_GENERATION_SEL strap pins of the Controller are set to 0, 0011 (2.5 and 5 GT/s) when the strap is set to 1 , and 0111 (2.5, 5, and 8 GT/s) when the strap pin is set to 10 For PF0, this field can be written through the LM interface.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg  0x000000ec
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R31 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R25(_x) (((_x) & 0x3f) << 25)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R25_of(_x) (((_x) >> 25) & 0x3f)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R23(_x) (((_x) & 0x3) << 23)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R23_of(_x) (((_x) >> 23) & 0x3)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R3(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R3_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_LSORSSV(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_LSORSSV_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R2(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R2_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_LSOGSSV(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_LSOGSSV_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R1(_x) (((_x) & 0xf) << 5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_R1_of(_x) (((_x) >> 5) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_SLSV(_x) (((_x) & 0x7) << 1)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_cap_2_reg_SLSV_of(_x) (((_x) >> 1) & 0x7)
/*----------------------------------------------------------------
  Register: i_PCIE_cap_struct_i_link_ctrl_status_2 -
    Bits: 31:22 R21(ro) - Reserved: Reserved
    Bits: 21    LE(rw) - Link Equalization Request 8.0 GT/s: This bit can be set by the software running on the EndPoint to force the Endpoint to perform link equalization for 8.0 GT/s. Setting this bit causes the LTSSM of the Controller to enter the Recovery state and request its link partner to perform equalization. This bit is cleared when the LTSSM enters the Recovery.Equalization state. It can also be cleared by writing a 1 to this bit position by the host, or writing a 0 from the LMI. STICKY.
    Bits: 20    EP3S(ro) - Equalization 8.0 GT/s Phase 3 Successful: This bit, when set to 1, indicates that the Phase 3 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 19    EP2S(ro) - Equalization 8.0 GT/s Phase 2 Successful: This bit, when set to 1, indicates that the Phase 2 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 18    EP1S(ro) - Equalization 8.0 GT/s Phase 1 Successful: This bit, when set to 1, indicates that the Phase 1 of the Transmitter Equalization procedure has completed successfully for 8.0 GT/s. STICKY.
    Bits: 17    EQC(ro) - Equalization 8.0 GT/s Complete: This bit, when set to 1, indicates that the Transmitter Equalization procedure has completed for 8.0 GT/s. STICKY.
    Bits: 16    CDEL(ro) - Current De-Emphasis Level: This status bit indicates the current operating de-emphasis level of the transmitter (0 = -6 dB, 1 = -3.5 dB).This field is undefined when link is not at Gen2 speed.
    Bits: 15:12 CDE(rw) - Compliance De-Emphasis: This bit sets the de-emphasis level (for 5 GT/s operation) or the Transmitter Preset level (for 8 GT/s operation) when the LTSSM enters the Polling.Compliance state because of software setting the Enter Compliance bit in this register. It is used only when the link is running at 5 GT/s or 8 GT/s. At 5 GT/s, the only valid setting are 0 (-6 dB) and 1 (-3.5 dB). STICKY.
    Bits: 11    CS(rw) - Compliance SOS: When this bit is set to 1, the device will transmit SKP ordered sets between compliance patterns. STICKY.
    Bits: 10    EMC(rw) - Enter Modified Compliance: This field is intended for debug and compliance testing purposes only. If this bit is set to 1, the device will transmit the Modified Compliance Pattern when the LTSSM enters the Polling. Compliance substate. Note: Setting this bit alone will not cause the LTSSM to enter Polling.Compliance. The Enter Compliance bit must also be set and a Hot Reset needs to be initiated by Host to enter Polling.Compliance. STICKY.
    Bits:  9:7  TM(rw) - Transmit Margin: This field is intended for debug and compliance testing purposes only. It controls the non-de-emphasized voltage level at the transmitter outputs. Its encodings are: 000: Normal operating range. 001: 800 - 1200 mV for full swing and 400 - 700 mV for half swing. 010 - 111: See PCI Express Base Specification 2.0. This field is reset to 0 when the LTSSM enters the Polling.Configuration substate during link training. STICKY.
    Bits:  6    SDE(ro) - Selectable De-emphasis: This bit selects the de-emphasis level when the Controller is operating at 5 GT/s (0 = -6 dB, 1 = -3.5 dB). This is reserved for Endpoints.
    Bits:  5    HASD(rw) - Hardware Autonomous Speed Disable: When this bit is set, the LTSSM is prevented from changing the operating speed of the link, other than reducing the speed to correct unreliable operation of the link. STICKY
    Bits:  4    EC(rw) - Enter Compliance: This bit is used to force the Endpoint device to enter the Compliance mode. Software sets this bit to 1 and initiates a hot reset to force the device into the Compliance mode. The target speed for the Compliance mode is determined by the Target Link Speed field of this register. STICKY.
    Bits:  3:0  TLS(rw) - Target Link Speed: For an upstream component, this field sets an upper limit on Link operational speed during reconfiguration. Additionally for both upstream and downstream components, this field sets the target speed when the software forces the link into Compliance mode by setting the Enter Compliance bit in this register (0001 = 2.5 GT/s, 0010 = 5 GT/s, 0011 = 8 GT/s). The default value of this field is 0001 (2.5 GT/s) when the PCIE_GENERATION_SEL strap pins of the Controller are set to 0, 0010 (5 GT/s) when the strap is set to 1, 0011 (8 GT/s) when the strap pin is set to 10. These bits are STICKY.
*/
#define NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2 0x000000f0
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_R21(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_R21_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_LE BIT(21)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EP3S BIT(20)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EP2S BIT(19)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EP1S BIT(18)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EQC BIT(17)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_CDEL BIT(16)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_CDE(_x) (((_x) & 0xf) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_CDE_of(_x) (((_x) >> 12) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_CS BIT(11)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EMC BIT(10)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_TM(_x) (((_x) & 0x7) << 7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_TM_of(_x) (((_x) >> 7) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_SDE BIT(6)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_HASD BIT(5)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_EC BIT(4)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_TLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_cap_struct_i_link_ctrl_status_2_TLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_AER_enhanced_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 4'h2, but can be modified from the local management bus.
    Bits: 15:0  PEECI(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express AER Extended Capability Structure (0001 hex).
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr 0x00000100
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_PEECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_AER_enhanced_cap_hdr_PEECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_status -
    Bits: 31:23 R3(ro) - Reserved:
    Bits: 22    UIE(w1c) - Uncorrectable Internal Error Status: This bit is set when the Controller has detected an internal uncorrectable error (HAL parity error or an uncorrectable ECC error while reading from any of the RAMs). This bit is also set in response to the client signaling an internal error through the input UNCORRECTABLE_ERROR_IN. This error is not Function-specific. This error is considered fatal by default, and is reported by sending an ERR_FATAL message. STICKY.
    Bits: 21    R2(ro) - Reserved: Reserved
    Bits: 20    URES(w1c) - Unsupported Request Error Status: This bit is set when the Controller has received a request from the link that it does not support. This error is not Function-specific. This error is considered non-fatal by default. In the special case described in Sections 6.2.3.2.4.1 of the PCI Express Specifications, the error is reported by sending an ERR_COR message. In all other cases, the error is reported by sending an ERR_NONFATAL message. The header of the received request that caused the error is logged in the Header Log Registers. STICKY.
    Bits: 19    EES(w1c) - ECRC Error Status: This bit is set when the Controller has detected an ECRC error in a received TLP. This error is not Function-specific. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 18    MTS(w1c) - Malformed TLP Status: This bit is set when the Controller receives a malformed TLP from the link. This error is not Function-specific. This error is considered fatal by default, and is reported by sending an ERR_FATAL message. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 17    ROS(w1c) - Receiver Overflow Status: This bit is set when the Controller receives a TLP in violation of the receive credit currently available. This error is not Function-specific. STICKY.
    Bits: 16    UCS(w1c) - Unexpected Completion Status: This bit is set when the Controller has received an unexpected Completion packet from the link. This error is not Function-specific. STICKY.
    Bits: 15    CAS(w1c) - Completer Abort Status: This bit is set when the Controller has returned the Completer Abort (CA) status to a request received from the link. This error is Function-specific. The header of the received request that caused the error is logged in the Header Log Registers. STICKY.
    Bits: 14    CTS(w1c) - Completion Timeout Status: This bit is set when the completion timer associated with an outstanding request times out. This error is Function-specific. This error is considered non-fatal by default. STICKY.
    Bits: 13    FCPES(w1c) - Flow Control Protocol Error Status: This bit is set when certain violations of the flow control protocol are detected by the Controller. Controller reports FCPE upon the following conditions: (i) InitFC/UpdateFC DLLP received which issues more than 2047 cumulative outstanding unused credits to the Transmitter for data payload or 127 for header. (ii) InitFC_P is received with Payload Credits less than 128B, Or (iii)InitFC_CPL is received with Payload Credits less than 128B. This error is not Function-specific STICKY.
    Bits: 12    PTS(w1c) - Poisoned TLP Status: This bit is set when the Controller receives a poisoned TLP from the link. This error is Function-specific. This error is considered non-fatal by default. The error is reported by sending an ERR_NONFATAL message. The header of the received TLP with error is logged in the Header Log Registers. STICKY.
    Bits: 11:5  R1(ro) - Reserved: Reserved
    Bits:  4    DLPES(w1c) - Data Link Protocol Error Status: This bit is set when the Controller receives an Ack or Nak DLLP whose sequence number does not correspond to that of an unacknowledged TLP or that of the last acknowledged TLP (for details, refer to PCI Express Base Specification 1.1, Section 3.5.2). This error is not Function-specific, and is reported by Function 0. STICKY.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status 0x00000104
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R3(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R3_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_UIE BIT(22)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R2 BIT(21)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_URES BIT(20)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_EES BIT(19)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_MTS BIT(18)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_ROS BIT(17)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_UCS BIT(16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_CAS BIT(15)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_CTS BIT(14)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_FCPES BIT(13)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_PTS BIT(12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R1(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R1_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_DLPES BIT(4)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_status_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_mask -
    Bits: 31:23 R7(ro) - Reserved: Reserved
    Bits: 22    UIEM(rw) - Uncorrectable Internal Error Mask: This bit is set to mask the reporting of internal errors. STICKY.
    Bits: 21    R6(ro) - Reserved: Reserved
    Bits: 20    UREM(rw) - Unsupported Request Error Mask: This bit is set to mask the reporting of unexpected requests received from the link. STICKY.
    Bits: 19    EEM(rw) - ECRC Error Mask: This bit is set to mask the reporting of ECRC errors. STICKY.
    Bits: 18    MTM(rw) - Malformed TLP Mask: This bit is set to mask the reporting of malformed TLPs received from the link. STICKY.
    Bits: 17    ROM(rw) - Receiver Overflow Mask: This bit is set to mask the reporting of violations of receive credit. STICKY.
    Bits: 16    UCM(rw) - Unexpected Completion Mask: This bit is set to mask the reporting of unexpected Completions received by the Controller. STICKY.
    Bits: 15    CAM(rw) - Completer Abort Mask: This bit is set to mask the reporting of the Controller sending a Completer Abort. STICKY.
    Bits: 14    CTM(rw) - Completion Timeout Mask: This bit is set to mask the reporting of Completion Timeouts. STICKY.
    Bits: 13    FCPEM(rw) - Flow Control Protocol Error Mask: This bit is set to mask the reporting of Flow Control Protocol Errors. STICKY.
    Bits: 12    PTM(rw) - Poisoned TLP Mask: This bit is set to mask the reporting of a Poisoned TLP. STICKY.
    Bits: 11:5  R5(ro) - Reserved: Reserved
    Bits:  4    DLPEM(rw) - Data Link Protocol Error Mask: This bit is set to mask the reporting of Data Link Protocol Errors. STICKY.
    Bits:  3:0  R4(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask  0x00000108
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R7(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R7_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_UIEM BIT(22)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R6 BIT(21)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_UREM BIT(20)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_EEM BIT(19)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_MTM BIT(18)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_ROM BIT(17)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_UCM BIT(16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_CAM BIT(15)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_CTM BIT(14)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_FCPEM BIT(13)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_PTM BIT(12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R5(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R5_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_DLPEM BIT(4)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R4(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_mask_R4_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_uncorr_err_severity -
    Bits: 31:23 R12(ro) - Reserved: Reserved
    Bits: 22    UIES(rw) - Uncorrectable Internal Error Severity: Severity of internal errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 21    R11(ro) - Reserved: Reserved
    Bits: 20    URES(rw) - Unsupported Requeset Error Severity: Severity of unexpected requests received from the link (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 19    EES(rw) - ECRC Error Severity: Severity of ECRC errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 18    MTS(rw) - Malformed TLP Severity: Severity of malformed TLPs received from the link (0 = Non- Fatal, 1 = Fatal). STICKY.
    Bits: 17    ROS(rw) - Receiver Overflow Severity: Severity of receive credit violations (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 16    UCS(rw) - Unexpected Completion Severity: Severity of unexpected Completions received by the Controller (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 15    CAS(rw) - Completer Abort Severity: Severity of sending a Completer Abort (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 14    CTS(rw) - Completion Timeout Severity: Severity of Completion Timeouts (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 13    FCPES(rw) - Flow Control Protocol Error Severity: Severity of Flow Control Protocol Errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 12    PTS(rw) - Poisoned TLP Severity: Severity of a Poisoned TLP error (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits: 11:6  R10(ro) - Reserved: Reserved
    Bits:  5    SDES(ro) - Surprise Down Error Severity: hard coded to 1
    Bits:  4    DLPER(rw) - Data Link Protocol Error Severity: Severity of Data Link Protocol Errors (0 = Non-Fatal, 1 = Fatal). STICKY.
    Bits:  3:0  R8(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity 0x0000010c
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R12(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R12_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_UIES BIT(22)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R11 BIT(21)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_URES BIT(20)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_EES BIT(19)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_MTS BIT(18)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_ROS BIT(17)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_UCS BIT(16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_CAS BIT(15)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_CTS BIT(14)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_FCPES BIT(13)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_PTS BIT(12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R10(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R10_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_SDES BIT(5)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_DLPER BIT(4)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R8(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_uncorr_err_severity_R8_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_corr_err_status -
    Bits: 31:16 R14(ro) - Reserved: Reserved
    Bits: 15    HLOS(w1c) - Header Log Overflow Status: This bit is set on a Header Log Register overflow, that is, when the header could not be logged in the Header Log Register because it is occupied by a previous header. STICKY.
    Bits: 14    CIES(w1c) - Corrected Internal Error Status: This bit is set when the Controller has detected an internal correctable error condition (a correctable ECC error while reading from any of the RAMs). This bit is also set in response to the client signaling an internal error through the input CORRECTABLE_ERROR_IN. This error is not Function-specific. STICKY.
    Bits: 13    ANFES(w1c) - Advisory Non-Fatal Error Status: This bit is set when an uncorrectable error occurs, which is determined to belong to one of the special cases described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications. This causes the Controller to generate an ERR_COR message in place of an ERR_NONFATAL message. STICKY.
    Bits: 12    RTTS(w1c) - Replay Timer Timeout Status: This bit is set when the replay timer in the Data Link Layer of the Controller times out, causing the Controller to retransmit a TLP. This error is not Function-specific. STICKY.
    Bits: 11:9  R13(ro) - Reserved: Reserved
    Bits:  8    RNRS(w1c) - Replay Number Rollover Status: This bit is set when the replay count rolls over after three re-transmissions of a TLP at the Data Link Layer of the Controller. This error is not Function-specific STICKY.
    Bits:  7    BDS(w1c) - Bad DLLP Status: This bit is set when an LCRC error is detected in a received DLLP, and no errors were detected by the Physical Layer. This error is not Function-specific. STICKY.
    Bits:  6    BTS(w1c) - Bad TP Status: This bit is set when an error is detected in a received TLP by the Data Link Layer of the Controller. The conditions causing this error are: (i) An LCRC error (ii) The packet terminates with EDB symbol, but its LCRC field does not equal the inverted value of the calculated CRC. This error is not Function-specific. STICKY.
    Bits:  5:1  R12(ro) - Reserved: Reserved
    Bits:  0    RES(w1c) - Receiver Error Status: This bit is set when an error is detected in the receive side of the Physical Layer of the Controller (e.g. a bit error or coding violation). This bit is set upon any of the following errors: (1) PHY reported 8B10B error, Disparity Error, Elastic Buffer Overflow Error, Underflow Error (2) GEN3 TLP, DLLP Framing Errors (3) OS Block Received Without EDS (4) Data Block Received After EDS (5) Illegal OS Block After EDS (6) OS Block Received After SKIP OS (7) OS Block Received After SDS (8) Sync Header Error (9) Loss of Gen3 Block Alignment This error is not Function-specific. STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status  0x00000110
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R14(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R14_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_HLOS BIT(15)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_CIES BIT(14)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_ANFES BIT(13)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_RTTS BIT(12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R13(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R13_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_RNRS BIT(8)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_BDS BIT(7)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_BTS BIT(6)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R12(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_R12_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_status_RES BIT(0)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_corr_err_mask -
    Bits: 31:16 R17(ro) - Reserved: Reserved
    Bits: 15    HLOM(rw) - Header Log Overflow Mask: This bit, when set, masks the generation of error messages in response to a Header Log register overflow. STICKY.
    Bits: 14    CIEM(rw) - Corrected Internal Error Mask: This bit, when set, masks the generation of error messages in response to a corrected internal error condition. STICKY.
    Bits: 13    ANFEM(rw) - Advisory Non-Fatal Error Mask: This bit, when set, masks the generation of error messages in response to an uncorrectable error occur, which is determined to belong to one of the special cases (as described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications). STICKY.
    Bits: 12    RTTM(rw) - Replay Timer Timeout Mask: This bit, when set, masks the generation of error messages in response to a Replay Timer timeout event. STICKY.
    Bits: 11:9  R16(ro) - Reserved: Reserved
    Bits:  8    RNRM(rw) - Replay Number Rollover Mask: This bit, when set, masks the generation of error messages in response to a Replay Number Rollover event. STICKY.
    Bits:  7    BDM(rw) - Bad DLLP Mask: This bit, when set, masks the generation of error messages in response to a 'Bad DLLP' received. STICKY.
    Bits:  6    BTM(rw) - Bad TLP Mask: This bit, when set, masks the generation of error messages in response to a 'Bad TLP' received. STICKY.
    Bits:  5:1  R15(ro) - Reserved: Reserved
    Bits:  0    REM(rw) - Receiver Error Mask: This bit, when set, masks the generation of error messages in response to the Physical Layer errors STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask    0x00000114
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R17(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R17_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_HLOM BIT(15)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_CIEM BIT(14)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_ANFEM BIT(13)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_RTTM BIT(12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R16(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R16_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_RNRM BIT(8)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_BDM BIT(7)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_BTM BIT(6)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R15(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_R15_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_corr_err_mask_REM BIT(0)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_advcd_err_cap_ctrl -
    Bits: 31:12 R18(ro) - Reserved: Reserved
    Bits: 11    R11(ro) - Reserved: Reserved
    Bits: 10    MHRE(ro) - Multiple Header Recording Enable: Setting this bit enables the Function to log multiple error headers in its Header Log Registers. It is hardwired to 0
    Bits:  9    MHRC(ro) - Multiple Header Recording Capable: This bit is set when the Function has the capability to log more than one error header in its Header Log Registers. It is hardwired to 0.
    Bits:  8    EEC(rw) - Enable ECRC Check: Setting this bit enables ECRC checking on the receive side of the Controller. This bit is writable from the local management bus. STICKY.
    Bits:  7    ECC(rw) - ECRC Check Capability: This read-only bit indicates to the software that the device is capable of checking ECRC in packets received from the link. This bit is writable from the local management bus.
    Bits:  6    EEG(rw) - Enable ECRC Generation: Setting this bit enables the ECRC generation on the transmit side of the Controller. This bit is writable from the local management bus. STICKY.
    Bits:  5    EGC(rw) - ECRC Generation Capability: This read-only bit indicates to the software that the device is capable of generating ECRC in packets transmitted on the link. This bit is writable from the local management bus.
    Bits:  4:0  FER(ro) - First Error Pointer: This is a 5-bit pointer to the bit position in the Uncorrectable Error Status Register corresponding to the error that was detected first. When there are multiple bits set in the Uncorrectable Error Status Register, this field informs the software which error was observed first. To prevent the field from being overwritten before software was able to read it, this field is not updated while the status bit pointed by it in the Uncorrectable Error Status Register remains set. After the software clears this status bit, a subsequent error condition that sets any bit in the Uncorrectable Error Status Register will update the First Error Pointer. Any uncorrectable error type, including the special cases where the error is reported using an ERR_COR message, will set the First Error Pointer (assuming the software has reset the error pointed by it in the Uncorrectable Error Status Register). STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl 0x00000118
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_R18(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_R18_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_R11 BIT(11)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_MHRE BIT(10)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_MHRC BIT(9)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_EEC BIT(8)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_ECC BIT(7)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_EEG BIT(6)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_EGC BIT(5)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_FER(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_advcd_err_cap_ctrl_FER_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_0 -
    Bits: 31:0  HD0(ro) - Header DWORD 0: First DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_0        0x0000011c
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_0_HD0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_0_HD0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_1 -
    Bits: 31:0  HD1(ro) - Header DWORD 1: Second DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_1        0x00000120
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_1_HD1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_1_HD1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_2 -
    Bits: 31:0  HD2(ro) - Header DWORD 2: Third DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_2        0x00000124
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_2_HD2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_2_HD2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_AER_cap_struct_i_hdr_log_3 -
    Bits: 31:0  HD3(ro) - Header DWORD 3: Fourth DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_3        0x00000128
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_3_HD3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_AER_cap_struct_i_hdr_log_3_HD3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_ARI_cap_struct_i_ARI_ext_cap_hdr -
    Bits: 31:20 ARINCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 ARICV(rw) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is set to 1 by default, but can be modified independently for each Function from the local management bus
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the ARI Extended Capability (000E hex).
*/
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr  0x00000140
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_ARINCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_ARINCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_ARICV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_ARICV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_ext_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_ARI_cap_struct_i_ARI_cap_and_ctrl -
    Bits: 31:16 ACR(ro) - ARI Control Register: ARI Control Register not implemented in this Controller. This field is hardwired to 0.
    Bits: 15:8  NF(rw) - Next Function: Points to the next Physical Function in the device. This field is set by default to point to the next Physical Function, 0 for last Function. It can be rewritten from the local management bus.
    Bits:  1    AFGC(ro) - ACS Function Groups Capability: Relevant only when ACS Capability is supported. This field is hardwired to 0.
    Bits:  0    MFGC(ro) - MFVC Function Groups Capability: Set when device supports arbitration at the Function Group-level. This field is hardwired to 0.
*/
#define NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl 0x00000144
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_ACR(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_ACR_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_NF(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_NF_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_AFGC BIT(1)
#define   NFP3800_PCIEX_PF_i_ARI_cap_struct_i_ARI_cap_and_ctrl_MFGC BIT(0)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr -
    Bits: 31:20 SNNCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 DSNCV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus by writing into Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express Device Serial Number Capability (0001 hex).
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr 0x00000150
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_SNNCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_SNNCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_DSNCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_DSNCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_0 -
    Bits: 31:0  DSND0(rw) - Device Serial Number, Doubleword 0: This field contains the first 32 bits of the device's serial number.
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_0 0x00000154
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_0_DSND0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_0_DSND0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_device_serial_num_cap_struct_i_dev_ser_num_1 -
    Bits: 31:0  DSND1(rw) - Device Serial Number, Doubleword 1: This field contains the last 32 bits of the device's serial number.
*/
#define NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_1 0x00000158
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_1_DSND1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_device_serial_num_cap_struct_i_dev_ser_num_1_DSND1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr -
    Bits: 31:20 PBNCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 PCV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus by writing into Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express Power Budgeting Capability (0004 hex).
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr 0x00000160
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PBNCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PBNCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PCV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PCV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_enhc_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel -
    Bits: 31:8  R0(ro) - Reserved:
    Bits:  7:0  PBDN(rw) - Power Budgeting Data Index: This field selects the power budgeting data read from the Power Budgeting Data Register. Its settings are: 00: Selects power budgeting data for power state D0 MAX for the associated PF. 01: Selects power budgeting data for power state D0 SUSTAINED for the associated PF. 10: Selects power budgeting data for power state D3hot for the associated PF. 11: Selects power budgeting data for power state D1 for the associated PF. Others: Not a valid setting. A read from the Power Budgeting Data Register returns all zeroes.
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel 0x00000164
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel_PBDN(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_sel_PBDN_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register -
    Bits: 31:21 R1(ro) - Reserved: Reserved
    Bits: 20:18 PR(rw) - Power Rail: Specifies the power rail corresponding to the power management data in this register.
    Bits: 17:15 TYPE(rw) - Type: Specifies the operation condition for which the data applies.
    Bits: 14:13 PS(rw) - PM State: Specifies the power management state of the Function, for which this power management data applies.
    Bits: 12:10 PSS(rw) - PM Sub-State: Specifies the power management sub-state of the selected power state
    Bits:  9:8  DS(rw) - Data Scale: Scale factor applicable to the Base Power field.
    Bits:  7:0  BP(rw) - Base Power: Specifies base power(in watts) of the selected power state
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register 0x00000168
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_R1(_x) (((_x) & 0x7ff) << 21)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_R1_of(_x) (((_x) >> 21) & 0x7ff)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PR(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PR_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_TYPE(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_TYPE_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PS(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PS_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PSS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_PSS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_DS(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_DS_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_BP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgtg_data_register_BP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_power_budgeting_cap_struct_i_pwr_bdgt_cap -
    Bits: 31:1  R4(ro) - Reserved: Reserved
    Bits:  0    SA(rw) - System Allocated: This bit is set to indicate that the device power specified by this Power Management Capability Structure is included in the system power budget. When this bit set, the software must exclude the device power reported by this Capability Structure from power calculations, when making power budgeting decisions. This bit is set to 0 by default, but its setting can be modified individually for each PF from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgt_cap 0x0000016c
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgt_cap_R4(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgt_cap_R4_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_PF_i_power_budgeting_cap_struct_i_pwr_bdgt_cap_SA BIT(0)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Resizable BAR Capability (0015 hex).
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr 0x00000180
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ext_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_0 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0 0x00000184
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_0_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0 0x00000188
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_0_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_1 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1 0x0000018c
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_1_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1 0x00000190
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_1_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_2 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2 0x00000194
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_2_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2 0x00000198
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_2_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_3 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3 0x0000019c
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_3_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3 0x000001a0
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_3_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_4 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4 0x000001a4
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_4_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4 0x000001a8
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_4_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_cap_5 -
    Bits: 31:24 R1(ro) - Reserved: Reserved
    Bits: 23    A512G(ro) - Aperture 512G: Indicates that the BAR aperture can be set to 512G.
    Bits: 22    A256G(ro) - Aperture 256G: Indicates that the BAR aperture can be set to 256G.
    Bits: 21    A128G(ro) - Aperture 128G: Indicates that the BAR aperture can be set to 128G.
    Bits: 20    A64G(ro) - Aperture 64G: Indicates that the BAR aperture can be set to 64G.
    Bits: 19    A32G(ro) - Aperture 32G: Indicates that the BAR aperture can be set to 32G.
    Bits: 18    A16G(ro) - Aperture 16G: Indicates that the BAR aperture can be set to 16G.
    Bits: 17    A8G(ro) - Aperture 8G: Indicates that the BAR aperture can be set to 8G.
    Bits: 16    A4G(ro) - Aperture 4G: Indicates that the BAR aperture can be set to 4G.
    Bits: 15    A2G(ro) - Aperture 2G: Indicates that the BAR aperture can be set to 2G.
    Bits: 14    A1G(ro) - Aperture 1G: Indicates that the BAR aperture can be set to 1G.
    Bits: 13    A512M(ro) - Aperture 512M: Indicates that the BAR aperture can be set to 512M.
    Bits: 12    A256M(ro) - Aperture 256M: Indicates that the BAR aperture can be set to 256M.
    Bits: 11    A128M(ro) - Aperture 128M: Indicates that the BAR aperture can be set to 128M.
    Bits: 10    A64M(ro) - Aperture 64M: Indicates that the BAR aperture can be set to 64M.
    Bits:  9    A32M(ro) - Aperture 32M: Indicates that the BAR aperture can be set to 32M.
    Bits:  8    A16M(ro) - Aperture 16M: Indicates that the BAR aperture can be set to 16M.
    Bits:  7    A8M(ro) - Aperture 8M: Indicates that the BAR aperture can be set to 8M.
    Bits:  6    A4M(ro) - Aperture 4M: Indicates that the BAR aperture can be set to 4M.
    Bits:  5    A2M(ro) - Aperture 2M: Indicates that the BAR aperture can be set to 2M.
    Bits:  4    A1M(ro) - Aperture 1M: Indicates that the BAR aperture can be set to 1M.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5 0x000001ac
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_R1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_R1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A512G BIT(23)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A256G BIT(22)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A128G BIT(21)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A64G BIT(20)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A32G BIT(19)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A16G BIT(18)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A8G BIT(17)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A4G BIT(16)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A2G BIT(15)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A1G BIT(14)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A512M BIT(13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A256M BIT(12)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A128M BIT(11)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A64M BIT(10)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A32M BIT(9)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A16M BIT(8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A8M BIT(7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A4M BIT(6)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A2M BIT(5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_A1M BIT(4)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_cap_5_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5 -
    Bits: 31:13 R3(ro) - Reserved: Reserved
    Bits: 12:8  BARS(ro) - BAR Size: When the Resizable BAR Capability is enabled for the Physical Function, this field controls the BAR aperture for the first BAR of the PF (0 = 1M, 1 = 2M, ... , 12 = 4G). This field can be modified independently for each PF from the local management bus.
    Bits:  7:5  RBARC(ro) - Resizable BAR Count: Specifies the number of BARs that can be configured through the Resizable BAR Capability Structure for this PF. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits:  4:3  R2(ro) - Reserved: Reserved
    Bits:  2:0  BARI(ro) - BAR Index: Specifies the index of the BAR controlled by this register. This field can be modified independently for each PF from the local management bus. Please see the `define den_db_Fx_RESIZABLE_BAR_CONTROL_REG0_BAR_INDEX values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5 0x000001b0
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_R3(_x) (((_x) & 0x7ffff) << 13)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_R3_of(_x) (((_x) >> 13) & 0x7ffff)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_BARS(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_BARS_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_RBARC(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_RBARC_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_R2(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_R2_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_resizable_BAR_cap_struct_i_resize_BAR_ctrl_5_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_LTR_cap_struct_i_LTR_ext_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Latency Tolerance Reporting Capability (0018 hex).
*/
#define NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr  0x000001b8
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_ext_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_LTR_cap_struct_i_LTR_snoop_lat -
    Bits: 31:29 R1(ro) - Reserved: Reserved
    Bits: 28:26 MNSLS(rw) - Max No-Snoop Latency Scale: Specifies the scale value for the Max No-Snoop Latency. When the setting of this field is non-zero, the actual snoop latency is determined by multiplying the Max No-Snoop Latency by the following scale factors: 001: 32 ns, 010: 1024 ns, 011: 32,768 ns, 100: 1,047,576 ns, 101: 33,554,432 ns, 110-111: Reserved
    Bits: 25:16 MNSL(rw) - Max No-Snoop Latency: When multiplied by the value of the Max No-Snoop Latency Scale, this field defines the maximum no-snoop value the device is permitted to request in an LTR message. This field can be written independently for each Physical Function from the local management bus.
    Bits: 15:13 R0(ro) - Reserved: Reserved
    Bits: 12:10 MSLS(rw) - Max Snoop Latency Scale: Specifies the scale value for the Max Snoop Latency. When the setting of this field is non-zero, the actual snoop latency is determined by multiplying the Max Snoop Latency by the following scale factors: 001: 32 ns, 010: 1024 ns, 011: 32,768 ns, 100: 1,047,576 ns, 101: 33,554,432 ns, 110-111: Reserved
    Bits:  9:0  MSL(rw) - Max Snoop Latency: When multiplied by the value of the Max Snoop Latency Scale, this field defines the maximum snoop value the device is permitted to request in an LTR message. This field can be written independently for each Physical Function from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat    0x000001bc
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_R1(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_R1_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MNSLS(_x) (((_x) & 0x7) << 26)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MNSLS_of(_x) (((_x) >> 26) & 0x7)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MNSL(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MNSL_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_R0(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_R0_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MSLS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MSLS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MSL(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_PF_i_LTR_cap_struct_i_LTR_snoop_lat_MSL_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each Function from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the SR-IOV Extended Capability Structure (0010 hex).
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg 0x00000200
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ext_cap_header_reg_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_cap_reg -
    Bits: 31:3  R31(ro) - Reserved: Reserved
    Bits:  2    R2(ro) - Reserved: Reserved
    Bits:  1    ACHP(rw) - ARI Capable Hierarchy Preserved: A 1 in this bit position indicates that the ARI Capable Hierarchy bit in the SR-IOV Control Register is preserved across certain power state transitions (see the PCI-SIG Single Root IO Virtualization and Sharing Specifications, Version 1.1, Section 3.3.3.5 for details). This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    VFMC(ro) - VF Migration Capable: Set when the Controller supports VF migration. Hardwired to 0.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg  0x00000204
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg_R31(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg_R31_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg_R2 BIT(2)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg_ACHP BIT(1)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_cap_reg_VFMC BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg -
    Bits: 31:16 SSR(ro) - SRIOV Status Register: Not implemented.
    Bits: 15:6  R15(ro) - Reserved: Reserved
    Bits:  5    R5(ro) - Reserved: Reserved
    Bits:  4    ARIE(rw) - ARI Capable Hierarchy: This bit enables the ARI mode for Virtual Functions. ARI Capable Hierarchy is only present in the lowest numbered PF which is enabled (for example PF0) and affects all PFs of the Device. ARI Capable Hierarchy is Read Only Zero in other PFs of a Device.
    Bits:  3    VFMSE(rw) - VF Memory Space Enable: This bit must be set to allow access to the memory space of the VFs associated with this PF.
    Bits:  2    VFMIE(rw) - VF Migration Interrupt Enable: Not supported. Hardwired to 0
    Bits:  1    VFME(rw) - VF Migration Enable: Not supported. Hardwired to 0
    Bits:  0    VFE(rw) - VF Enable: This bit must be set to enable the VFs associated with this PF.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg 0x00000208
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_SSR(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_SSR_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_R15(_x) (((_x) & 0x3ff) << 6)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_R15_of(_x) (((_x) >> 6) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_R5 BIT(5)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_ARIE BIT(4)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_VFMSE BIT(3)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_VFMIE BIT(2)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_VFME BIT(1)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_SRIOV_ctrl_status_reg_VFE BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_initial_total_VFs_reg -
    Bits: 22:16 TVF(rw) - Total VFs: This field contains the total number of VFs per PF. Its default setting is identical to that of InitialVFs. This field can be modified using local management registers.
    Bits:  6:0  IVF(rw) - Initial VFs: This field contains the initial number of VFs configured for each PF. This field can be modified using local management registers. Please see the `define den_db_PFx_TOTAL_VF_COUNT values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_initial_total_VFs_reg 0x0000020c
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_initial_total_VFs_reg_TVF(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_initial_total_VFs_reg_TVF_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_initial_total_VFs_reg_IVF(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_initial_total_VFs_reg_IVF_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg -
    Bits: 23:16 FDL(rw) - Function Dependency Link: This field is used to specify dependencies between PFs. It can be modified independently for each Function from the local management bus. Please see the `define den_db_Fx_SR_IOV_FUNCTION_DEPENDENCY_LINK values (where x is the function number) for default values of each function in the reg_defaults.v files.
    Bits: 15:0  NVF(rw) - NumVFs: This field must be set by the software to the number of VFs that it wants to enable for each PF. This field can be changed only when the VF Enable bit in the SR-IOV Control Register is 0. Its value should not exceed the setting of TotalVFs for the corresponding Physical Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg 0x00000210
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg_FDL(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg_FDL_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg_NVF(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_func_dep_link_numVFs_reg_NVF_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_offset_stride_reg -
    Bits: 31:16 VFS(ro) - VF Stride: Stride value used to assign RIDs for VFs. The stride value is hardwired to 1 for all Physical Functions.
    Bits: 15:0  FVFO(rw) - First VF Offset: Offset of First VF relative to its PF. This field can be re-written independently for each PF from the local management bus. Please see the `define den_db_Fx_VF_ADDR_OFFSET values (where x is the function number) for default values of each function in the reg_defaults.v files.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_offset_stride_reg 0x00000214
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_offset_stride_reg_VFS(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_offset_stride_reg_VFS_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_offset_stride_reg_FVFO(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_offset_stride_reg_FVFO_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_device_id_reg -
    Bits: 31:16 VFDI(rw) - VF Device ID: VF device id assigned to the device. Its default value is specified in reg_defaults.h, but can be re-written independently for each PF from the local management bus.
    Bits: 15:0  R2(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_device_id_reg 0x00000218
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_device_id_reg_VFDI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_device_id_reg_VFDI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_device_id_reg_R2(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_device_id_reg_R2_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_supported_page_size_reg -
    Bits: 31:16 R0(ro) - Reserved: Reserved
    Bits: 15:0  PS(rw) - Page Sizes: Page sizes supported by the device (one bit for each page size). The Controller implements only bits 15:0 of this register. The default value of this field is specified in reg_defaults.h, but can be re-written independently for each PF from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_supported_page_size_reg 0x0000021c
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_supported_page_size_reg_R0(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_supported_page_size_reg_R0_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_supported_page_size_reg_PS(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_supported_page_size_reg_PS_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_system_page_size_reg -
    Bits: 31:16 R0(ro) - Reserved: Reserved
    Bits: 15:0  SPS(rw) - System Page Size: This field must be programmed by software to the current page size in use. TheController implements only bits 15:0 of this register. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_system_page_size_reg 0x00000220
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_system_page_size_reg_R0(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_system_page_size_reg_R0_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_system_page_size_reg_SPS(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_system_page_size_reg_SPS_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_0_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 1 is treated as a continuation of the base address in BAR 0. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg   0x00000224
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_P0 BIT(3)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_S0 BIT(2)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_R7 BIT(1)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_0_reg_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_1_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_1_reg   0x00000228
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_1_reg_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_1_reg_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_2_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 3 is treated as a continuation of the base address in BAR 2. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg   0x0000022c
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_P0 BIT(3)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_S0 BIT(2)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_R7 BIT(1)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_2_reg_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_3_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_3_reg   0x00000230
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_3_reg_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_3_reg_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_4_reg -
    Bits: 31:22 BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function.
    Bits: 21:8  BAMR0(ro) - Base Address - RO part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture configured in BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
    Bits:  7:4  R8(ro) - Reserved: These bits are hardwired to 0
    Bits:  3    P0(ro) - Prefetchability: When the BAR is used to define a memory address range, this field declares whether data from the address range is prefetchable (0 = non-prefetchable, 1 = prefetchable). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
    Bits:  2    S0(ro) - Size: When the BAR is used to define a memory address range, this field indicates whether the address range is 32-bit or 64-bit (0 = 32-bit, 1 = 64 bit). For 64-bit address ranges, the value in BAR 5 is treated as a continuation of the base address in BAR 4. The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function.
    Bits:  1    R7(ro) - Reserved: This bit is hardwired to 0 for both memory and I/O BARs.
    Bits:  0    MSI(ro) - Memory Space Indicator: Specifies whether this BAR defines a memory address range or an I/O address range (0 = memory, 1 = I/O). The value read in this field is determined by the setting of BAR Configuration Registers of the associated Physical Function
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg   0x00000234
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_BAMRW(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_BAMRW_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_BAMR0(_x) (((_x) & 0x3fff) << 8)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_BAMR0_of(_x) (((_x) >> 8) & 0x3fff)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_R8(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_R8_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_P0 BIT(3)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_S0 BIT(2)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_R7 BIT(1)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_4_reg_MSI BIT(0)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_BAR_5_reg -
    Bits: 31:0  BAMRW(rw) - Base Address - RW part: This field defines the base address of the memory address range. The number of implemented bits in this field determines the BAR aperture setting of BAR Configuration Registers of the associated Physical Function. All other bits are not writeable, and are read as 0's.
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_5_reg   0x00000238
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_5_reg_BAMRW(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_BAR_5_reg_BAMRW_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_SRIOV_cap_struct_i_VF_migration_state_arr_offset_reg -
    Bits: 31:0  MSAOR(ro) - NA
*/
#define NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_migration_state_arr_offset_reg 0x0000023c
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_migration_state_arr_offset_reg_MSAOR(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_SRIOV_cap_struct_i_VF_migration_state_arr_offset_reg_MSAOR_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the TPH Requester Capability.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg 0x00000274
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_cap_reg -
    Bits: 31:27 R2(ro) - Reserved: Reserved
    Bits: 26:16 STS(rw) - ST Table Size: Specifies the number of entries in the Steering Tag Table (0 = 1 entry, 1 = 2 entries, and so on). Max limit is 64 entries when the ST Table is located in the TPH Requester Capability Structure, and 2048 entries when located in the MSI-X table. Each entry is 16 bits long. This field can be modified from the local management bus.
    Bits: 15:11 R1(ro) - Reserved: Reserved
    Bits: 10:9  STL(rw) - ST Table Location: The setting of this field indicates if a Steering Tag Table is implemented for this Function, and its location if present. (00 = ST Table not present, 01 = ST Table in the TPH Requester Capability Structure, 10 = ST values stored in the MSI-X Table in client RAM, 11 = reserved.). This field can be modified from the local management bus.
    Bits:  8    ERS(ro) - Extended TPH Requester Supported: When set to 1, indicates that the Function is capable of generating requests with a TPH TLP Prefix.
    Bits:  7:3  R0(ro) - Reserved: Reserved
    Bits:  2    DSMS(rw) - Device-Specific Mode Supported: A setting of 1 indicates that the Function supports the Device- Specific Mode for TPH Steering Tag generation. In this mode, the Steering Tags are supplied by the client for each request through the HAL master interface. The client typically chooses the Steering Tag values from the ST Table, but is not required to do so. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  1    IVMS(rw) - Interrupt Vector Mode Supported: A setting of 1 indicates that the Function supports the Interrupt Vector Mode for TPH Steering Tag generation. In the Interrupt Vector Mode, Steering Tags are attached to MSI/MSI-X interrupt requests. The Steering Tag for each interrupt request is selected by the MSI/MSI-X interrupt vector number. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    NSM(ro) - No ST Mode Supported: When set to 1, indicates that this Function supports the 'No ST Mode' for the generation of TPH Steering Tags. In the No ST Mode, the device must use a Steering Tag value of 0 for all requests. This bit is hardwired to 1, as all TPH Requesters are required to support the No ST Mode of operation.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg  0x00000278
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R2(_x) (((_x) & 0x1f) << 27)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R2_of(_x) (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_STS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_STS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R1(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R1_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_STL(_x) (((_x) & 0x3) << 9)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_STL_of(_x) (((_x) >> 9) & 0x3)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_ERS BIT(8)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R0(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_R0_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_DSMS BIT(2)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_IVMS BIT(1)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_cap_reg_NSM BIT(0)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_req_ctrl_reg -
    Bits: 31:10 R10(ro) - Reserved: Reserved
    Bits:  9:8  CRE(rw) - TPH Requester Enable: When set , the Function is allowed to generate requests with Transaction Processing Hints. Defined Encodings are: 00b - Function operating as a Requester is not permitted to issue Requests with TPH or Extended TPH. 01b - Function operating as a Requester is permitted to issue Requests with TPH and is not permitted to issue Requests with Extended TPH. 10b - Reserved. 11b - Function operating as a Requester is permitted to issue Requests with TPH and Extended TPH.
    Bits:  2:0  CSM(rw) - ST Mode: This field selects the ST mode (000 = No Steering Tag Mode, 001 = Interrupt Vector Mode, 010 = Device-Specific Mode, other values are reserved). The TPH_ST_MODE output of the Controller reflects the setting of this register field. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg 0x0000027c
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_R10(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_R10_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_CRE(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_CRE_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_CSM(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_req_ctrl_reg_CSM_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_TPH_cap_struct_i_TPH_tab_0 -
  Register: i_TPH_cap_struct_i_TPH_tab_1 -
  Register: i_TPH_cap_struct_i_TPH_tab_2 -
  Register: i_TPH_cap_struct_i_TPH_tab_3 -
  Register: i_TPH_cap_struct_i_TPH_tab_4 -
  Register: i_TPH_cap_struct_i_TPH_tab_5 -
  Register: i_TPH_cap_struct_i_TPH_tab_6 -
  Register: i_TPH_cap_struct_i_TPH_tab_7 -
  Register: i_TPH_cap_struct_i_TPH_tab_8 -
  Register: i_TPH_cap_struct_i_TPH_tab_9 -
  Register: i_TPH_cap_struct_i_TPH_tab_10 -
  Register: i_TPH_cap_struct_i_TPH_tab_11 -
  Register: i_TPH_cap_struct_i_TPH_tab_12 -
  Register: i_TPH_cap_struct_i_TPH_tab_13 -
  Register: i_TPH_cap_struct_i_TPH_tab_14 -
  Register: i_TPH_cap_struct_i_TPH_tab_15 -
    Bits: 31:24 STU1(ro) - ST Upper 1: This field is used for the upper 8 bits of the second Steering Tag when Extended TPH Requester support is enabled.
    Bits: 23:16 STL1(rw) - ST Lower 1: Lower 8 bits of the second Steering Tag. This is the 8-bit Steering Tag sent out in requests.
    Bits: 15:8  STU0(ro) - ST Upper 0: This field is used for the upper 8 bits of the first Steering Tag when Extended TPH Requester support is enabled.
    Bits:  7:0  STL0(rw) - ST Lower 0: Lower 8 bits of the first Steering Tag. This is the 8-bit Steering Tag sent out in requests.
*/
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_0        0x00000280
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_1        0x00000284
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_2        0x00000288
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_3        0x0000028c
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_4        0x00000290
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_5        0x00000294
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_6        0x00000298
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_7        0x0000029c
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_8        0x000002a0
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_9        0x000002a4
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_10       0x000002a8
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_11       0x000002ac
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_12       0x000002b0
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_13       0x000002b4
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_14       0x000002b8
#define NFP3800_PCIEX_PF_i_TPH_cap_struct_i_TPH_tab_15       0x000002bc
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STU1(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STU1_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STL1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STL1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STU0(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STU0_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STL0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_TPH_cap_struct_TPH_st_table_cl_STL0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECI(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Secondary PCI Express Capability
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg 0x00000300
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_PECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_sec_pcie_cap_hdr_reg_PECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_link_control3_reg -
    Bits: 31:12 R2(ro) - Reserved: Reserved
    Bits: 11:9  ELSOSGV(rw) - Enable Lower SKP OS Generation Vector: When the Link is in L0 and the bit in this field corresponding to the current Link speed is Set, SKP Ordered Sets are scheduled at the rate defined for SRNS, overriding the rate required based on the clock tolerance architecture.
    Bits:  8:0  R1(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg 0x00000304
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_R2(_x) (((_x) & 0xfffff) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_R2_of(_x) (((_x) >> 12) & 0xfffff)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_ELSOSGV(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_ELSOSGV_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_R1(_x) (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_link_control3_reg_R1_of(_x) (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg -
    Bits: 31:8  R0(ro) - Reserved:
    Bits:  7:0  LES(w1c) - Lane Error Status: Each of these bits indicates the error status for the corresponding lane. STICKY.
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg 0x00000308
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg_LES(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_error_status_reg_LES_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 1 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 1 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 0 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 0 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0 0x0000030c
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R3 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R1 BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg0_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 3 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 3 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 2 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 2 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1 0x00000310
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R3 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R1 BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg1_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 5 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 5 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 4 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 4 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2 0x00000314
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R3 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R1 BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg2_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3 -
    Bits: 31    R3(ro) - Reserved: Reserved
    Bits: 30:28 UPRPH1(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 7 Receiver Preset Hint value received from the upstream device.
    Bits: 27:24 UPTP1(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 7 Transmitter Preset value received from the upstream device.
    Bits: 23    R2_1(ro) - Reserved: Reserved
    Bits: 22:16 R2(ro) - Reserved: Reserved
    Bits: 15    R1(ro) - Reserved: Reserved
    Bits: 14:12 UPRPH0(ro) - Upstream Port 8.0GT/s Receiver Preset Hint: 8.0GT/s Lane 6 Receiver Preset Hint value received from the upstream device.
    Bits: 11:8  UPTP0(ro) - Upstream Port 8.0GT/s Transmitter Preset: 8.0GT/s Lane 6 Transmitter Preset value received from the upstream device.
    Bits:  7    R0_1(ro) - Reserved: Reserved
    Bits:  6:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3 0x00000318
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R3 BIT(31)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPRPH1(_x) (((_x) & 0x7) << 28)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPRPH1_of(_x) (((_x) >> 28) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPTP1(_x) (((_x) & 0xf) << 24)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPTP1_of(_x) (((_x) >> 24) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R2_1 BIT(23)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R2(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R2_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R1 BIT(15)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPRPH0(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPRPH0_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPTP0(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_UPTP0_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R0_1 BIT(7)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R0(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_PF_i_PCIE_sec_ext_cap_struct_i_lane_equalization_control_reg3_R0_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vsec_header_reg -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified independently for each PF from the local management bus.
    Bits: 15:0  PECI(rw) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the Vendor-Specific Extended Capability.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg 0x00000400
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_PECI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vsec_header_reg_PECI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_header_reg -
    Bits: 31:20 VL(rw) - VSEC Length: Total byte count (in hex format) of the VSEC structure, including the Vendor-Specific Capability Header, the Vendor-Specific Header and the Vendor-Specific registers. This field can be written from the local management bus independently or each PF.
    Bits: 19:16 VR(rw) - VSEC Revision: Vendor-defined version number for the VSEC structure. This field can be written from the local management bus independently or each PF.
    Bits: 15:0  VI(rw) - VSEC ID: This field contains a vendor defined ID number that indicates the nature and format of the information in the Vendor-Specific Capability Structure. This field can be written from the local management bus independently or each PF.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg 0x00000404
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VL(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VL_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VR(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VR_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_header_reg_VI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_control_reg -
    Bits: 31:9  VSEC_COUT(rw) - VSEC Control Out: The state of these bits drive the output pins Fx_VSEC_CONTROL_OUT ( where x is the function number). These are implemented as register bits that can be read and written by the host through a Config transaction, or via the local management interface.
    Bits:  8    HTI(rw) - Host-Triggered Interrupt: The state of this bit drives the output pins Fx_VSEC_INTERRUPT_OUT ( where x is the function number). It can be used by the host to signal a software-driven interrupt to the application logic outside the Controller. This bit may be read and written by the host through a Config transaction, or via the local management interface.
    Bits:  7:0  VSEC_CIN(ro) - VSEC Control In: The 8-bit value read from this field of PFx reflects the setting of Fx_VSEC_CONTROL_IN[7:0] input to the Controller. This field can also be read from the local management bus
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg 0x00000408
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg_VSEC_COUT(_x) (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg_VSEC_COUT_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg_HTI BIT(8)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg_VSEC_CIN(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_control_reg_VSEC_CIN_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_VSEC_struct_i_vendor_specific_data_reg0 -
    Bits: 31:0  GPD(rw) - General-Purpose Data: These bits are implemented as register bits that can be read and written by the host through a Config transaction, or via the local management interface. Their use is application-dependent.
*/
#define NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_data_reg0 0x0000040c
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_data_reg0_GPD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_PF_i_regf_VSEC_struct_i_vendor_specific_data_reg0_GPD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr -
    Bits: 31:20 NCO(rw) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(rw) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the L1 PM Substates Extended Capability Structure (001E hex).
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr 0x00000900
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ext_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_cap -
    Bits: 23:19 R0(rw) - Port Power- On Time Value: Along with the Port T_POWER_ON Scale field in the L1 PM Substates Capabilities register sets the time (in us) that this Port requires the port on the opposite side of Link to wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. The value of Port T_POWER_ON is calculated by multiplying the value in this field by the scale value in the Port T_POWER_ON Scale field in the L1 PM Substates Capabilities register. T Power On is the minimum amount of time that each component must wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. This is to ensure no device is ever actively driving into an unpowered component.This bit can be modified using local management interface.
    Bits: 17:16 L1PrtPvrOnScale(rw) - Port Power-On Time Scale: Specifies the scale used for the Port T_POWER_ON Value field in the L1 PM Substates Capabilities register. Range of Values 00b = 2us 01b = 10us 10b = 100us 11b = Reserved Default value is 00.This bit can be modified using local management interface.
    Bits: 15:8  L1PrtCmMdReStrTime(rw) - Port Common Mode Restore Time: Time (in us) required for this Port to re-establish common mode during exit from PM or ASPM L1.2 substate. This bit can be modified using local management interface.
    Bits:  4    L1PMSUPP(rw) - L1 PM Substates Supported: When Set this bit indicates that this Port supports L1 PM Substates.This bit can be modified using local management interface.
    Bits:  3    L1ASPML11SUPP(rw) - ASPML1.1 Supported: When Set this bit indicates that ASPM L1.1 is supported.This bit can be modified using local management interface.
    Bits:  2    L1ASPML12SUPP(rw) - ASPML1.2 Supported: When Set this bit indicates that ASPM L1.2 is supported.This bit can be modified using local management interface.
    Bits:  1    L1PML11SUPP(rw) - PML1.1 Supported: When Set this bit indicates that PCI-PM L1.1 is supported.This bit can be modified using local management interface.
    Bits:  0    L1PML12SUPP(rw) - PML1.2 Supported: When Set this bit indicates that PCI-PM L1.2 is supported. This bit can be modified using local management interface.
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap 0x00000904
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_R0(_x) (((_x) & 0x1f) << 19)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_R0_of(_x) (((_x) >> 19) & 0x1f)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PrtPvrOnScale(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PrtPvrOnScale_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PrtCmMdReStrTime(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PrtCmMdReStrTime_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PMSUPP BIT(4)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1ASPML11SUPP BIT(3)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1ASPML12SUPP BIT(2)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PML11SUPP BIT(1)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_cap_L1PML12SUPP BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1 -
    Bits: 31:29 L1ThrshldSc(rw) - LTR L1.2 Threshold Scale: This field provides a scale for the value contained within the LTR_L1.2_THRESHOLD_Value. 000 - Value times 1 ns 001 - Value times 32 ns 010 - Value times 1024 ns 011 - Value times 32,768 ns 100 - Value times 1,048,576 ns 101 - Value times 33,554,422ns 110-111 - Not permitted
    Bits: 25:16 L1ThrshldVal(rw) - LTR L1.2 Threshold Value: Along with the LTR_L1.2_THRESHOLD_Scale, this field indicates the LTR threshold used to determine if entry into L1 results in L1.1 (if enabled) or L1.2 (if enabled).
    Bits: 15:8  L1CmMdReStrTime(ro) - Common Mode Restore Time: This field is reserved for EP.
    Bits:  3    L1ASPML11EN(rw) - ASPML1.1 Enable: When Set this bit enables ASPM L1.1.
    Bits:  2    L1ASPML12EN(rw) - ASPML1.2 Enable: When Set this bit enables ASPM L1.2.
    Bits:  1    L1PML11EN(rw) - PML1.1 Enable: When Set this bit enables PCI-PM L1.1.
    Bits:  0    L1PML12EN(rw) - PML1.2 Enable: When Set this bit enables PCI-PM L1.2.
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1 0x00000908
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ThrshldSc(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ThrshldSc_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ThrshldVal(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ThrshldVal_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1CmMdReStrTime(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1CmMdReStrTime_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ASPML11EN BIT(3)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1ASPML12EN BIT(2)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1PML11EN BIT(1)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_1_L1PML12EN BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2 -
    Bits:  7:3  L1PwrOnVal(rw) - T_POWER_ON Value: Along with the T_POWER_ON Scale sets the minimum amount of time (in us) that the Port must wait in L1.2.Exit after sampling CLKREQ# asserted before actively driving the interface. T_POWER_ON is calculated by multiplying the value in this field by the value in the T_POWER_ON Scale field.
    Bits:  1:0  L1PwrOnSc(rw) - T_POWER_ON Scale: Specifies the scale used for T_POWER_ON Value. Range of Values 00b = 2us 01b = 10us 10b = 100us 11b = Reserved
*/
#define NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2 0x0000090c
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2_L1PwrOnVal(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2_L1PwrOnVal_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2_L1PwrOnSc(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_PF_i_regf_L1_PM_cap_struct_i_L1_PM_ctrl_2_L1PwrOnSc_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_rc_pcie_base_i_RC_generic_reserved_reg -
    Bits: 31:0  rsvd(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_RC_i_rc_pcie_base_i_RC_generic_reserved_reg 0x00000000
#define   NFP3800_PCIEX_RC_i_rc_pcie_base_i_RC_generic_reserved_reg_rsvd(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_RC_i_rc_pcie_base_i_RC_generic_reserved_reg_rsvd_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pl_config_0_reg -
    Bits: 31    MLE(rw) - Master Loopback Enable: When the Controller is operating as a Root Port, setting this to 1 causes the LTSSM to initiate a loopback and become the loopback master. This bit is not used in the EndPoint Mode.
    Bits: 30    R0(ro) - Remote Linkwidth Upconfigure Capability Status: A 1 in this field indicates that the remote node advertised Linkwidth Upconfigure Capability in the training sequences in the Configuration.Complete state when the link came up. A 0 indicates that the remote node did not set the Link Upconfigure bit.
    Bits: 29:24 LTSSM(ro) - LTSSM State: Current state of the LTSSM. The encoding of the states is given in Appendix C.
    Bits: 23:16 RLID(ro) - Received Link ID: Link ID received from other side during link training.
    Bits: 15:8  RFC(ro) - Received FTS Count for 2.5 GT/s speed: FTS count received from the other side during link training for use at the 2.5 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 2.5 GT/s speed.
    Bits:  7    TSS(rw) - Tx Swing Setting: This bit drives the PIPE_TX_SWING output of the Controller.
    Bits:  6    APER(rw) - Phy Error Reporting: This bit controls the reporting of Errors Detected by the PHY. The Errors Detected by the PHY include:- - Received errors indicated on PIPE RxStatus interface, - 8.0 GT/s Invalid Sync Header received error, If PHY Error Reporting bit is set to 0, the Controller will only report those errors that caused a TLP or DLLP to be dropped because of a Detected PHY Error. If PHY Error Reporting bit is set to 1, the Controller will report all Detected PHY Errors regardless of whether a TLP or DLLP was dropped. The following registers report PHY error in conjunction with this bit: - Correctable Error Status Register, i_corr_err_status, bit-0, Receiver Error Status - Local Error and Status Register, i_local_error_status_register, bit-7, Phy Error In addition to the Errors Detected by the PHY(PCS), the Controller detects the following Physical Layer Protocol Framing Errors: - Framing Errors in the received DLLP and TLP - Ordered Set Block Received Without EDS - Data Block Received After EDS - Illegal Ordered Set Block Received After EDS - Ordered Set Block Received After Skip OS Note: These Errors are always reported independent of the setting of this bit.
    Bits:  5    LTD(ro) - Link Training Direction: The state of this bit indicates whether the Controller completed link training as an upstream port(EndPoint)(=0) or a downstream port(Root Port)(=1). Default value depends on CORE_TYPE strap pin.
    Bits:  4:3  NS(ro) - Negotiated Speed: Current operating speed of link (00 = 2.5G, 01 = 5G, 10 = 8G, 11 = 16G).
    Bits:  2:1  NLC(ro) - Negotiated Lane Count: Lane count negotiated with other side during link training (00 = x1, 01 = x2, 10 = x4, 11 = x8).
    Bits:  0    LS(ro) - Link Status: Current state of link (1 = link training complete, 0 = link training not complete).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg 0x00000000
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_MLE BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_R0 BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_LTSSM(_x) (((_x) & 0x3f) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_LTSSM_of(_x) (((_x) >> 24) & 0x3f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_RLID(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_RLID_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_RFC(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_RFC_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_TSS BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_APER BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_LTD BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_NS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_NS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_NLC(_x) (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_NLC_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_0_reg_LS BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pl_config_1_reg -
    Bits: 31:24 TFC3(rw) - Transmitted FTS Count at 8 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits: 23:16 TFC2(rw) - Transmitted FTS Count at 5 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits: 15:8  TFC1(rw) - Transmitted FTS Count at 2.5 GT/s Speed: FTS count transmitted by the Controller in TS1/TS2 sequences during link training. This value must be set based on the time needed by the receiver to acquire sync while exiting from L0S state.
    Bits:  7:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg 0x00000004
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC3(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC3_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC2(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC2_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_TFC1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_R0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pl_config_1_reg_R0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_dll_tmr_config_reg -
    Bits: 31:25 R25(ro) - Reserved: Reserved
    Bits: 24:16 RSART(rw) - Receive-Side ACK-NAK Replay Timeout Adjustment: Additional receive side ACK-NAK timer timeout interval. This 9-bit value is added as a signed 2's complement number to the internal ACK-NAK timer timeout value computed by the Controller based on the PCI Express Specifications. This enables the user to make minor adjustments to the spec-defined replay timer settings.Its value is in multiples of (2 Symbol Times) At Gen1 adjustment range = (+2040 ns to -2048 ns). At Gen2 adjustment range = (+1020 ns to -1024 ns). At Gen3 adjustment range = (+510 ns to -512 ns).
    Bits: 15:9  R9(ro) - Reserved: Reserved
    Bits:  8:0  TSRT(rw) - Transmit-Side Replay Timeout Adjustment: Additional transmit-side replay timer timeout interval. This 9-bit value is added as a signed 2's complement number to the internal replay timer timeout value computed by the Controller based on the PCI Express Specifications. This enables the user to make minor adjustments to the spec-defined replay timer settings. Its value is in multiples of (2 Symbol Times) At Gen1 adjustment range = (+2040 ns to -2048 ns). At Gen2 adjustment range = (+1020 ns to -1024 ns). At Gen3 adjustment range = (+510 ns to -512 ns).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg 0x00000008
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_R25(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_R25_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_RSART(_x) (((_x) & 0x1ff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_RSART_of(_x) (((_x) >> 16) & 0x1ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_R9(_x) (((_x) & 0x7f) << 9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_R9_of(_x) (((_x) >> 9) & 0x7f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_TSRT(_x) (((_x) & 0x1ff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_dll_tmr_config_reg_TSRT_of(_x) (((_x) >> 0) & 0x1ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg -
    Bits: 31:20 NPPC(rw) - Non-Posted Payload Credit VC0: Non-Posted payload credit limit advertised by the Controller for VC 0 . (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 19:12 PHC(rw) - Posted Header Credit VC0: Posted header credit limit advertised by the Controller for VC 0. (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 11:0  PPC(rw) - Posted Payload Credit VC0: Posted payload credit limit advertised by the Controller for VC 0. (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg 0x0000000c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_NPPC(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_NPPC_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_PHC(_x) (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_PHC_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_PPC(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_0_reg_PPC_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg -
    Bits: 31:24 CHC(rw) - Completion Header Credit VC0: Completion header credit limit advertised by the Controller for VC 0 (in number of packets). (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits: 23:20 R2(ro) - Reserved: Reserved
    Bits: 19:8  CPC(rw) - Completion Payload Credit VC0: Completion payload credit limit advertised by the Controller for VC 0 . (in units of 4 Dwords) Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
    Bits:  7:0  NPHCL(rw) - Non-Posted Header Credit Limit VC0: Non-Posted header credit limit advertised by the Controller for VC 0 (in number of packets). (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest Caution: The programmed Header and Payload credit values must not exceed the actual size of the Receive Buffer.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg 0x00000010
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_CHC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_CHC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_R2(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_R2_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_CPC(_x) (((_x) & 0xfff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_CPC_of(_x) (((_x) >> 8) & 0xfff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_NPHCL(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_rcv_cred_lim_1_reg_NPHCL_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_lim_0_reg -
    Bits: 31:20 NPPC(ro) - Non-Posted Payload Credit VC0: Non-Posted payload credit limit received by the Controller for Link 0 . (in units of 4 Dwords)
    Bits: 19:12 PHC(ro) - Posted Header Credit VC0: Posted header credit limit received by the Controller for this link . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
    Bits: 11:0  PPC(ro) - Posted Payload Credit VC0: Posted payload credit limit received by the Controller for this link . (in units of 4 Dwords)
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg 0x00000014
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_NPPC(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_NPPC_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_PHC(_x) (((_x) & 0xff) << 12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_PHC_of(_x) (((_x) >> 12) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_PPC(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_0_reg_PPC_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_lim_1_reg -
    Bits: 31:24 CHC(ro) - Completion Header Credit VC0: Completion header credit limit received by the Controller for VC 0 . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
    Bits: 23:20 R3(ro) - Reserved: Reserved
    Bits: 19:8  CPC(ro) - Completion Payload Credit VC0: Completion payload credit limit received by the Controller for VC 0 . (in units of 4 Dwords)
    Bits:  7:0  NPHC(ro) - Non-Posted Header Credit VC0: Non-Posted header credit limit received by the Controller for VC 0 . (in units of 1 Packet Header) Note: Packet Header represents one maximum-size TLP Header + TLP Digest
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg 0x00000018
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_CHC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_CHC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_R3(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_R3_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_CPC(_x) (((_x) & 0xfff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_CPC_of(_x) (((_x) >> 8) & 0xfff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_NPHC(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_lim_1_reg_NPHC_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg -
    Bits: 31:16 MNUI(rw) - Minimum Non-Posted Update Interval: Minimum credit update interval for non-posted transactions. The Controller follows this minimum interval between issuing posted credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This field is re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
    Bits: 15:0  MPUI(rw) - Minimum Posted Update Interval: Minimum credit update interval for posted transactions. The Controller follows this minimum interval between issuing posted credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This field is re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg 0x0000001c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg_MNUI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg_MNUI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg_MPUI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_0_reg_MPUI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg -
    Bits: 31:16 MUI(rw) - Maximum Update Interval: Maximum credit update interval for all transactions. If no new credit has become available since the last update, the Controller will repeat the last update after this interval. This is to recover from any losses of credit update packets. The value is in units of 16 ns. This field could be re-written by the internal logic when the negotiated link width or link speed changes, to correspond to the default values defined in defines.h. The user may override this default value by writing into this register field. The value written will be lost on a change in the negotiated link width/speed.
    Bits: 15:0  CUI(rw) - Minimum Completion Update Interval: Minimum credit update interval for Completion packets. The Controller follows this minimum interval between issuing completion credit updates on the link. This is to limit the bandwidth use of credit updates. If new credit becomes available in the receive FIFO since the last update was sent, the Controller will issue a new update only after this interval has elapsed since the last update. The value is in units of 16 ns. This parameter is not used when the Completion credit is infinity.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg 0x00000020
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg_MUI(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg_MUI_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg_CUI(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transm_cred_update_int_config_1_reg_CUI_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_L0S_timeout_limit_reg -
    Bits: 31:16 R4(ro) - Reserved: Reserved
    Bits: 15:0  LT(rw) - L0S Timeout: Contains the timeout value (in units of 16 ns) for transitioning to the L0S power state. Setting this parameter to 0 permanently disables the transition to the L0S power state.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L0S_timeout_limit_reg 0x00000024
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L0S_timeout_limit_reg_R4(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L0S_timeout_limit_reg_R4_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L0S_timeout_limit_reg_LT(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L0S_timeout_limit_reg_LT_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transmit_tlp_count_reg -
    Bits: 31:0  TTC(w1c) - Transmit TLP Count: Count of TLPs transmitted
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_count_reg 0x00000028
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_count_reg_TTC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_count_reg_TTC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_transmit_tlp_payload_dword_count_reg -
    Bits: 31:0  TTPBC(w1c) - Transmit TLP Payload Byte Count: Count of TLPs payload Dwords transmitted
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_payload_dword_count_reg 0x0000002c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_payload_dword_count_reg_TTPBC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_transmit_tlp_payload_dword_count_reg_TTPBC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_tlp_count_reg -
    Bits: 31:0  RTC(w1c) - Receive TLP Count: Count of TLPs received
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_count_reg 0x00000030
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_count_reg_RTC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_count_reg_RTC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_tlp_payload_dword_count_reg -
    Bits: 31:0  RTPDC(w1c) - Receive TLP Payload Byte Count: Count of TLP payload Dwords received
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_payload_dword_count_reg 0x00000034
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_payload_dword_count_reg_RTPDC(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_tlp_payload_dword_count_reg_RTPDC_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg -
    Bits: 31:24 R5(ro) - Reserved: Reserved
    Bits: 15:0  CTL(rw) - Completion Timeout Limit: Timeout limit for completion timers. This value is in multiples of 4096 ns. Default value is 50ms. Please note that there could be a variation of 0 to +8us on the programmed Completion Timeout.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg 0x00000038
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg_R5(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg_R5_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg_CTL(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_0_reg_CTL_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg -
    Bits: 31:28 R6(ro) - Reserved: Reserved
    Bits: 15:0  CTL(rw) - Completion Timeout Limit: Timeout limit for completion timers.This value is in multiples of 4096 ns. Default value is 200ms. Please note that there could be a variation of 0 to +8us on the programmed Completion Timeout.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg 0x0000003c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg_R6(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg_R6_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg_CTL(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_compln_tmout_lim_1_reg_CTL_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_L1_st_reentry_delay_reg -
    Bits: 31:0  L1RD(rw) - L1 Re-Entry Delay: Delay to re-enter L1 after no activity (in units of 16 ns).
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L1_st_reentry_delay_reg 0x00000040
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L1_st_reentry_delay_reg_L1RD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_L1_st_reentry_delay_reg_L1RD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg -
    Bits: 31    DISLNRXCHK(rw) - Disable Check for Link RX IDLE: This bit is used to configure the ASPM L1 Entry mechanism: 1: Link is checked for IDLE only on the TX to determine ASPM L1 Entry. ASPM L1 entry is initiated if no TLP is transmitted for the L1 timeout period. 0: Link is checked for IDLE both on the TX and RX to determine ASPM L1 Entry. ASPM L1 entry is initiated if no TLP is transmitted/received for the L1 timeout period.
    Bits: 30:20 R7(ro) - Reserved: Reserved
    Bits: 19:0  L1T(rw) - L1 Timeout: Contains the timeout value(in units of 16 ns) for transitioning to the L1 power state. Setting it to 0 permanently disables the transition to the L1 power state.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg 0x00000048
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg_DISLNRXCHK BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg_R7(_x) (((_x) & 0x7ff) << 20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg_R7_of(_x) (((_x) >> 20) & 0x7ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg_L1T(_x) (((_x) & 0xfffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_aspm_L1_entry_tmout_delay_reg_L1T_of(_x) (((_x) >> 0) & 0xfffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg -
    Bits: 31:16 R7(ro) - Reserved: Reserved
    Bits: 15:0  PTOAD(rw) - PME Turnoff Ack Delay: Time in microseconds between the Controller receiving a PME_TurnOff message TLP and the Controller sending a PME_TO_Ack response to it. This field must be set to a non-zero value in order for the Controller to send a response. Setting this field to 0 suppresses the Controller's response to PME_TurnOff message, so that the client may transmit the PME_TO_Ack message through the master interface.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg 0x0000004c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg_R7(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg_R7_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg_PTOAD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_turnoff_ack_delay_reg_PTOAD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_linkwidth_control_reg -
    Bits: 31    EPLSCRL(rw) - EP Link Speed Change Retrain Link: Writing a 1 into this field results in the Controller re-training the link to change its speed. When setting this bit to 1, the software must also set the EP Target Link Speed field to indicate the speed that the EP desires to change on the link. The EP Controller will attempt to change the link to this speed. This bit is cleared by the internal logic of the Controller after the re-training has been completed and link has reached the L0 state. Software must wait for the bit to be clear before setting it again to change the link speed.
    Bits: 30:26 R2(ro) - Reserved: Reserved
    Bits: 25:24 EPTLS(rw) - EP Target Link Speed: This field contains the Link Speed that the EP intends to change to during the re-training. Client needs to ensure that this field is programmed to a speed which is lesser than or equal to the Target Link Speed field of PF0 Configuration Link Control 2 Register. Client also needs to ensure that this does not exceed PCIE_GENERATION_SEL strap input. Defined encodings of this field are: 00 - GEN1 01 - GEN2 10 - GEN3 11 - Reserved
    Bits: 23:17 R1(ro) - Reserved: Reserved
    Bits: 16    RL(rw) - Link Upconfigure Retrain Link: Writing a 1 into this field results in the Controller re-training the link to change its width. When setting this bit to 1, the software must also set the target lane-map field to indicate the lanes it desires to be part of the link. The Controller will attempt to form a link with this set of lanes. The link formed at the end of the retraining may include all of these lanes (if both nodes agree on them during re-training), or the largest subset that both sides were able to activate. This bit is cleared by the internal logic of the Controller after the re-training has been completed and link has reached the L0 state. Software must wait for the bit to be clear before setting it again to change the link width.
    Bits: 15:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  TLM(rw) - Target Lane Map: This field contains the bitmap of the lanes to be included in forming the link during the re-training. 00000001 - Retrain to a x1 link 00000011 - Retrain to a x2 link 00001111 - Retrain to a x4 link 11111111 - Retrain to a x8 link If the target lane map includes lanes that were inactive when retraining is initiated, then both the Controller and its link partner must support the LinkWidth Upconfigure Capability to be able to activate those lanes. In RC Mode, the user can check if the remote node has this capability by reading the Remote Link Upconfigure Capability Status bit in Physical Layer Configuration Register 0 after the link first came up.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg 0x00000050
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_EPLSCRL BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R2(_x) (((_x) & 0x1f) << 26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R2_of(_x) (((_x) >> 26) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_EPTLS(_x) (((_x) & 0x3) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_EPTLS_of(_x) (((_x) >> 24) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R1(_x) (((_x) & 0x7f) << 17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R1_of(_x) (((_x) >> 17) & 0x7f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_RL BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R0(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_R0_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_TLM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_linkwidth_control_reg_TLM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_sris_control_reg -
    Bits: 31:1  R31(ro) - Reserved: Reserved
    Bits:  0    SRISE(rw) - SRIS Enable: Setting this bit enables SRIS mode in the PHY layer. This bit should be changed before link training begins by holding the LINK_TRAINING_ENABLE input to 1'b0. When SRIS is disabled using this bit the Lower SKP OS Generation Supported Speeds Vector and Lower SKP OS Reception Supported Speeds Vector in the Link Capabilities Register 2 will be forced to ZERO. The default value of this register can be controlled using the SRIS_ENABLE strap input.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_sris_control_reg 0x00000074
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_sris_control_reg_R31(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_sris_control_reg_R31_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_sris_control_reg_SRISE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_0_reg -
    Bits: 31:0  SHDW_HDR_LOG_0(rw) - Shadow header log 0: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [31:0] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_0_reg 0x00000100
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_0_reg_SHDW_HDR_LOG_0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_0_reg_SHDW_HDR_LOG_0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_1_reg -
    Bits: 31:0  SHDW_HDR_LOG_1(rw) - Shadow header log 1: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [63:32] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_1_reg 0x00000104
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_1_reg_SHDW_HDR_LOG_1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_1_reg_SHDW_HDR_LOG_1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_2_reg -
    Bits: 31:0  SHDW_HDR_LOG_2(rw) - Shadow header log 2: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [95:64] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_2_reg 0x00000108
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_2_reg_SHDW_HDR_LOG_2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_2_reg_SHDW_HDR_LOG_2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_hdr_log_3_reg -
    Bits: 31:0  SHDW_HDR_LOG_3(rw) - Shadow header log 3: The value here will be reflected in the target function's header log register when f/w sets any bit in the the shadow error register. If the header log is already set in the function's AER space, the value here may not get written and a header log overflow bit would get set. This register holds [127:96] value of the TLP header.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_3_reg 0x0000010c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_3_reg_SHDW_HDR_LOG_3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_hdr_log_3_reg_SHDW_HDR_LOG_3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_func_num_reg -
    Bits: 31:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  SHDW_FUNC_NUM(rw) - Shadow register target function number: The value here will be the target function number when f/w sets any bit in the shadow error register.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_func_num_reg 0x00000110
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_func_num_reg_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_func_num_reg_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_func_num_reg_SHDW_FUNC_NUM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_func_num_reg_SHDW_FUNC_NUM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_shdw_ur_err_reg -
    Bits: 31:2  R0(ro) - Reserved: Reserved
    Bits:  1    NP_UR_ERR(wo) - Non Posted Error: If this bit is set, the corresponding non-posted UR error bits will be set in the AER and device status registers of the target function.
    Bits:  0    P_UR_ERR(wo) - Posted UR Error: If this bit is set, the corresponding posted UR error bits will be set in the AER and device status registers of the target function.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_ur_err_reg 0x00000114
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_ur_err_reg_R0(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_ur_err_reg_R0_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_ur_err_reg_NP_UR_ERR BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_shdw_ur_err_reg_P_UR_ERR BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pm_clk_frequency_reg -
    Bits: 31:8  R0(ro) - Reserved: Reserved
    Bits:  7:0  PMCLKFRQ(rw) - PM_CLK Frequency Select: This field specifies the PM_CLK Frequency selected. The encoding is described below: 000000: Reserved 000001: Reserved 000010: PM_CLK is 2 MHz 000011: PM_CLK is 3 MHz 000100: PM_CLK is 4 MHz 000101: PM_CLK is 5 MHz .. 111010: PM_CLK is 58 MHz 111011: PM_CLK is 59 MHz 111100: PM_CLK is 60 MHz 111101 : Reserved 111110 : Reserved 111111 : Reserved .
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pm_clk_frequency_reg 0x00000140
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pm_clk_frequency_reg_R0(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pm_clk_frequency_reg_R0_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pm_clk_frequency_reg_PMCLKFRQ(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pm_clk_frequency_reg_PMCLKFRQ_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen1_reg -
    Bits: 31:0  DLLPCNT1(ro) - GEN1 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN1 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen1_reg 0x00000144
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen1_reg_DLLPCNT1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen1_reg_DLLPCNT1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen2_reg -
    Bits: 31:0  DLLPCNT2(ro) - GEN2 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN2 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen2_reg 0x00000148
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen2_reg_DLLPCNT2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen2_reg_DLLPCNT2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_dllp_count_gen3_reg -
    Bits: 31:0  DLLPCNT3(ro) - GEN3 DLLP Count: Reflects the total number of DLLPs received by the Controller at GEN3 speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen3_reg 0x0000014c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen3_reg_DLLPCNT3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_dllp_count_gen3_reg_DLLPCNT3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_vendor_defined_message_tag_reg -
    Bits:  7:0  VDMTAG(rw) - Vendor Defined Message Tag: The Controller will use the tag programed in this register for all Outbound Vendor Defined Messages.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_vendor_defined_message_tag_reg 0x00000158
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_vendor_defined_message_tag_reg_VDMTAG(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_vendor_defined_message_tag_reg_VDMTAG_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_negotiated_lane_map_reg -
    Bits: 31:17 R71(ro) - Reserved: Reserved
    Bits: 16    LRS(ro) - Lane Reversal Status: This bit set by the Controller at the end of link training if the LTSSM had to reverse the lane numbers to form the link.
    Bits: 15:8  R70(ro) - Reserved: Reserved
    Bits:  7:0  NLM(ro) - Negotiated Lane Map: Bit i of this field is set to 1 at the end of link training if Lane i is part of the PCIe link. The value of this field is valid only when the link is in L0 or L0s states.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg 0x00000200
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_R71(_x) (((_x) & 0x7fff) << 17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_R71_of(_x) (((_x) >> 17) & 0x7fff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_LRS BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_R70(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_R70_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_NLM(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_negotiated_lane_map_reg_NLM_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_receive_fts_count_reg -
    Bits: 31:24 R24(ro) - Reserved: Reserved
    Bits: 23:16 R16(ro) - Reserved: Reserved
    Bits: 15:8  RFC8S(ro) - Received FTS Count for 8GT/s Speed: FTS count received from the other side during link training for use at the 8 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 8 GT/s speed.
    Bits:  7:0  RFC5S(ro) - Received FTS Count for 5GT/s Speed: FTS count received from the other side during link training for use at the 5 GT/s link speed. The Controller transmits this many FTS sequences while exiting the L0S state, when operating at the 5 GT/s speed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg 0x00000204
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_R24(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_R24_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_R16(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_R16_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_RFC8S(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_RFC8S_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_RFC5S(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_receive_fts_count_reg_RFC5S_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_mux_control_reg -
    Bits: 31    EFSRTCA(rw) - Enable Function-Specific Reporting of Type-1 Configuration Accesses: Setting this bit to 0 causes all the enabled Functions to report an error when a Type-1 configuration access is received by the Controller, targeted at any Function. Setting it to 1 limits the error reporting to the type-0 Function whose number matches with the Function number specified in the request. If the Function number in the request refers to an unimplemented or disabled Function, all enabled Functions report the error regardless of the setting of this bit.
    Bits: 30    DOC(rw) - Disable Ordering Checks: Setting this bit to 1 disables the ordering check in the Controller between Completions and Posted requests received from the link.
    Bits: 29    DFCUT(rw) - Disable Flow Control Update Timeout: When this bit is 0, the Controller will time out and re-train the link when no Flow Control Update DLLPs are received from the link within an interval of 128 us. Setting this bit to 1 disables this timeout. When the advertised receive credit of the link partner is infinity for the header and payload of all credit types, this timeout is always suppressed. The setting of this bit has no effect in this case. This bit should not be set during normal operation, but is useful for testing.
    Bits: 28    DEI(rw) - Disable Electrical Idle Infer in L0 State: Setting this bit to 1 disables the inferring of electrical idle in the L0 state. Electrical idle is inferred when no flow control updates and no SKP sequences are received within an interval of 128 us. This bit should not be set during normal operation, but is useful for testing.
    Bits: 27    DGLUS(rw) - Disable Gen3 LFSR Update from SKP: Setting this bit to 1 disables the update of the LFSRs in the Gen3 descramblers of the Controller, from the values received in SKP sequences. This bit should not be set during normal operation, but is useful for testing.
    Bits: 26    R26(ro) - Reserved: Reserved
    Bits: 25    ESPC(rw) - Enable Slot Power Capture: When this bit is set to 1, the Controller will capture the Slot Power Limit Value and Slot Power Limit Scale parameters from a Set_Slot_Power_Limit message received in the Device Capabilities Register. When this bit is 0, the capture is disabled. This bit is valid only when the Controller is configured as an EndPoint. It has no effect when the Controller is a Root Complex.
    Bits: 24    EFLT(rw) - Enable Fast Link Training: This bit is provided to shorten the link training time to facilitate fast simulation of the design, especially at the gate level. Enabling this bit has the following effects: 1. The 1 ms, 2 ms, 12 ms, 24 ms, 32 ms and 48 ms timeout intervals in the LTSSM are shortened by a factor of 500. 2. In the Polling.Active state of the LTSSM, only 16 training sequences are required to be transmitted (Instead of 1024) to make the transition to the Configuration state. This bit should not be set during normal operation of the Controller.
    Bits: 23    DLUC(rw) - Disable Link Upconfigure Capability: The user may set this bit to turn off the link upconfigure capability of the Controller. Setting this bit prevents the Controller from advertising the link upconfigure capability in training sequences transmitted in the Configuration.Complete state. In addition, setting this bit causes the Controller to put the unused lanes into Turn Off mode. When disable_link_upconfigure_capability==1: Controller drives PIPE_TX_ELEC_IDLE==1 AND PIPE_TX_COMPLIANCE==1 for the Unused upper lanes. The Unused upper lanes are put into Turn Off mode by the PHY as per PIPE specification. When disable_link_upconfigure_capability==0: Controller drives PIPE_TX_ELEC_IDLE==1 AND PIPE_TX_COMPLIANCE==0 for the Unused upper lanes. The Unused upper lanes are put into Electrical Idle by the PHY.
    Bits: 22    DLRFE(rw) - Disable Link Re-Training on Framing Error: When this bit is 1, the Controller will not transition its LTSSM into the Recovery state when it detects a Framing Error at 8 GT/s speed (as defined in Section 4.2.2.3.3 of the PCIe Base Specification 3.0. This bit must normally be set to 0 so that a Framing Error will cause the LTSSM to enter Recovery. The setting of this bit has no effect on the operation of the Controller at 2.5 and 5 GT/s speeds.
    Bits: 21    DSHEC(rw) - Disable Sync Header Error Check: When this bit is 0, the Controller will signal a framing error if it detects a sync header error in the received blocks at 8 GT/s speed (A 00 or 11 binary setting of the sync header on the received blocks in any lane constitutes a framing error). Setting this bit to 1 suppresses this error check. This bit should normally be set to 0, as the sync header check is mandatory in the PCIe 3.0 Specifications.
    Bits: 20    DCIVMC(rw) - Disable checking of invalid message codes: When this bit is 1, the Controller will not check for invalid message codes. This bit should normally set to 0, as the invalid message code checking is mandatory in the PCIe 3.0 specifications.
    Bits: 19    DIOAEFC(rw) - Disable Illegal OS After EDS Framing Check: When this bit is 1, the Controller will not check for illegal OS after EDS as part of Gen3 Framing Error Checks. This bit should normally set to 0, as this is a mandatory Gen3 Framing Error check in the PCIe 3.0 specifications.
    Bits: 18    DOASFC(rw) - Disable OS After Skip Framing Check: When this bit is 1, the Controller will not check for OS after SKIP OS as part of Gen3 Framing Error Checks. This bit should normally set to 0, as this is a mandatory Gen3 Framing Error check in the PCIe 3.0 specifications.
    Bits: 17    R8B(ro) - Reserved:
    Bits: 16    R8A(ro) - Reserved:
    Bits: 15    FDS(rw) - Force Disable Scrambling: Disable Scrambling/Descrambling in Gen1/Gen2.
    Bits: 14    R14(ro) - Reserved:
    Bits: 13    R1313(ro) - Reserved:
    Bits: 12    R1212(ro) - Reserved:
    Bits: 11    R1111(rw) - Disable Client TX MUX arbitartion: When this bit is 1, Disable Client TX MUX Completion and PNP request arbitartion,roundrobin priority logic added to prevent PNP requests from starving when completions are present
    Bits: 10    DRXNPSP(rw) - Disable RX NP Starvation Prevention: As per PCIe specification, Non Posted packets should not pass ahead of a Posted packet. Posted and Non Posted packets are stored in a common Receive PNP FIFO. Controller ensures that the P and NP are delivered to the HAL/AXI target interface without violating the Ordering rules. When a mix of P and NP requests are received over the link, the NP packets can be starved if multiple Posted packets are stored in the PNP RX FIFO. Controller implements a mechanism to prevent NP Starvation Prevention which can be programmed through this bit: 0: Send P and NP in the received order, instead of giving priority only for P and starve NP when continous P, NP packets are received. 1: Priority only for P. Starve NP when continous P, NP packets are received. NP packets sent to HAL/AXI target interface only when all P packets in the PNP FIFO are delivered.
    Bits:  9    MSIVCMS(rw) - MSI Vector Count Mode Select: Sets the mode of generating MSI_VECTOR_COUNT output for all functions. 0 - MSI_VECTOR_COUNT always outputs the configured value of MSI Multiple Message Enable[2:0] register. 1 - MSI_VECTOR_COUNT outputs the lesser of the MSI Multiple Message Enable[2:0] and MSI Multiple Message Capable[2:0] This mode can be used to handle any programming error form the Host software.
    Bits:  8    DIDBOC(rw) - Disable ID Based Ordering Checks: Setting this bit to 1 disables the ID Based Ordering check in the Controller between Completions and Posted requests received from the link.
    Bits:  7    R77(rw) - Reserved: This bit should be set to 0 for backward compatibility.
    Bits:  6:5  R6(ro) - Reserved:
    Bits:  4:0  MS(rw) - Mux Select: Bits 4:3 select the module and bits 2:0 select the group of signals within the module that are driven on the debug bus. The assignments of signals on the debug outputs of the Controller are given in Appendix B.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg 0x00000208
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_EFSRTCA BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DOC BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DFCUT BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DEI BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DGLUS BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R26 BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_ESPC BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_EFLT BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DLUC BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DLRFE BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DSHEC BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DCIVMC BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DIOAEFC BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DOASFC BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R8B BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R8A BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_FDS BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R14 BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R1313 BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R1212 BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R1111 BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DRXNPSP BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_MSIVCMS BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_DIDBOC BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R77 BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R6(_x) (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_R6_of(_x) (((_x) >> 5) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_MS(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_reg_MS_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_error_status_register -
    Bits: 31:28 R31_28(ro) - Reserved: Reserved
    Bits: 27:26 R27(ro) - Reserved: Reserved
    Bits: 25    MSIXMSKST(w1c) - MSIX Function Mask Change: This interrupt status bit is used when MSIX Function Mask Enhanced Interrupt Enable bit is set to 0 by the User. This status bit indicates that the MSIX Function Mask bit of any function, PF or VF, was programmed or configured by Local Firmware Or Host SW.
    Bits: 24:22 R24(ro) - Reserved: Reserved
    Bits: 21    HAWCD(w1c) - Hardware Autonomous Width Change Disable Toggle: This interrupt status bit indicates that the Host toggled the Hardware Autonomous Width Change bit in the Link Control Register through a Config Write. Upon this interrupt, the Client firmware must read the Link Control Register to check the value set by Host in the Hardware Autonomous Width Change bit. The Host Software may disable autonomous width change by setting Hardware Autonomous Width Disable bit in the Link Control register. If disabled by the Host and if the Endpoint firmware had initiated an autonomous width downsizing prior to this interrupt, then the local Client firmware is responsible to upconfigure the Link to go to its full functional width by initiating the link_upconfigure_retrain_link within 1 ms of this interrupt.
    Bits: 20    MSIENGRCAP(w1c) - MSI Multiple Message Enable Greater Than Capability: The configured value of MSI Multiple Message Enable[2:0] for a function was greater than the functions MSI Multiple Message Capable[2:0]
    Bits: 19    MMVC(w1c) - MSI Mask Value Change: This status bit is set whenever the MSI mask register value in the MSI capability register changes value in ANY of the functions in the controller
    Bits: 18    UTC(w1c) - Unmapped TC: Unmapped TC error. This bit is tied to 0 since this configuration of the Controller does not implement the Virtual Channel Capability Registers.
    Bits: 17    R17(ro) - Reserved: Reserved
    Bits: 16:13 R13(ro) - Reserved: Reserved
    Bits: 12    TSRPE(w1c) - TPH ST RAM Parity Error: Uncorrectable parity error detected while reading from the TPH Steering Tag RAM
    Bits: 11    CT(w1c) - Completion Timeout: A request timed out waiting for completion.
    Bits: 10    FCE(w1c) - Flow Control Error: An error was observed in the flow control advertisements from the other side.
    Bits:  9    UCR(w1c) - Unexpected Completion Received: Unexpected Completion received from the link.
    Bits:  8    MTR(w1c) - Malformed TLP Received: Malformed TLP received from the link.
    Bits:  7    PE(w1c) - Phy Error: Phy error detected on receive side. This bit is set when an error is detected in the receive side of the Physical Layer of the Controller (e.g. a bit error or coding violation). This bit is set upon any of the following errors: (1) PHY reported 8B10B error, Disparity Error, Elastic Buffer Overflow Error, Underflow Error (2) GEN3 TLP, DLLP Framing Errors (3) OS Block Received Without EDS (4) Data Block Received After EDS (5) Illegal OS Block After EDS (6) OS Block Received After SKIP OS (7) OS Block Received After SDS (8) Sync Header Error (9) Loss of Gen3 Block Alignment This error is not Function-specific..
    Bits:  6    RTR(w1c) - Replay Timer Rollover: Replay timer rolled over after 4 transmissions of the same TLP.
    Bits:  5    RT(w1c) - Replay Timeout: Replay timer timed out
    Bits:  4    CRFO(w1c) - Completion RX FIFO Overflow: Overflow occurred in the Completion Receive FIFO.
    Bits:  3    PRFO(w1c) - PNP RX FIFO Overflow: Overflow occurred in the PNP Receive FIFO.
    Bits:  2    RRPE(w1c) - Replay RAM Parity Error: Parity error detected while reading from Replay Buffer RAM.
    Bits:  1    CRFPE(w1c) - Completion RX FIFO Parity Error: Parity error detected while reading from the Completion Receive FIFO RAM.
    Bits:  0    PRFPE(w1c) - PNP RX FIFO Parity Error: Parity error detected while reading from the PNP Receive FIFO RAM.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register 0x0000020c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R31_28(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R31_28_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R27(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R27_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_MSIXMSKST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R24(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R24_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_HAWCD BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_MSIENGRCAP BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_MMVC BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_UTC BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R17 BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R13(_x) (((_x) & 0xf) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_R13_of(_x) (((_x) >> 13) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_TSRPE BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_CT BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_FCE BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_UCR BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_MTR BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_PE BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_RTR BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_RT BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_CRFO BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_PRFO BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_RRPE BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_CRFPE BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_register_PRFPE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_intrpt_mask_reg -
    Bits: 31:28 R31_28(ro) - Reserved: Reserved
    Bits: 27:26 R27(ro) - Reserved: Reserved
    Bits: 25    MSIXMSK(rw) - MSIX Function Mask Change: This bit is used to mask interrupt that indicates that the MSIX Function Mask bit of any function, PF or VF, was programmed or configured by Local Firmware Or Host SW.
    Bits: 24:22 R24(ro) - Reserved: Reserved
    Bits: 21    HAWCD(rw) - Hardware Autonomous Width Change Disable Toggle: This bit is used to mask interrupt that indicates that the Host toggled the Hardware Autonomous Width Change in the Endpoint Link Control Register through a Config Write.
    Bits: 20    MSIENGRCAP(rw) - MSI Multiple Message Enable Greater Than Capability: The configured value of MSI Multiple Message Enable[2:0] for a function was greater than the functions MSI Multiple Message Capable[2:0]
    Bits: 19    MMVC(rw) - MSI Mask Value Change: MSI mask register value in the MSI capability register changes value in ANY of the functions in the controller
    Bits: 18    UTC(rw) - Unmapped TC: Unmapped TC error
    Bits: 17    R17(ro) - Reserved: Reserved
    Bits: 16:13 R13(ro) - Reserved: Reserved
    Bits: 12    TSRPE(rw) - TPH ST RAM Parity Error: Uncorrectable parity error detected while reading from the TPH Steering Tag RAM
    Bits: 11    CT(rw) - Completion Timeout: A request timed out waiting for completion.
    Bits: 10    FCE(rw) - Flow Control Error: An error was observed in the flow control advertisements from the other side.
    Bits:  9    UCR(rw) - Unexpected Completion Received: Unexpected Completion received from the link.
    Bits:  8    MTR(rw) - Malformed TLP Received: Malformed TLP received from the link.
    Bits:  7    PE(rw) - Phy Error: Phy error detected on receive side.
    Bits:  6    RTR(rw) - Replay Timer Rollover: Replay timer rolled over after 4 transmissions of the same TLP.
    Bits:  5    RT(rw) - Replay Timeout: Replay timer timed out
    Bits:  4    CRFO(rw) - Completion RX FIFO Overflow: Overflow occurred in the Completion Receive FIFO.
    Bits:  3    PRFO(rw) - PNP RX FIFO Overflow: Overflow occurred in the PNP Receive FIFO.
    Bits:  2    RRPE(rw) - Replay RAM Parity Error: Parity error detected while reading from Replay Buffer RAM.
    Bits:  1    CRFPE(rw) - Completion RX FIFO Parity Error: Parity error detected while reading from the Completion Receive FIFO RAM.
    Bits:  0    PRFPE(rw) - PNP RX FIFO Parity Error: Parity error detected while reading from the PNP Receive FIFO RAM.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg 0x00000210
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R31_28(_x) (((_x) & 0xf) << 28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R31_28_of(_x) (((_x) >> 28) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R27(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R27_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_MSIXMSK BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R24(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R24_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_HAWCD BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_MSIENGRCAP BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_MMVC BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_UTC BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R17 BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R13(_x) (((_x) & 0xf) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_R13_of(_x) (((_x) >> 13) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_TSRPE BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_CT BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_FCE BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_UCR BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_MTR BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_PE BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_RTR BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_RT BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_CRFO BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_PRFO BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_RRPE BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_CRFPE BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_reg_PRFPE BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_lcrc_err_count_reg -
    Bits: 31:16 R11(ro) - Reserved: Reserved
    Bits: 15:0  LEC(w1c) - LCRC Eror Count: Number of TLPs received with LCRC errors.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_lcrc_err_count_reg 0x00000214
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_lcrc_err_count_reg_R11(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_lcrc_err_count_reg_R11_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_lcrc_err_count_reg_LEC(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_lcrc_err_count_reg_LEC_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ecc_corr_err_count_reg -
    Bits: 31:24 R12(w1c) - TPH ST RAM Correctable Error Count: Number of correctable errors detected while reading from the TPH Steering Tag RAM. This is an 8-bit saturating counter that can be cleared by writing all 1s into it.
    Bits: 23:16 RRCER(w1c) - Replay RAM Correctable Error Count: Number of correctable errors detected while reading from the Replay Buffer RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
    Bits: 15:8  SFRCER(w1c) - SC FIFO RAM Correctable Error Count: Number of correctable errors detected while reading from the SC FIFO RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
    Bits:  7:0  PFRCER(w1c) - PNP FIFO RAM Correctable Error Count: Number of correctable errors detected while reading from the PNP FIFO RAM. This is an 8-bit saturating counter that can be cleared by writing all 1's into it.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg 0x00000218
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_R12(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_R12_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_RRCER(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_RRCER_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_SFRCER(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_SFRCER_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_PFRCER(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ecc_corr_err_count_reg_PFRCER_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ltr_snoop_lat_reg -
    Bits: 31    SL(rw) - Snoop Latency: The client software must set this bit to 1 to set the Snoop Latency Requirement bit in the LTR message to be sent.
    Bits: 30:29 R13(ro) - Reserved: Reserved
    Bits: 28:26 SLS(rw) - Snoop Latency Scale: The client software must program this field with the value to be sent in the Snoop Latency Scale field of the LTR message.
    Bits: 25:16 SLV(rw) - Snoop Latency Value: The client software must program this field with the value to be sent in the Snoop Latency Value field of the LTR message.
    Bits: 15    NSLR(rw) - No-Snoop Latency Requirement: The client software must set this bit to 1 to set the No-Snoop Latency Requirement bit in the LTR message to be sent.
    Bits: 14:13 R12(ro) - Reserved:
    Bits: 12:10 NSLS(rw) - No-Snoop Latency Scale: The client software must program this field with the value to be sent in the No-Snoop Latency Scale field of the LTR message.
    Bits:  9:0  NSLV(rw) - No-Snoop Latency Value: The client software must program this field with the value to be sent in the No-Snoop Latency Value field of the LTR message.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg 0x0000021c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_SL BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_R13(_x) (((_x) & 0x3) << 29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_R13_of(_x) (((_x) >> 29) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_SLS(_x) (((_x) & 0x7) << 26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_SLS_of(_x) (((_x) >> 26) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_SLV(_x) (((_x) & 0x3ff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_SLV_of(_x) (((_x) >> 16) & 0x3ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_NSLR BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_R12(_x) (((_x) & 0x3) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_R12_of(_x) (((_x) >> 13) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_NSLS(_x) (((_x) & 0x7) << 10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_NSLS_of(_x) (((_x) >> 10) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_NSLV(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_snoop_lat_reg_NSLV_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg -
    Bits: 12    TMFPSC(rw) - Transmit Message on Function Power State Change: When this bit is set to 1, the Controller will automatically transmit an LTR message when all the Functions in the Controller have transitioned to a non-D0 power state, provided that the following conditions are both true: 1. The Controller sent at least one LTR message since the Data Link layer last transitioned from down to up state. 2. The most recent LTR message transmitted by the Controller had as least one of the Requirement bits set. The Controller will set the Requirement bits in this LTR message to 0. When this bit 12 is 0, the Controller will not, by itself, send any LTR messages in response to Function Power State changes. Client logic may monitor the FUNCTION_POWER_STATE outputs of the Controller and transmit LTR messages through the master interface, in response to changes in their states.
    Bits: 11    TMLMET(rw) - Transmit Message on LTR Mechanism Enable Transition: When this bit is set to 1, the Controller will automatically transmit an LTR message whenever the LTR Mechanism Enable bit in the Device Control 2 Register changes from 0 to 1, with the parameters specified in the LTR Snoop/No-Snoop Latency Register. When this bit is 1, the Controller will also transmit an LTR message whenever the LTR Mechanism Enable bit is cleared, if the following conditions are both true: 1. The Controller sent at least one LTR message since the LTR Mechanism Enable bit was last set. 2. The most recent LTR message transmitted by the Controller had as least one of the Requirement bits set. The Controller will set the Requirement bits in this LTR message to 0. When this bit 11 is 0, the Controller will not, by itself, send any LTR messages in response to state changes of the LTR Mechanism Enable bit. Client logic may monitor the state of the LTR_MECHANISM_ ENABLE output of the Controller and transmit LTR messages through the master interface, in response to its state changes.
    Bits: 10    SLM(ro) - Send LTR Message: Setting this bit causes the Controller to transmit an LTR message with the parameters specified in the LTR Snoop/No-Snoop Latency Register (Section 8.4.2.9). This bit is cleared by the Controller on transmitting the LTR message, and stays set until then. Client software must read this register and verify that this bit is 0 before setting it again to send a new message. This field becomes writable when LTR mechanism is enabled in device control-2 register.
    Bits:  9:0  MLI(rw) - Minimum LTR Interval: This field specifies the minimum spacing between LTR messages transmitted by the Controller in units of microseconds. The PCI Express Specifications recommend sending no more than two LTR messages within a 500 microsecond interval. The Controller will wait for the minimum delay specified by this field after sending an LTR message, before transmitting a new LTR message. NOTE: The LINK can be in low power states(L0s and L1) when send LTR Message is trigered. So, the user has to consider the exit latencies while programming this field. It is recommended to program this field with about 2 us higher than the required interval to account for the L0s/L1 exit latencies.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg 0x00000220
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg_TMFPSC BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg_TMLMET BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg_SLM BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg_MLI(_x) (((_x) & 0x3ff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ltr_msg_gen_ctl_reg_MLI_of(_x) (((_x) >> 0) & 0x3ff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg -
    Bits: 31:21 R21(ro) - Reserved: Reserved
    Bits: 20    DPMOPS(rw) - Disable PME message on PM Status: When this bit is set, Controller will not automatically send a PME message, when PM Status bit in PMCSR register is set
    Bits: 19:0  PSTD(rw) - PME Service Timeout Delay: Specifies the timeout delay for retransmission of PM_PME messages. The value is in units of microseconds. The actual time elapsed has a +1 microseconds tolerance from the value programmed.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg 0x00000224
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg_R21(_x) (((_x) & 0x7ff) << 21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg_R21_of(_x) (((_x) >> 21) & 0x7ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg_DPMOPS BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg_PSTD(_x) (((_x) & 0xfffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pme_service_timeout_delay_reg_PSTD_of(_x) (((_x) >> 0) & 0xfffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_ep_bus_device_number_reg -
    Bits: 31:16 R16(ro) - Reserved: Reserved
    Bits: 15:8  EPBN(ro) - Bus Number: Bus Number captured by Function 0 in End Point mode
    Bits:  7:5  R5(ro) - Reserved: Reserved
    Bits:  4:0  EPDN(ro) - Device Number: Device Number captured by Function 0 in End Point mode
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg 0x0000022c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_R16(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_R16_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_EPBN(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_EPBN_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_R5(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_R5_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_EPDN(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_ep_bus_device_number_reg_EPDN_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_debug_mux_control_2_reg -
    Bits: 31:29 R31(ro) - Reserved: Reserved
    Bits: 28    DFLRTRB(rw) - Disable FLR Termination Resp Block: 1 : NP Termination due to FLR/Completion Timeout is delayed till the RX Completion FIFO is Empty. 0 : NP Termination due to FLR is done immediately on receiving FLR/Completion Timeout.
    Bits: 27    R27(ro) - Reserved: Reserved
    Bits: 26    R26(ro) - Reserved: Reserved
    Bits: 25    MSIXMSKEN(rw) - MSIX Function Mask Change Enhanced Interrupt Enable: By default, the Controller provides a single status bit when any function's MSIX Function Mask is programmed or configured by Local firmware or Host SW. Controller also implements an enhanced MSIX Function Mask Interrupt mechanism, which provides per-function set/clear status when a function's MSIX Function Mask is updated by SW. This Local Management programmable bit allows user to choose between the Default and Enhanced MSIX Function Mask Change Interrupt mechanisms.
    Bits: 24    MSIMSKEN(rw) - MSI Mask Change Enhanced Interrupt Enable: By default, the Controller provides a single status bit when any function's MSI Mask is programmed or configured by Local firmware or Host SW. Controller also implements an enhanced MSI Mask Interrupt mechanism, which provides per-function set/clear status when a function's MSI Mask is updated by SW. This Local Management programmable bit allows user to choose between the Default and Enhanced MSI Mask Change Interrupt mechanisms.
    Bits: 23    VARCCLKEN(rw) - Enable Variable Core Clock: If this bit is set the CORE_CLK input can be driven with Variable Clock depending on the Link Speed,similar to the PIPE_PCLK.
    Bits: 22:13 MAXNPREQ(rw) - Maximum NP Outstanding Request Limit: The Controller supports 128 outstanding NP requests that can be initiated by the User. However, the number of split completion TLPs that can be stored in the Controller is limited to 128. The Completion FIFO will overflow if more than 128 split completion packets are pending. If the User interface can accept inbound Posted and Completion packets at the same rate as received from PCIe link, then the split completion FIFO will never reach the FULL condition. However, if the User cannot guarantee this, then this register needs to be programmed as described in the Programming Guide section of the Controller User guide. The Controller will limit the maximum number of outstanding NP requests to the value programmed in this register. Example: 8 : Controller will limit maximum number of outstanding NP requests to 8. 0-7 : Reserved Default Value is 128
    Bits: 12    AXINPSPEN_RSVD(ro) - RESERVED: RESERVED
    Bits: 11    CMPTOADV(rw) - Completion Timeout Advisory Non Fatal: As per PCIe specification on Error Signaling, the Requester detecting a Completion Timeout is allowed to handle this as an Advisory Non Fatal Error. 1: Completion Timeout is handled as Advisory Non-Fatal Error. 0: Completion Timeout is handled as normally as a Non-Fatal Error.
    Bits: 10    PSNADV(rw) - Poisoned TLP Received Advisory Non Fatal: As per PCIe specification 2.7.2.2, the following Poisoned TLP requests must be handled as Uncorrectable and not as Advisory: I/O Write Request, Memory Write Request, or non-vendor-defined Message with data that target a Control structure. Since it is not possible for the Controller to determine if the target is a Control or a non-Control strusture, the Controller implements this bit for the user to determine the required handling. 1: Poisoned TLP of type IOWr, MemWr, MsgD will be handled as Advisory Non-Fatal Error. 0: Poisoned TLP of type IOWr, MemWr, MsgD will be handled as Uncorrectable Error. Note: Poisoned CplD will always be reported as Advisory Non-Fatal and is not controlled by this register setting.
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    R8(ro) - Reserved: Reserved
    Bits:  7:6  BLKALNWIN(rw) - Gen3 Block Alignment Check Window: When in the data stream at Gen3 or higher speeds, the pipe_rx_valid is asserted by the PHY. If the block alignment is lost, then the PHY may deassert pipe_rx_valid. Controller reports loss of block alignment if pipe_rx_valid or pipe_rx_data_valid=0 for a period consecutive clock cycles as programmed in this field. 00: 8 CORE_CLK cycles 01: 16 CORE_CLK cycles 10: 64 CORE_CLK cycles 11: 256 CORE_CLK cycles
    Bits:  5    BLKALNCHK(rw) - Gen3 Block Alignment Check Disable: When in the data stream at Gen3 or higher speeds, the pipe_rx_valid is asserted by the PHY. If the block alignment is lost, then the PHY may deassert pipe_rx_valid. Block Alignment may be lost if the received sync header is invalid. Controller supports detecting loss of block alignment while in a data stream in Gen3. 0: Enable check for loss of Gen3 Block Alignment during data stream. 1: Disable check for loss of Gen3 Block Alignment.
    Bits:  4    ARICAPMOD(rw) - ARI Capable Hierarchy Mode: As per SR IOC specification, ARI Capable Hierarchy bit is only present in the lowest numbered PF of a Device. The Controller has two modes to determine the lowest numbered PF. 0: the first PF which is enabled (PF0) is taken as the lowest numbered PF. 1: the first PF which has a non-zero TOTAL_VF_COUNT field is taken as the lowest numbered PF.(Default Mode)
    Bits:  3    ENLNCHK(rw) - Enable Link Lane Number Check for Loopback and Link Disable: As per PCIe specification, LTSSM should transition to Disabled after any Lanes that are transmitting TS1 Ordered Sets receive two consecutive TS1 Ordered Sets with the Disable Link bit asserted. Similarly, LTSSM should transition to Loopback after all Lanes that are transmitting TS1 Ordered Sets, that are also receiving TS1 Ordered Sets, receive the Loopback bit asserted in two consecutive TS1 Ordered Sets. Controller ignores the Link and Lane Number in the Received TS1s with Loopback/Disable bit set. Setting this bit to 1 turns on the check for link number (assigned by RC in Recovery.Idle) and lane number (PAD in Config.LW.Start or as assigned by RC in Recovery.Idle). This bit is recommended to be kept at the default value of 0.
    Bits:  2    DISSDSCHK(rw) - Disable SDS OS Check: As per PCIe specification, When using 128b/130b encoding, next state is L0 if eight consecutive Symbol Times of Idle data are received on all configured Lanes. The Controller checks to ensure that the Idle symbols of data are received in Data Blocks after SDS OS. This check is enabled by default. Setting this bit to 1 turns off this check. This bit is recommended to be kept at the default value of 0.
    Bits:  1    EXTSNP(rw) - Enable Extended Config Snoop Read: This bit can be set if an extra clock cycle is required by the Client Application logic to respond with the Read Data on Configuration Snoop Interface. Please refer to the user guide section on Configuration Snoop Interface for timing diagrams.
    Bits:  0    DLFFS(rw) - Disable LOCALLF, LOCALFS sampling after speed change: As per PIPE 4.2 specification, the LOCALLF, LOCALFS outputs from PHY can be sampled uponf PHYSTATUS pulse after Reset# OR upon the first PHYSTATUS pulse after speed change to GEN3. This bit can be set to 1 to disable sampling after speed change to GEN3 or higher
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg 0x00000234
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R31(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R31_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_DFLRTRB BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R27 BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R26 BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_MSIXMSKEN BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_MSIMSKEN BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_VARCCLKEN BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_MAXNPREQ(_x) (((_x) & 0x3ff) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_MAXNPREQ_of(_x) (((_x) >> 13) & 0x3ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_AXINPSPEN_RSVD BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_CMPTOADV BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_PSNADV BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R9 BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_R8 BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_BLKALNWIN(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_BLKALNWIN_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_BLKALNCHK BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_ARICAPMOD BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_ENLNCHK BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_DISSDSCHK BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_EXTSNP BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_debug_mux_control_2_reg_DLFFS BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_phy_status_1_reg -
    Bits: 31:9  R31(ro) - Reserved: Reserved
    Bits:  8    LOSBLKALN(w1c) - Loss of Block Alignment Error: This bit is set if the PHY Loses Block Alignment during data stream. This is detected based upon an unexpected PIPE_RX_VALID input deassertion during data stream. Write a 1 to clear this error.
    Bits:  7    INVSYNHR(w1c) - Invalid Sync Header Error: This bit is set if an invalid Sync Header is detected. 00 and 11 are Invalid Sync Headers. Write a 1 to clear this error. .
    Bits:  6    OSAFSDS(w1c) - OS Block Received After SDS: This bit is set if an SDS is received after an SDS. This is a framing error. Write a 1 to clear this error.
    Bits:  5    G3FRERR(w1c) - Gen3 Framing Error Detected: This bit is set if a framing error is detected while receiving a TLP in Gen3. Example, if an invalid token is received in a data stream, this error is flagged. Write a 1 to clear this error.
    Bits:  4    OSWOEDS(w1c) - OS Block Received without EDS: This bit is set if an Ordered Set Block is received without an EDS. This is a framing error. Write a 1 to clear this error.
    Bits:  3    DATEDS(w1c) - Data Block After EDS: This bit is set if a Data Block is received after an EDS. Write a 1 to clear this error.
    Bits:  2    ILOSEDS(w1c) - Illegal OS Block After EDS: The Valid OS blocks after an EDS are EIOS, EIEOS and SKP. If any other OS blocks are received after EDS, then it is a framing error and this bit is asserted.
    Bits:  1    OSASKP(w1c) - OS Block After Skip OS: This bit indicates that an Ordered Set BLock was received immediately after a SKIP OS. This is a framing error. Write a 1 to clear this field.
    Bits:  0    TLPPHYER(w1c) - TLP PHY Error Status: This bit indicates that a PHY Error was detected on the PIPE_RX_STATUS within a TLP. Write a 1 to clear this field.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg 0x00000238
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_R31(_x) (((_x) & 0x7fffff) << 9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_R31_of(_x) (((_x) >> 9) & 0x7fffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_LOSBLKALN BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_INVSYNHR BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_OSAFSDS BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_G3FRERR BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_OSWOEDS BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_DATEDS BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_ILOSEDS BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_OSASKP BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_phy_status_1_reg_TLPPHYER BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_BAR_config_0_reg -
    Bits: 31:29 BAR3C(rw) - BAR 3 Control: Specifies the configuration of BAR3. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 28:24 BAR3A(rw) - BAR 3 Aperture: Specifies the aperture of the BAR 3 when it is configured as a 32-bit BAR. For 32-bit BAR 3, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits: 23:21 BAR2C(rw) - BAR 2 Control: Specifies the configuration of BAR2. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits: 20:16 BAR2A(rw) - BAR 2 Aperture: Specifies the aperture of the 32-bit BAR 2 or 64bit BAR2-3. For 32-bit BAR 2, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR2-3, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
    Bits: 15:13 BAR1C(rw) - BAR 1 Control: Specifies the configuration of BAR1. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  BAR1A(rw) - BAR 1 Aperture: Specifies the aperture of the BAR 1 when it is configured as a 32-bit BAR. For 32-bit BAR 1, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits:  7:5  BAR0C(rw) - BAR 0 Control: Specifies the configuration of BAR0. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  BAR0A(rw) - BAR 0 Aperture: Specifies the aperture of the 32-bit BAR 0 or 64bit BAR0-1. For 32-bit BAR 0, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR0-1, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_0_BAR_config_0_reg 0x00000240
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_1_BAR_config_0_reg 0x00000248
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_2_BAR_config_0_reg 0x00000250
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_3_BAR_config_0_reg 0x00000258
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR3C(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR3C_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR3A(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR3A_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR2C(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR2C_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR2A(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR2A_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR1C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR1C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR1A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR1A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR0C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR0C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR0A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_0_reg_BAR0A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_BAR_config_1_reg -
    Bits: 31    ERBC(rw) - Enable Resizable BAR Capability: Setting this bit to 1 enables the Resizable BAR Capability in the PCI Express Configuration Space of the associated Function. When the Resizable BAR Capability is enabled, the apertures of the memory BARs of the corresponding Function are no longer selected by the fields in this register, but by the setting of the registers in the Resizable BAR Capability Structure.
    Bits: 30:24 R24(ro) - Reserved: Reserved
    Bits: 23:22 R22(ro) - Reserved: Reserved
    Bits: 21    ERBE(rw) - EXP-ROM BAR Enable: This bit must be set to enable the Expansion ROM BAR associated with the Function.
    Bits: 20:16 ERBA(rw) - EXP-ROM BAR Aperture: Specifies the aperture of the Expansion ROM BAR. The encodings are: 00000-00011 = undefined, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 00110 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes,10010-11111 = undefined
    Bits: 15:13 BAR5C(rw) - BAR 5 Control: Specifies the configuration of BAR5. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  BAR5A(rw) - BAR 5 Aperture: Specifies the aperture of the BAR 5 when it is configured as a 32-bit BAR. For 32-bit BAR 5, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB
    Bits:  7:5  BAR4C(rw) - BAR 4 Control: Specifies the configuration of BAR4. The various encodings are: 000: Disabled 001: 32bit IO BAR 010-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  BAR4A(rw) - BAR 4 Aperture: Specifies the aperture of the 32-bit BAR 4 or 64bit BAR4-5. For 32-bit BAR 4, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB For 64-bit BAR4-5, the valid encodings are: 00000 = 128 B, 00001 = 256 B, 00010 = 512 B, 00011 = 1 KB, 00100 = 2 KB, 00101 = 4 KB, 00110 = 8 KB, 00111 = 16 KB, 01000 = 32 KB, 01001 = 64 KB, 01010 = 128 KB, 01011 = 256 KB, 01100 = 512 KB, 01101 = 1 MB, 01110 = 2 MB, 01111 = 4 MB, 10000 = 8 MB, 10001 = 16 MB, 10010 = 32 MB, 10011 = 64 MB, 10100 = 128 MB, 10101 = 256 MB, 10110 = 512 MB, 10111 = 1 GB, 11000 = 2 GB, 11001 = 4 GB, 11010 = 8 GB, 11011 = 16 GB, 11100 = 32 GB, 11101 = 64 GB, 11110 = 128 GB, 11111 = 256 GB
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_0_BAR_config_1_reg 0x00000244
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_1_BAR_config_1_reg 0x0000024c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_2_BAR_config_1_reg 0x00000254
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_3_BAR_config_1_reg 0x0000025c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_ERBC BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_R24(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_R24_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_R22(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_R22_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_ERBE BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_ERBA(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_ERBA_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR5C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR5C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR5A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR5A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR4C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR4C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR4A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_pf_BAR_config_1_reg_BAR4A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_0_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_0_reg -
    Bits: 31:29 VFBAR3C(rw) - VF BAR 3 Control: Specifies the configuration of VF BAR3. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 28:24 VFBAR3A(rw) - VF BAR 3 Aperture: Specifies the aperture of the VF BAR 3 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits: 23:21 VFBAR2C(rw) - VF BAR 2 Control: Specifies the configuration of VF BAR2. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits: 20:16 VFBAR2A(rw) - VF BAR 2 Aperture: Specifies the aperture of the 32-bit VF BAR 2 or 64bit VF BAR2-3. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
    Bits: 15:13 VFBAR1C(rw) - VF BAR 1 Control: Specifies the configuration of VF BAR1. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  VFBAR1A(rw) - VF BAR 1 Aperture: Specifies the aperture of the VF BAR 1 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits:  7:5  VFBAR0C(rw) - VF BAR 0 Control: Specifies the configuration of VF BAR0. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  VFBAR0A(rw) - VF BAR 0 Aperture: Specifies the aperture of the 32-bit VF BAR 0 or 64bit VF BAR0-1. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_0_reg 0x00000280
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_0_reg 0x00000288
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_0_reg 0x00000290
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_0_reg 0x00000298
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR3C(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR3C_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR3A(_x) (((_x) & 0x1f) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR3A_of(_x) (((_x) >> 24) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR2C(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR2C_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR2A(_x) (((_x) & 0x1f) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR2A_of(_x) (((_x) >> 16) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR1C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR1C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR1A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR1A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR0C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR0C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR0A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_0_reg_VFBAR0A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_1_reg -
  Register: i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_1_reg -
    Bits: 31:16 R16(ro) - Reserved: Reserved
    Bits: 15:13 VFBAR5C(rw) - VF BAR 5 Control: Specifies the configuration of VF BAR5. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110-111: Reserved
    Bits: 12:8  VFBAR5A(rw) - VF BAR 5 Aperture: Specifies the aperture of the VF BAR 5 when it is configured as a 32-bit BAR. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes
    Bits:  7:5  VFBAR4C(rw) - VF BAR 4 Control: Specifies the configuration of VF BAR4. The various encodings are: 000: Disabled 001-011: Reserved 100: 32bit memory BAR, non prefetchable 101: 32bit memory BAR, prefetchable 110: 64bit memory BAR, non prefetchable 111: 64bit memory BAR, prefetchable
    Bits:  4:0  VFBAR4A(rw) - VF BAR 4 Aperture: Specifies the aperture of the 32-bit VF BAR 4 or 64bit VF BAR4-5. The encodings are: 00000 = 128 Bytes, 0001 = 256 Bytes, 0010 = 512 Bytes, 0011 = 1 Kbytes, 00100 = 2 Kbytes, 00101 = 4 Kbytes, 00110 = 8 Kbytes, 00111 = 16 Kbytes, 01000 = 32 Kbytes, 01001 = 64 Kbytes, 01010 = 128 Kbytes, 01011 = 256 Kbytes, 01100 = 512 Kbytes, 01101 = 1 Mbyte, 01110 = 2 Mbytes, 01111 = 4 Mbytes, 10000 = 8 Mbytes, 10001 = 16 Mbytes, 10010 = 32 Mbytes, 10011 = 64 Mbytes, 10100 = 128 Mbytes, 10101 = 256 Mbytes, 10110 = 512 Mbytes, 10111 = 1 Gbyte, 11000 = 2 Gbytes, 11001 = 4 Gbytes, 11010 = 8 Gbytes, 11011 = 16 Gbytes, 11100 = 32 Gbytes, 11101 = 64 Gbytes, 11110 = 128 Gbytes, 11111 = 256 Gbytes
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_0_vf_BAR_config_1_reg 0x00000284
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_1_vf_BAR_config_1_reg 0x0000028c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_2_vf_BAR_config_1_reg 0x00000294
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_3_vf_BAR_config_1_reg 0x0000029c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_R16(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_R16_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR5C(_x) (((_x) & 0x7) << 13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR5C_of(_x) (((_x) >> 13) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR5A(_x) (((_x) & 0x1f) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR5A_of(_x) (((_x) >> 8) & 0x1f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR4C(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR4C_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR4A(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_vf_BAR_config_1_reg_VFBAR4A_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_pf_config_reg -
    Bits: 31:4  R(ro) - Reserved: Reserved
    Bits:  3    F3E(rw) - Function 3 Enable: Enable for Function 3. This bit can be modified from the local management bus.
    Bits:  2    F2E(rw) - Function 2 Enable: Enable for Function 2. This bit can be modified from the local management bus.
    Bits:  1    F1E(rw) - Function 1 Enable: Enable for Function 1. This bit can be modified from the local management bus.
    Bits:  0    F0E(ro) - Function 0 Enable: Enable for Function 0. This bit is hardwired to 1.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg 0x000002c0
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_R(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_R_of(_x) (((_x) >> 4) & 0xfffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_F3E BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_F2E BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_F1E BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_pf_config_reg_F0E BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_default_preset_reg -
    Bits: 31:19 R31(ro) - Reserved: Reserved
    Bits: 18:8  S8GPR(rw) - Supported 8G Preset: This register can be used to program the Presets that are supported by local Transmitter at 8Gbps. Default value of this register is determined by the SUPPORTED_PRESET strap input. Note: At 8.0 GT/s and 16.0 GT/s all preset values must be supported for Full swing signaling. Reduced swing signaling must implement presets #4, #1, #9, #5, #6, and #3.
    Bits:  7    R7(ro) - Reserved: Reserved
    Bits:  6:4  GDRXPH(rw) - Default Receiver Preset Hint: Default receiver preset hint value used for a lane that did not receive EQ TS2 in Recovery.RcvrCfg LTSSM state
    Bits:  3:0  GDTXP(rw) - Default Transmitter Preset: Default transmitter preset value used for a lane that did not receive EQ TS2 in Recovery.RcvrCfg LTSSM state
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg 0x00000360
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_R31(_x) (((_x) & 0x1fff) << 19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_R31_of(_x) (((_x) >> 19) & 0x1fff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_S8GPR(_x) (((_x) & 0x7ff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_S8GPR_of(_x) (((_x) >> 8) & 0x7ff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_R7 BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_GDRXPH(_x) (((_x) & 0x7) << 4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_GDRXPH_of(_x) (((_x) >> 4) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_GDTXP(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_default_preset_reg_GDTXP_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg -
    Bits: 31:30 RXEQABM(rw) - RXEQINPROGRESS Abort Timer Mode Control: When a 24ms timeout occurs in the LTSSM Equalization Phase 2, the Controller aborts Equalization Phase 2 and transitions to Recovery.Rcvr.Lock. In this case, the RxEqEval output on the PIPE Interface will be de-asserted immediately (if it was asserted). The RxEqInProgress output will stay high and waits for PhyStatus pulse. Controller implements a timer to select an upper limit to wait for this PhyStatus pulse during an abort to de-assert RxEqInProgress. 00: Wait for a maximum of 4 PIPE_PCLK period. 01: Wait for a maximum of 8 PIPE_PCLK period. 10: Wait for a maximum of 16 PIPE_PCLK period. 11: Disabled. Wait till PhyStatus Pulse is received. Note: This register is used only if RxEqEval was asserted when LTSSM 24ms timeout occured in Equalization.
    Bits: 29    RXEQABD(rw) - RXEQINPROGRESS Abort Disable: In an unexpected case where the PIPE_PCLK stops due to error in equalization, this bit can be set to de-couple RxEqInProgress from the rest of the equalization state machine. This bit should not be set for normal usage.
    Bits: 28    R28(ro) - Reserved: Reserved
    Bits: 27:0  LEQT2ms(rw) - Link Equalization Timeout 2ms: Time spent for evaluation per TX Setting in Endpoint Phase 2 (RC Mode Phase 3) of Link Equalization specified in multiples of 16ns. eg. the value 125000 will result in 125000*16ns = 2ms. Simulation with reduced time mode(PCIE_SIM define) will give a samller value of 300 as power on reset value.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg 0x00000364
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_RXEQABM(_x) (((_x) & 0x3) << 30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_RXEQABM_of(_x) (((_x) >> 30) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_RXEQABD BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_R28 BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_LEQT2ms(_x) (((_x) & 0xfffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_timeout_2ms_reg_LEQT2ms_of(_x) (((_x) >> 0) & 0xfffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg -
    Bits: 31:3  RES3(ro) - Reserved: Reserved
    Bits:  2:0  MXECC(rw) - Max Eval Convergence Count: Controls the number of consecutive RxEqEval iterations with direction change feedback of 00s before Equalization Convergence is inferred. 0 : Infer Convergence after 1 feedback of 000000 1 : Infer Convergence after 2 feedback of 000000 2 : Infer Convergence after 3 consecutive feedback of 000000 .. 7 : Infer Convergence after 8 consecutive feedback of 000000. Note: Each lane independently counts consecutive feedback of 000000. Note: Count is reset after a non-000000 feedback on each lane.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg 0x00000368
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg_RES3(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg_RES3_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg_MXECC(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_ctrl_reg_MXECC_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane0 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane1 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane2 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane3 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane4 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane5 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane6 -
  Register: i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane7 -
    Bits: 31:26 RES3126(ro) - Reserved: Reserved
    Bits: 25:8  LEQTXCO(ro) - Link Equalization TX Coefficient: TX Coefficients agreed upon for this lane. [25:20] : Post Cursor Coefficient [19:14] : Cursor Coefficient [13:8] : Pre-Cusror Coefficient
    Bits:  7:5  RES75(ro) - Reserved: Reserved
    Bits:  4    LEQTXPRV(ro) - Link Equalization TX Preset Valid: TX Preset Valid Indicator. This bit is set when a TX Preset is received in TS1s with the use_preset bit set in Endpoint Mode Phase 3 or RC Mode Phase 2.
    Bits:  3:0  LEQTXPR(ro) - Link Equalization TX Preset: TX Preset agreed upon for this lane
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane0 0x00000380
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane1 0x00000384
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane2 0x00000388
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane3 0x0000038c
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane4 0x00000390
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane5 0x00000394
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane6 0x00000398
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_gen3_link_eq_debug_status_reg_lane7 0x0000039c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_RES3126(_x) (((_x) & 0x3f) << 26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_RES3126_of(_x) (((_x) >> 26) & 0x3f)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_LEQTXCO(_x) (((_x) & 0x3ffff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_LEQTXCO_of(_x) (((_x) >> 8) & 0x3ffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_RES75(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_RES75_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_LEQTXPRV BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_LEQTXPR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_gen3_link_eq_debug_status_reg_LEQTXPR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control0 -
    Bits: 27    L1DLEUP(rw) - Disable L1 exit upon Pending Tlps: Pending Tlps trigger a L1 exit by default. This includes internaly generated messages and internaly blocked TLPs. Setting this bit changes the default behavior. This is required only for debug purpose.
    Bits: 26:25 L1EM(ro) - L1 entry mode: This field shows the last entered L1 mode. This is useful for debug. bit 0 - Entry mode was ASPM. Bit 1 - Entry mode was PM. This is reset before any new L1 entry.
    Bits: 24    L1DBRI(rw) - Do Not block Request interface: Before entering L1, controller internally blocks all TLP and Register Request interface entering controller. interfaces are internally unblocked while exiting L1. This field control this behavior. '1' in this field makes the controler to do not perform any blocking to interfaces. '0' makes the controller behaves normaly. This is required only for debug purpose. Power shutoff feature has to be disabled while using this field.
    Bits: 23:0  L1XDELAY(rw) - L1 substate entry delay: Normaly L1 substate entry process is initiated immedaitely after LTSSM enters L1. A delay in micro-seconds can be given in this field to delay L1 substate entry process. This timeout has 0-1us margin of error. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_L1_SUBSTATE_ENTRY_DELAY
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0 0x00000c88
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1DLEUP BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1EM(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1EM_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1DBRI BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1XDELAY(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control0_L1XDELAY_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control1 -
    Bits:  7:0  L1ER(ro) - L1 or L1.x Exit Trigger conditions: This field shows the values of possible L1 or L1-substate exit triggers. This is useful for debug. this is captured during L1 or L1-substate exit process. this field is reset during L1 entry. 0 : CLIENT_REQ_EXIT_L1 asserted 1 : Electrical Idle exit detected at link 2 : New TLP request detected 3 : Internal request to send TLP. This includes CFG completions. internal messages. INTx messages 4 : Pending TX traffic available. This could be traffic from DMA and blocked traffic due to credits at AXI. 5 : #CLKREQ assert detected 6 : CLIENT_REQ_EXIT_L1_SUBSTATE asserted 7 : Reg Access request detected Triggers #5,6,7 are valid only with L1-substate supported configs.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control1 0x00000c8c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control1_L1ER(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control1_L1ER_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_low_power_debug_and_control2 -
    Bits: 30    L1CSC(rw) - Client supplies slow clock to core during L1: L1-substate removes CORE_CLK. since the registers are implemented in core-clk, register access is not possible during L1-substate. If client can supply a slow clock to core(CORE_CLK) during L1-substates, APB/mgmt access is possible in L1.x. set this bit if client can supply slow clock to CORE_CLK when CLKREQ_IN_N is 1(de-asserted). If this bit is set, Controller neither wake-up from L1 or generate error response for APB access during L1.x. Controller behavior is undefined if register write is performed while slow clock is supplied to core_clk. Recommended flow is to first exit from L1-substate and perform register writes. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_CLIENT_SUPPLIES_SLOW_CLK_TO_CORE_DURING_L1
    Bits: 29    L1DAET(rw) - Disable Autonomous L1.x exit upon reg access: L1.x turns off clocks to the controller. Default behavior is made to exit L1.x if Register access request is present at register interface. Setting this bit disables this feature. If this bit is set and CLKREQ_IN_N is 1(de-asserted), Controller responds with ERROR response to APB requests. Client can use CLIENT_EXIT_L1_SUBSTATE pin to trigger L1.x exit if autonomous exit is disabled for register access. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_DISABLE_AUTONOMOUS_L1_EXIT_ON_NEW_REG_REQ
    Bits: 28    L1TROW(ro) - Timeout occured during RX and outstanding wait: This is a debug status field. '1' in this field indicates that a timeout has occured while waiting for RX path or OUTstanding packet IDLE conditions. This is cleared on new entry to L1.
    Bits: 26    L1ERC(rw) - Enable RX path check: Enables waiting for RX path IDLE condition before entering L1.x. This checks that all packets from PCIE link has reached client side before entering L1.x. This only a tuning register. Not setting this regsiter will cause controller to enter L1.x to save power without checking this. controller will resume transferring RX data once it exit from L1.x state if RX buffers were not empty. This field is ignored if Power shutoff mechanism is enabled for L1.x and Controller will always check RX path idle condition before turning off internal power(with cpf flow). If timeout is enabled, controller enters L1.x without internal power shutoff after timeout. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_WAIT_FOR_RX_BUFFER_IDLE
    Bits: 25    L1EOC(rw) - Enable outstanding CPL check: Enable waiting for outstanding completions before entering L1.x. Outstanding packets expected from pcie link as well as from AXI side is checked. FOR HAL configurations client has to assert PREVENT_L1x_ENTRY signal to prevent L1x entry. This only a tuning register. Not setting this regsiter will cause controller to enter L1.x to save power without checking this. controller exit from L1.x as soon as it receives expected TLps. This field is ignored if Power shutoff mechanism is selected for L1.x and Controller will always wait for outstanding packets before turning off internal power(with cpf flow). If timeout is enabled, controller enters L1.x without internal power shutoff after timeout. This bit is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_WAIT_FOR_OUTSTANDING_CPLS
    Bits: 23:0  L1TWROI(rw) - Timeout while waiting for RX IDLE and OUTSTANDING Idle.: This field enables a timeout mechanism while waiting for RX buffers and Outstanding Pkts before turning off power. Controller enters L1 substate after timeout. A value of 0x0 disables this timeout mechanism. Controller do not select internal power shutoff if it enters L1.x with this timeout. User can give timeout in micro-seconds using this register. This field is ignored if L1 substate is disabled. Power on reset value of this register can be adjusted by modifying the define `den_db_LP_DBG_CTRL_RX_CPL_IDLE_CHECK_TIMEOUT
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2 0x00000c90
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1CSC BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1DAET BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1TROW BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1ERC BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1EOC BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1TWROI(_x) (((_x) & 0xffffff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_low_power_debug_and_control2_L1TWROI_of(_x) (((_x) >> 0) & 0xffffff)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_tl_internal_control -
    Bits: 31:1  RES1(ro) - Reserved: Reserved
    Bits:  0    ECFLR(rw) - Enable CRS under FLR: By default controller ignores config request if a function is under going FLR. Setting this bit Makes the controller to respond with CRS response. Power on reset value of this register can be adjusted by modifying the define `den_db_TL_CTRL_ENABLE_CRS_UNDER_FLR
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_tl_internal_control 0x00000c94
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_tl_internal_control_RES1(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_tl_internal_control_RES1_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_tl_internal_control_ECFLR BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_error_status_2_register -
    Bits: 31:10 R31(ro) - Reserved: Reserved
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    NFTSTOS(w1c) - NFTS Timeout Status: This status bit indicates that a NFTS Timeout occured. This could occur if the PHY failed to achieve lock on the receive data before the NFTS Timeout during Rx_L0s.FTS state. Local Firmware should consider increasing the advertized NFTS values if this event occurs.
    Bits:  7:4  R4(ro) - Reserved: Reserved
    Bits:  3    MSIXMSKSETST(w1c) - MSIX Function Mask Set Status: This status bit indicates that the MSIX Function Mask of any function, PF or VF, was programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSIX Function Mask Clear status per-function is captured in the msix_function_mask_set_status_register. Firmware has to clear the per-function bits in msix_function_mask_set_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  2    MSIXMSKCLST(w1c) - MSIX Function Mask Cleared Status: This status bit indicates that the MSIX Function Mask of any function, PF or VF, was programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSIX Function Mask Clear status per-function is captured in the msix_function_mask_cleared_status_register. Firmware has to clear the per-function bits in msix_function_mask_cleared_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  1    MSIMSKSETST(w1c) - MSI Mask Set Status: This status bit indicates that One or More bits of MSI Mask of any function, PF or VF, was programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSI Mask Clear status per-function is captured in the msi_mask_set_status_register. Firmware has to clear the per-function bits in msi_mask_set_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
    Bits:  0    MSIMSKCLST(w1c) - MSI Mask Cleared Status: This status bit indicates that One or More bits of MSI Mask of any function, PF or VF, was programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Note that this is a Read Only Status bit. The MSI Mask Clear status per-function is captured in the msi_mask_cleared_status_register. Firmware has to clear the per-function bits in msi_mask_cleared_status_register in order to clear this status bit and to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register 0x00000d00
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_R31(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_R31_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_R9 BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_NFTSTOS BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_R4(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_R4_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_MSIXMSKSETST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_MSIMSKSETST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_error_status_2_register_MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg -
    Bits: 31:10 R31(ro) - Reserved: Reserved
    Bits:  9    R9(ro) - Reserved: Reserved
    Bits:  8    NFTSTOM(rw) - NFTS Timeout Mask: Mask for NFTS Timeout.
    Bits:  7:4  R4(ro) - Reserved: Reserved
    Bits:  3    MSIXMSKSET(rw) - MSIX Function Mask Set: Mask for MSIX Function Mask Cleared Status.
    Bits:  2    MSIXMSKCL(rw) - MSIX Function Mask Cleared: Mask for MSIX Function Mask Set Status.
    Bits:  1    MSIMSKSET(rw) - MSI Mask Set: Mask for MSI Mask Set Status.
    Bits:  0    MSIMSKCL(rw) - MSI Mask Cleared: Mask for MSI Mask Cleared Status.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg 0x00000d04
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_R31(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_R31_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_R9 BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_NFTSTOM BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_R4(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_R4_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_MSIXMSKSET BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_MSIXMSKCL BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_MSIMSKSET BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_i_local_intrpt_mask_2_reg_MSIMSKCL BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_1 -
    Bits: 31    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIMSKCLST(w1c) - PF3 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIMSKCLST(w1c) - PF2 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIMSKCLST(w1c) - PF1 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIMSKCLST(w1c) - PF0 MSI Mask Cleared Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1 0x00000d10
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF27MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF26MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF25MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF24MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF23MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF22MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF21MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF20MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF19MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF18MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF17MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF16MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF15MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF14MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF13MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF12MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF11MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF10MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF9MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF8MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF7MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF6MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF5MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF4MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF3MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF2MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF1MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_VF0MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_PF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_PF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_PF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_1_PF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_1 -
    Bits: 31    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIMSKCLST(w1c) - PF3 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIMSKCLST(w1c) - PF2 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIMSKCLST(w1c) - PF1 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIMSKCLST(w1c) - PF0 MSI Mask Set Status: Each PF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in PF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1 0x00000d14
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF27MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF26MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF25MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF24MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF23MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF22MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF21MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF20MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF19MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF18MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF17MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF16MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF15MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF14MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF13MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF12MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF11MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF10MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF9MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF8MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF7MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF6MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF5MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF4MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF3MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF2MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF1MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_VF0MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_PF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_PF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_PF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_1_PF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_1 -
    Bits: 31    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIXMSKCLST(w1c) - PF3 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIXMSKCLST(w1c) - PF2 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIXMSKCLST(w1c) - PF1 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIXMSKCLST(w1c) - PF0 MSIX Function Mask Cleared Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1 0x00000d18
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF27MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF26MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF25MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF24MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF23MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF22MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF21MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF20MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF19MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF18MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF17MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF16MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF15MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF14MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF13MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF12MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF11MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF10MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF9MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF8MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF7MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF6MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF5MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF4MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF3MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF2MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF1MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_VF0MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_PF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_PF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_PF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_1_PF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_1 -
    Bits: 31    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    PF3MSIXMSKCLST(w1c) - PF3 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    PF2MSIXMSKCLST(w1c) - PF2 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    PF1MSIXMSKCLST(w1c) - PF1 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    PF0MSIXMSKCLST(w1c) - PF0 MSIX Function Mask Set Status: Each PF has a 1-bit MSIX Function Mask. This status bit is set when the PF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1 0x00000d1c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF27MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF26MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF25MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF24MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF23MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF22MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF21MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF20MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF19MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF18MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF17MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF16MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF15MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF14MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF13MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF12MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF11MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF10MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF9MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF8MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF7MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF6MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF5MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF4MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF3MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF2MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF1MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_VF0MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_PF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_PF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_PF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_1_PF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_2 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2 0x00000d20
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_2_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_2 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2 0x00000d24
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_2_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_2 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2 0x00000d28
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_2_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_2 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2 0x00000d2c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_2_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_cleared_status_3 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Cleared Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3 0x00000d30
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_cleared_status_3_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msi_mask_set_status_3 -
    Bits: 31    VF31MSIMSKCLST(w1c) - VF31 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF31 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIMSKCLST(w1c) - VF30 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF30 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIMSKCLST(w1c) - VF29 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF29 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIMSKCLST(w1c) - VF28 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF28 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIMSKCLST(w1c) - VF27 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF27 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIMSKCLST(w1c) - VF26 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF26 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIMSKCLST(w1c) - VF25 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF25 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIMSKCLST(w1c) - VF24 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF24 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIMSKCLST(w1c) - VF23 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF23 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIMSKCLST(w1c) - VF22 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF22 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIMSKCLST(w1c) - VF21 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF21 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIMSKCLST(w1c) - VF20 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF20 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIMSKCLST(w1c) - VF19 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF19 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIMSKCLST(w1c) - VF18 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF18 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIMSKCLST(w1c) - VF17 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF17 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIMSKCLST(w1c) - VF16 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF16 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIMSKCLST(w1c) - VF15 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF15 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIMSKCLST(w1c) - VF14 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF14 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIMSKCLST(w1c) - VF13 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF13 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIMSKCLST(w1c) - VF12 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF12 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIMSKCLST(w1c) - VF11 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF11 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIMSKCLST(w1c) - VF10 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF10 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIMSKCLST(w1c) - VF9 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF9 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIMSKCLST(w1c) - VF8 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF8 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIMSKCLST(w1c) - VF7 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF7 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIMSKCLST(w1c) - VF6 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF6 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIMSKCLST(w1c) - VF5 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF5 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIMSKCLST(w1c) - VF4 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF4 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIMSKCLST(w1c) - VF3 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF3 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIMSKCLST(w1c) - VF2 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF2 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIMSKCLST(w1c) - VF1 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF1 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIMSKCLST(w1c) - VF0 MSI Mask Set Status: Each VF has a 32-bit MSI Mask. This status bit is set when any of the 32-bits in VF0 MSI Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSI Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3 0x00000d34
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF31MSIMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF30MSIMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF29MSIMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF28MSIMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF27MSIMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF26MSIMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF25MSIMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF24MSIMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF23MSIMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF22MSIMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF21MSIMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF20MSIMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF19MSIMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF18MSIMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF17MSIMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF16MSIMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF15MSIMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF14MSIMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF13MSIMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF12MSIMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF11MSIMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF10MSIMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF9MSIMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF8MSIMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF7MSIMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF6MSIMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF5MSIMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF4MSIMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF3MSIMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF2MSIMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF1MSIMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msi_mask_set_status_3_VF0MSIMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_cleared_status_3 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Cleared Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 1 to 0 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3 0x00000d38
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_cleared_status_3_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_msix_function_mask_set_status_3 -
    Bits: 31    VF31MSIXMSKCLST(w1c) - VF31 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF31 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 30    VF30MSIXMSKCLST(w1c) - VF30 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF30 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 29    VF29MSIXMSKCLST(w1c) - VF29 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF29 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 28    VF28MSIXMSKCLST(w1c) - VF28 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF28 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 27    VF27MSIXMSKCLST(w1c) - VF27 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF27 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 26    VF26MSIXMSKCLST(w1c) - VF26 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF26 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 25    VF25MSIXMSKCLST(w1c) - VF25 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF25 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 24    VF24MSIXMSKCLST(w1c) - VF24 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF24 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 23    VF23MSIXMSKCLST(w1c) - VF23 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF23 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 22    VF22MSIXMSKCLST(w1c) - VF22 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF22 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 21    VF21MSIXMSKCLST(w1c) - VF21 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF21 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 20    VF20MSIXMSKCLST(w1c) - VF20 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF20 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 19    VF19MSIXMSKCLST(w1c) - VF19 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF19 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 18    VF18MSIXMSKCLST(w1c) - VF18 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF18 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 17    VF17MSIXMSKCLST(w1c) - VF17 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF17 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 16    VF16MSIXMSKCLST(w1c) - VF16 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF16 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 15    VF15MSIXMSKCLST(w1c) - VF15 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF15 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 14    VF14MSIXMSKCLST(w1c) - VF14 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF14 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 13    VF13MSIXMSKCLST(w1c) - VF13 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF13 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 12    VF12MSIXMSKCLST(w1c) - VF12 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF12 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 11    VF11MSIXMSKCLST(w1c) - VF11 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF11 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits: 10    VF10MSIXMSKCLST(w1c) - VF10 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF10 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  9    VF9MSIXMSKCLST(w1c) - VF9 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF9 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  8    VF8MSIXMSKCLST(w1c) - VF8 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF8 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  7    VF7MSIXMSKCLST(w1c) - VF7 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF7 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  6    VF6MSIXMSKCLST(w1c) - VF6 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF6 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  5    VF5MSIXMSKCLST(w1c) - VF5 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF5 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  4    VF4MSIXMSKCLST(w1c) - VF4 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF4 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  3    VF3MSIXMSKCLST(w1c) - VF3 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF3 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  2    VF2MSIXMSKCLST(w1c) - VF2 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF2 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  1    VF1MSIXMSKCLST(w1c) - VF1 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF1 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
    Bits:  0    VF0MSIXMSKCLST(w1c) - VF0 MSIX Function Mask Set Status: Each VF has a 1-bit MSIX Function Mask. This status bit is set when the VF0 MSIX Function Mask is programmed or configured from 0 to 1 by Local Firmware Or Host SW. This bit is set only when the MSIX Function Mask Change Enhanced Interrupt Enable bit is set by the User in debug_mux_control_2_reg. When this status bit is set, the Controller asserts LOCAL_INTERRUPT if not masked in local_intrpt_mask_2_reg . Firmware has to clear this bit in order to deassert LOCAL_INTERRUPT.
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3 0x00000d3c
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF31MSIXMSKCLST BIT(31)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF30MSIXMSKCLST BIT(30)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF29MSIXMSKCLST BIT(29)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF28MSIXMSKCLST BIT(28)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF27MSIXMSKCLST BIT(27)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF26MSIXMSKCLST BIT(26)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF25MSIXMSKCLST BIT(25)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF24MSIXMSKCLST BIT(24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF23MSIXMSKCLST BIT(23)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF22MSIXMSKCLST BIT(22)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF21MSIXMSKCLST BIT(21)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF20MSIXMSKCLST BIT(20)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF19MSIXMSKCLST BIT(19)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF18MSIXMSKCLST BIT(18)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF17MSIXMSKCLST BIT(17)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF16MSIXMSKCLST BIT(16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF15MSIXMSKCLST BIT(15)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF14MSIXMSKCLST BIT(14)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF13MSIXMSKCLST BIT(13)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF12MSIXMSKCLST BIT(12)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF11MSIXMSKCLST BIT(11)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF10MSIXMSKCLST BIT(10)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF9MSIXMSKCLST BIT(9)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF8MSIXMSKCLST BIT(8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF7MSIXMSKCLST BIT(7)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF6MSIXMSKCLST BIT(6)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF5MSIXMSKCLST BIT(5)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF4MSIXMSKCLST BIT(4)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF3MSIXMSKCLST BIT(3)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF2MSIXMSKCLST BIT(2)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF1MSIXMSKCLST BIT(1)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_msix_function_mask_set_status_3_VF0MSIXMSKCLST BIT(0)
/*----------------------------------------------------------------
  Register: i_regf_lm_pcie_base_rx_elec_idle_filter_control -
    Bits: 31:24 GFLCP(rw) - RX Electrical Idle Glitch Filter Count PM Clocks: This controls the glitch filter on PM Clock domain. This counter indicates the number of PM Clocks the glitch will be filtered out. The total delay of the glitch filter is calculated as (PM Clock Period * Number of PM Clocks) this delay should be same or close enough for both Core Clock(GFLCC) and PM Clock(GFLCP)
    Bits: 23:16 GFLCC(rw) - RX Electrical Idle Glitch Filter Count CORE Clocks: This controls the glitch filter on CORE Clock domain. This counter indicates the number of CORE Clocks the glitch will be filtered out. Thetotal delay of the glitch filter is calculated as (CORE Clock Period * Number of CORE Clocks) thisdelay should be same or close enough for both CORE Clock(GFLCC) and PM Clock(GFLCP)
    Bits: 15:8  RSVGFLD(ro) - Reserved: Reserved
    Bits:  7:0  GFLD(rw) - RX Electrical Idle Glitch Filter Disable: By default controller enables glitch filter on all lanes. Setting this bit to one makes the controller to disable the glitch filter on that corresponding lanes in which the bit is set. When all bits are set to one the Glitch filter is completely bypassed, When any bit is zero glitch filter is enabled, and de-glitching is done only on the lanes that are set to zero
*/
#define NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control 0x00000da4
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLCP(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLCP_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_RSVGFLD(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_RSVGFLD_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLD(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_LM_i_regf_lm_pcie_base_rx_elec_idle_filter_control_GFLD_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_vendor_id_device_id -
    Bits: 31:16 DID(ro) - Device ID: Device ID assigned by the manufacturer of the device. On power-up, the core sets it to the value defined in the RTL file reg_defaults.h. This field can be written independently for each Function from the local management bus.
    Bits: 15:0  VID(ro) - Vendor ID: A read to this register returns FFFFh for VFs
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_vendor_id_device_id 0x00000000
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_vendor_id_device_id_DID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_vendor_id_device_id_DID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_vendor_id_device_id_VID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_vendor_id_device_id_VID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_command_status -
    Bits: 31    DPE(w1c) - Detected Parity Error: This bit is set when the core has received a Poisoned TLP targeted at this VF. The Parity Error Response enable bit (bit 6) in the PCI Command Register of the associated PF has no effect on the setting of this bit. STICKY.
    Bits: 30    SSE(w1c) - Signaled System Error: If the SERR enable bit in the PCI Command Register of the associated Physical Function is 1, this bit is set when this VF has sent out a fatal or non-fatal error message on the link to the Root Complex. If the SERR enable bit is 0, this bit remains 0. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 29    RMA(w1c) - Received Master Abort: This bit is set when this VF has received a completion from the link with the Unsupported Request status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 28    RTA(w1c) - Received Target Abort: This bit is set when this Virtual Function has received a completion from the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 27    STA(w1c) - Signaled Target Abort: This bit is set when the core has sent a completion from this VF to the link with the Completer Abort status. This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 26:25 R5(ro) - Reserved: Reserved
    Bits: 24    MDPE(w1c) - Master Data Parity Error: When the Parity Error Response enable bit in the PCI Command Register of the associated Physical Function is set, the core sets this bit when it detects the following error conditions: (i) The core receives a Poisoned Completion TLP from the link in response to a request from this VF. (ii) The core sends out a poisoned write request on the link from this VF. (This bit remains 0 when the Parity Error Response enable bit in the PCI Command Register of the associated Physical Function is 0). This field can also be cleared from the local management bus by writing a 1 into this bit position. STICKY.
    Bits: 23:21 R4(ro) - Reserved: Reserved
    Bits: 20    CL(ro) - Capabilities List: Indicates the presence of PCI Extended Capabilities registers. This bit is hardwired to 1.
    Bits: 19    IS(ro) - Interrupt Status: Reserved
    Bits: 18:11 R3(ro) - Reserved: Reserved
    Bits: 10    IMD(ro) - INTx Message Disable: Reserved
    Bits:  9    R2(ro) - Reserved: Reserved
    Bits:  8    SE(ro) - SERR Enable: Reserved
    Bits:  7    R1(ro) - Reserved: Reserved
    Bits:  6    PERE(ro) - Parity Error Response Enable: Reserved
    Bits:  5:3  R0(ro) - Reserved: Reserved
    Bits:  2    BME(rw) - Bus-Master Enable: Enables the device to issue memory requests from this Function. This field can be written from the local management bus.
    Bits:  1    MSE(ro) - Mem-Space Enable: Reserved
    Bits:  0    IOSE(ro) - IO-Space Enable: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status     0x00000004
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_DPE BIT(31)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_SSE BIT(30)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_RMA BIT(29)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_RTA BIT(28)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_STA BIT(27)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R5(_x) (((_x) & 0x3) << 25)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R5_of(_x) (((_x) >> 25) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_MDPE BIT(24)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R4(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R4_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_CL BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_IS BIT(19)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R3(_x) (((_x) & 0xff) << 11)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R3_of(_x) (((_x) >> 11) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_IMD BIT(10)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R2 BIT(9)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_SE BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R1 BIT(7)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_PERE BIT(6)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R0(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_R0_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_BME BIT(2)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_MSE BIT(1)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_command_status_IOSE BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_revision_id_class_code -
    Bits: 31:24 CC(ro) - Class Code: Identifies the function of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 23:16 SCC(ro) - Sub-Class Code: Identifies a sub-category within the selected function. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 15:8  PIB(ro) - Programming Interface Byte: Identifies the register set layout of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits:  7:0  RID(ro) - Revision ID: Assigned by the manufacturer of the device to identify the revision RO Setting of this field Denali Cadence-PCIe Core User Guide, PMC-Sierra Version 3.4 202 number of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code 0x00000008
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_CC(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_CC_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_SCC(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_SCC_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_PIB(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_PIB_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_RID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_revision_id_class_code_RID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bist_header_latency_cache_line -
    Bits: 31:24 BR(ro) - BIST Register: Reserved
    Bits: 23    DT(ro) - Device Type: Identifies whether the device supports a single Function or multiple Functions. This bit is read as 0 when only Function 0 has been enabled in the Physical Function Configuration Register (in the local management block). Reserved for VFs
    Bits: 22:16 HT(ro) - Header Type: Reserved
    Bits: 15:8  LT(ro) - Latency Timer: Reserved
    Bits:  7:0  CLS(ro) - Cache Line Size: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line 0x0000000c
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_BR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_BR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_DT BIT(23)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_HT(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_HT_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_LT(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_LT_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_CLS(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bist_header_latency_cache_line_CLS_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_0_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_0_reg          0x00000010
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_0_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_0_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_1_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_1_reg          0x00000014
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_1_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_1_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_2_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_2_reg          0x00000018
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_2_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_2_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_3_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_3_reg          0x0000001c
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_3_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_3_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_4_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_4_reg          0x00000020
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_4_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_4_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_bar_5_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_5_reg          0x00000024
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_5_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_bar_5_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_rsvd_0A -
  Register: i_vf_pcie_base_rsvd_0E -
  Register: i_vf_MSI_cap_struct_rsvd_02A_02B_[2] -
  Register: i_vf_MSIX_cap_struct_rsvd_02F -
  Register: i_vf_PCIE_cap_struct_rsvd_034_038_[5] -
  Register: i_vf_PCIE_cap_struct_rsvd_03A_03F_[6] -
  Register: i_vf_AER_cap_struct_rsvd_04B_04D_[3] -
  Register: i_vf_ARI_cap_struct_rsvd_052_09C_[75] -
    Bits: 31:0  RSVD(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_rsvd_0A              0x00000028
#define NFP3800_PCIEX_VF_i_vf_pcie_base_rsvd_0E              0x00000038
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_rsvd_02A_02B(_x) (0x000000a8 + (0x4 * ((_x) & 0x1)))
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_rsvd_02F       0x000000bc
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_rsvd_034_038(_x) (0x000000d0 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_rsvd_03A_03F(_x) (0x000000e8 + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_rsvd_04B_04D(_x) (0x0000012c + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_rsvd_052_09C(_x) (0x00000148 + (0x4 * ((_x) & 0x7f)))
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_VF_generic_reserved_reg_vf_cl_RSVD(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_VF_generic_reserved_reg_vf_cl_RSVD_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i -
    Bits: 31:16 SID(ro) - Subsystem ID: Specifies the Subsystem ID assigned by the manufacturer of the device. This field reflects the setting of the corresponding register in the configuration space of the associated Physical Function.
    Bits: 15:0  SVID(ro) - Subsystem Vendor ID: Specifies the Subsystem Vendor ID assigned by the PCI SIG to the manufacturer of the device.This field when read reflects the Subsystem Vendor ID of the Physical Function the VF is associated with.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i 0x0000002c
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i_SID(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i_SID_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i_SVID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_subsystem_vendor_id_subsystem_i_SVID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_expansn_rom_bar_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_expansn_rom_bar_reg 0x00000030
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_expansn_rom_bar_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_expansn_rom_bar_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_capabilities_pointer -
    Bits: 31:8  R6(ro) - Reserved: Reserved
    Bits:  7:0  CP(ro) - Capabilities Pointer: Contains pointer to the first PCI Capability Structure. This field is set by default to point to the Power Management Capability Structure. It can be modified by writing to VF 0 from the local management bus, and the setting is common across all VFs.
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_capabilities_pointer 0x00000034
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_capabilities_pointer_R6(_x) (((_x) & 0xffffff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_capabilities_pointer_R6_of(_x) (((_x) >> 8) & 0xffffff)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_capabilities_pointer_CP(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_capabilities_pointer_CP_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_pcie_base_i_intrpt_line_intrpt_pin_reg -
    Bits: 31:0  NI(ro) - Not Implemented:
*/
#define NFP3800_PCIEX_VF_i_vf_pcie_base_i_intrpt_line_intrpt_pin_reg 0x0000003c
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_intrpt_line_intrpt_pin_reg_NI(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_pcie_base_i_intrpt_line_intrpt_pin_reg_NI_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap -
    Bits: 31    PSDCS(ro) - PME Support for D3(cold) State: Indicates whether the Function is capable of sending PME messages when in the D3cold state. Because the device does not have aux power, this bit is hardwired to 0.
    Bits: 30    PSDHS(rw) - PME Support for D3(hot) State: Indicates whether the Function is capable of sending PME messages when in the D3hot state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 29    PSD2S(ro) - PME Support for D2 State: Indicates whether the Function is capable of sending PME messages when in the D2 state. This bit is hardwired to 0 because D2 state is not supported.
    Bits: 28    PSD1S(rw) - PME Support for D1 State: Indicates whether the Function is capable of sending PME messages when in the D1 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 27    PSD0S(rw) - PME Support for D0 State: Indicates whether the Function is capable of sending PME messages when in the D0 state. This bit is set to 1 by default, but can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 26    D2S(ro) - D2 Support: Set if the Function supports the D2 power state. Currently hardwired to 0.
    Bits: 25    D1S(rw) - D1 Support: Set if the Function supports the D1 power state. This bit can be modified from the local management bus by writing into Function 0. All other Functions assume the value set in Function 0s Power Management Capabilities Register.
    Bits: 24:22 MCRAPS(ro) - Max Current Required from Aux Power Supply: Specifies the maximum current drawn by the device from the aux power source in the D3cold state. This field is not implemented in devices not supporting PME notification when in the D3cold state, and is therefore hardwired to 0.
    Bits: 21    DSI(ro) - Device Specific Initialization Bit: This bit, when set, indicates that the device requires additional configuration steps beyond setting up its PCI configuration space, to bring it to the D0active state from the D0uninitialized state. This bit is hardwired to 0.
    Bits: 20    R0(ro) - Reserved: Reserved
    Bits: 19    PC(ro) - PME Clock: Not applicable to PCI Express. This bit is hardwired to 0.
    Bits: 18:16 VID(ro) - Version ID: Indicates the version of the PCI Bus Power Management Specifications that the Function implements. This field is set by default to 011 (Version 1.2). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Contains pointer to the next PCI Capability Structure. The core sets it to the value defined in the RTL file reg_defaults.h. By default, this points to the MSI Capability Structure. This field can be re-written independently for each Function from the local management bus.
    Bits:  7:0  CID(ro) - Capability ID: Identifies that the capability structure is for Power Management. This field is set by default to 01 hex. It can be re-written independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap 0x00000088
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSDCS BIT(31)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSDHS BIT(30)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD2S BIT(29)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD1S BIT(28)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PSD0S BIT(27)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_D2S BIT(26)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_D1S BIT(25)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_MCRAPS(_x) (((_x) & 0x7) << 22)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_MCRAPS_of(_x) (((_x) >> 22) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_DSI BIT(21)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_R0 BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_PC BIT(19)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_VID(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_VID_of(_x) (((_x) >> 16) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_cap_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep -
    Bits: 31:24 DR(ro) - Data Register: This optional register is not implemented in the Cadence PCIe core. This field is hardwired to 0.
    Bits: 23:16 R1(ro) - Reserved: Reserved
    Bits: 15    PMES(rw) - PME Status: When PME notification is enabled, writing a 1 into this bit position from the local management bus sets this bit and causes the core to send a PME message from the associated Function. When the Root Complex processes this message, it will turn off this bit by writing a 1 into this bit position though a Config Write. This bit can be set or cleared from the local management bus, by writing a 1 or 0, respectively. It can only be cleared from the configuration path (by writing a 1).
    Bits: 14:9  R2(ro) - Reserved: Reserved
    Bits:  8    PE(rw) - PME Enable: Setting this bit enables the notification of PME events from the associated Function. This bit can be set also by writing into this register from the local management bus.
    Bits:  7:4  R3(ro) - Reserved: Reserved
    Bits:  3    NSR(rw) - No Soft Reset: When this bit is set to 1, the Function will maintain all its state in the PM state D3hot. The software is not required to re-initialize the Function registers on the transition back to D0. This bit is set to 1 by default, but can be modified independently for each VF from the local management bus.
    Bits:  2    R4(ro) - Reserved: Reserved
    Bits:  1:0  PS(rw) - Power State: Indicates the power state this Function is currently in. This field can be read by the software to monitor the current power state, or can be written to cause a transition to a new state. The valid settings are 00 (state D0), 01 (state D1) and 11 (state D3hot). The software should not write any other value into this field. This field can also be written from the local management bus independently for each VF Function.
*/
#define NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep 0x0000008c
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_DR(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_DR_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R1(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R1_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PMES BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R2(_x) (((_x) & 0x3f) << 9)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R2_of(_x) (((_x) >> 9) & 0x3f)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PE BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R3(_x) (((_x) & 0xf) << 4)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R3_of(_x) (((_x) >> 4) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_NSR BIT(3)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_R4 BIT(2)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PS(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_VF_i_vf_power_mgmt_cap_struct_i_pwr_mgmt_ctrl_stat_rep_PS_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_ctrl_reg -
    Bits: 31:25 R0(ro) - Reserved: Reserved
    Bits: 24    MC(rw) - MSI masking capable: can be modified using localmanagement interface
    Bits: 23    AC64(rw) - 64-Bit Address Capable: Set to 1 to indicate that the device is capable of generating 64-bit addresses for MSI messages.
    Bits: 22:20 MME(rw) - Multiple Message Enable: Encodes the number of distinct messages that the core is programmed to generate for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). This setting must be based on the number of interrupt inputs of the core that are actually used by this Function. This field can be written from the local management bus.
    Bits: 19:17 MMC(rw) - Multiple Message Capable: Encodes the number of distinct messages that the core is capable of generating for this Function (000 = 1, 001 = 2, 010 = 4, 011 = 8, 100 = 16, 101 = 32). Thus, this field defines the number of the interrupt vectors for this Function. The core allows up to 32 distinct messages, but the setting of this field must be based on the number of interrupt inputs of the core that are actually used by the client. For example, if the client logic uses 8 of the 32 distinct MSI interrupt inputs of the core for this Function, then the value of this field must be set to 011. This field can be written from the local management bus. Please see the `define den_db_VF_MSI_MULTIPLE_MSG_CAPABLE for default value in the reg_defaults.v files.
    Bits: 16    ME(rw) - MSI Enable: Set by the configuration program to enable the MSI feature. This field can also be written from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Pointer to the next PCI Capability Structure. The value read from this read-only field is the corresponding pointer in the MSI Capability Structure of the Physical Function this VF is attached to. The setting is common across all the Virtual Functions.
    Bits:  7:0  CID(ro) - Capability ID: Specifies that the capability structure is for MSI. Hardwired to 05 hex.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg  0x00000090
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_R0(_x) (((_x) & 0x7f) << 25)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_R0_of(_x) (((_x) >> 25) & 0x7f)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_MC BIT(24)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_AC64 BIT(23)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_MME(_x) (((_x) & 0x7) << 20)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_MME_of(_x) (((_x) >> 20) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_MMC(_x) (((_x) & 0x7) << 17)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_MMC_of(_x) (((_x) >> 17) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_ME BIT(16)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_ctrl_reg_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_low_addr -
    Bits: 31:2  MAL(rw) - Message Address Low: Lower bits of the address to be used in MSI messages. This field can also be written from the local management bus.
    Bits:  1:0  R1(ro) - Reserved: The two lower bits of the address are hardwired to 0 to align the address on a double-word boundary.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_low_addr 0x00000094
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_low_addr_MAL(_x) (((_x) & 0x3fffffff) << 2)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_low_addr_MAL_of(_x) (((_x) >> 2) & 0x3fffffff)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_low_addr_R1(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_low_addr_R1_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_hi_addr -
    Bits: 31:0  MAH(rw) - Message Address High: Contains bits 63:32 of the 64-bit address to be used in MSI Messages. A value of 0 specifies that 32-bit addresses are to be used in the messages. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_hi_addr 0x00000098
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_hi_addr_MAH(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_hi_addr_MAH_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_msg_data -
    Bits: 31:16 R2(ro) - Reserved: Hardwired to 0
    Bits: 15:0  MD(rw) - Message Data: Message data to be used for this Function. This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_data  0x0000009c
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_data_R2(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_data_R2_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_data_MD(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_msg_data_MD_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_mask -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MM(rw) - MSI Mask: Mask bits for MSI interrupts. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid mask bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Mask field also changes correspondingly
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_mask      0x000000a0
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_mask_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_mask_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_mask_MM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_MSI_cap_struct_i_msi_pending_bits -
    Bits: 31:1  R0(ro) - Reserved: Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of this field also changes correspondingly
    Bits:  0    MP(rw) - MSI Pending Bits: Pending bits for MSI interrupts. This register contains the MSI pending interrupt bits, one for each of the interrupt levels. This field can be written from the local management bus. The Multiple Message Capable field of the MSI Control Register specifies the number of distinct interrupts for the Function, which determines the number of valid pending bits. Please note that if the Multiple Message Capable field is changed from the local management bus, then the width of the MSI Pending Bits field also changes correspondingly
*/
#define NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_pending_bits 0x000000a4
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_pending_bits_R0(_x) (((_x) & 0x7fffffff) << 1)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_pending_bits_R0_of(_x) (((_x) >> 1) & 0x7fffffff)
#define   NFP3800_PCIEX_VF_i_vf_MSI_cap_struct_i_msi_pending_bits_MP BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_ctrl -
    Bits: 31    MSIXE(rw) - MSI-X Enable: Set by the configuration program to enable the MSI-X feature. This field can also be written from the local management bus.
    Bits: 30    FM(rw) - Function Mask: This bit serves as a global mask to all the interrupt conditions associated with this Function. When this bit is set, the core will not send out MSI messages from this Function. This field can also be written from the local management bus.
    Bits: 29:27 R0(ro) - Reserved: Reserved
    Bits: 26:16 MSIXTS(rw) - MSI-X Table Size: Specifies the size of the MSI-X Table, that is, the number of interrupt vectors defined for the Function. The programmed value is 1 minus the size of the table (that is, this field is set to 0 if the table size is 1.). It can be re-written independently for each Function from the local management bus.
    Bits: 15:8  CP(ro) - Capabilities Pointer: Contains a pointer to the next PCI Capability Structure. The value read from this read-only field is the corresponding pointer in the MSI-X Capability Structure of the Physical Function this VF is attached to.
    Bits:  7:0  CID(ro) - Capability ID: Identifies that the capability structure is for MSI-X. This field is set by default to 11 hex. It can be rewritten independently for each Function from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl    0x000000b0
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_MSIXE BIT(31)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_FM BIT(30)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_R0(_x) (((_x) & 0x7) << 27)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_R0_of(_x) (((_x) >> 27) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_MSIXTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_MSIXTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_CP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_CP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_ctrl_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_tbl_offset -
    Bits: 31:3  TO(rw) - Table Offset: Offset of the memory address where the MSI-X Table is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the MSI-X Table is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5).
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_tbl_offset 0x000000b4
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_tbl_offset_TO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_tbl_offset_TO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_tbl_offset_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_tbl_offset_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_MSIX_cap_struct_i_msix_pending_intrpt -
    Bits: 31:3  PO(rw) - PBA Offset: Offset of the memory address where the PBA is located, relative to the selected BAR. The three least significant bits of the address are omitted, as the addresses are QWORD aligned.
    Bits:  2:0  BARI(rw) - BAR Indicator Register: Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.Identifies the BAR corresponding to the memory address range where the PBA Structure is located (000 = BAR 0, 001 = BAR 1, ... , 101 = BAR 5). The value programmed must be the same as the BAR Indicator configured in the MSI-X Table Offset Register.
*/
#define NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_pending_intrpt 0x000000b8
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_pending_intrpt_PO(_x) (((_x) & 0x1fffffff) << 3)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_pending_intrpt_PO_of(_x) (((_x) >> 3) & 0x1fffffff)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_pending_intrpt_BARI(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_i_vf_MSIX_cap_struct_i_msix_pending_intrpt_BARI_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_cap_list -
    Bits: 31    R0(ro) - Reserved: Reserved
    Bits: 30    TRS(ro) - TCS Routing Supported: When set to 1, this bit indicates that the device supports routing of Trusted Configuration Requests. Not valid for Endpoints. Hardwired to 0.
    Bits: 29:25 IMN(ro) - Interrupt Message Number: Identifies the MSI or MSI-X interrupt vector for the interrupt message generated corresponding to the status bits in the Slot Status Register, Root Status Register, or this capability structure. This field must be defined based on the chosen interrupt mode - MSI or MSI-X. This field is hardwired to 0.
    Bits: 24    SS(ro) - Slot Status: Set to 1 when the link connected to a slot. Hardwired to 0.
    Bits: 23:20 DT(ro) - Device Type: Indicates the type of device implementing this Function. This field is hardwired to 0 in the EP mode.
    Bits: 19:16 CV(ro) - Capability Version: Identifies the version number of the capability structure. This field is set to 2 by default to indicate that the Controller is compatible to PCI Express Base Specification Revision 3.0.
    Bits: 15:8  NCP(ro) - Next Capability Pointer: Points to the next PCI capability structure. Set to 0 because this is the last capability structure.
    Bits:  7:0  CID(ro) - Capability ID: Specifies Capability ID assigned by PCI SIG for this structure. This field is hardwired to 10 hex.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list 0x000000c0
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_R0 BIT(31)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_TRS BIT(30)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_IMN(_x) (((_x) & 0x1f) << 25)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_IMN_of(_x) (((_x) >> 25) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_SS BIT(24)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_DT(_x) (((_x) & 0xf) << 20)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_DT_of(_x) (((_x) >> 20) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_NCP(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_NCP_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_CID(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_cap_list_CID_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_cap -
    Bits: 31:29 R3(ro) - Reserved: Reserved
    Bits: 28    FLRC(ro) - FLR Capable: Set when device has Function-Level Reset capability. Hardwired to 1.
    Bits: 27:26 CPLS(ro) - Captured Power Limit Scale: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 25:18 CSPLV(ro) - Captured Slot Power Limit Value: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 17:16 R2(ro) - Reserved: Reserved
    Bits: 15    RBER(ro) - Role-Based Error Reporting: This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits: 14:12 R1(ro) - Reserved: Reserved
    Bits: 11:9  AL1SL(ro) - Acceptable L1 Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L1 to L0. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  8:6  AL0SL(ro) - Acceptable L0S Latency: Specifies acceptable latency that the Endpoint can tolerate while transitioning from L0S to L0. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  5    ETFS(ro) - Extended Tag Field Supported: Set when device allows the tag field to be extended from 5 to 8 bits. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0.
    Bits:  4:3  PFS(ro) - Phantom Functions Supported: This field is used to extend the tag field by combining unused Function bits with the tag bits. This field is hardwired to 00 to disable this feature.
    Bits:  2:0  MPS(ro) - Max Payload Size: Specifies maximum payload size supported by the device. This field reflects the setting of the corresponding field in the PCIe Device Capability Register of PF 0
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap 0x000000c4
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R3(_x) (((_x) & 0x7) << 29)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R3_of(_x) (((_x) >> 29) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_FLRC BIT(28)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_CPLS(_x) (((_x) & 0x3) << 26)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_CPLS_of(_x) (((_x) >> 26) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_CSPLV(_x) (((_x) & 0xff) << 18)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_CSPLV_of(_x) (((_x) >> 18) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R2(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R2_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_RBER BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R1(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_R1_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_AL1SL(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_AL1SL_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_AL0SL(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_AL0SL_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_ETFS BIT(5)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_PFS(_x) (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_PFS_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_MPS(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_MPS_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status -
    Bits: 31:22 R4(ro) - Reserved: Reserved
    Bits: 21    TP(ro) - Transaction Pending: Indicates if any of the Non-Posted requests issued by the VF are still pending.
    Bits: 20    APD(ro) - Aux Power Detected: Reserved
    Bits: 19    URD(w1c) - Unsupported Request Detected: Set to 1 by the core when it receives an unsupported request, regardless of whether its reporting is enabled or not.
    Bits: 18    FED(w1c) - Fatal Error Detected: Set to 1 by the core when it detects a fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 17    NFER(w1c) - Non-Fatal Error Detected: Set to 1 by the core when it detects a non-fatal error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked.
    Bits: 16    CED(w1c) - Correctable Error Detected: Set to 1 by the core when it detects a correctable error, regardless of whether error reporting is enabled or not, and regardless of whether the error is masked
    Bits: 15    FLR(rw) - Function-Level Reset: Writing a 1 into this bit position generated a Function-Level Reset for the selected VF. This bit reads as 0.
    Bits: 14:12 MRRS(ro) - Max Read Request Size: Reserved
    Bits: 11    EBS(ro) - Enable No Snoop: Reserved
    Bits: 10    EAP(ro) - Enable Aux Power: Reserved
    Bits:  9    EPF(ro) - Enable Phantom Functions: Reserved
    Bits:  8    ETFE(ro) - Extended Tag Field Enable: Reserved
    Bits:  7:5  MPS(ro) - Max Payload Size: Reserved
    Bits:  4    ERO(ro) - Enable Relaxed Ordering: Reserved
    Bits:  3    EURR(ro) - Enable Unsupported Request Reporting: Reserved
    Bits:  2    EFER(ro) - Enable Fatal Error Reporting: Reserved
    Bits:  1    ENFER(ro) - Enable Non-Fatal Error Reporting: Reserved
    Bits:  0    ECER(ro) - Enable Correctable Error Reporting: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status 0x000000c8
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_R4(_x) (((_x) & 0x3ff) << 22)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_R4_of(_x) (((_x) >> 22) & 0x3ff)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_TP BIT(21)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_APD BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_URD BIT(19)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_FED BIT(18)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_NFER BIT(17)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_CED BIT(16)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_FLR BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_MRRS(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_MRRS_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_EBS BIT(11)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_EAP BIT(10)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_EPF BIT(9)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_ETFE BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_MPS(_x) (((_x) & 0x7) << 5)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_MPS_of(_x) (((_x) >> 5) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_ERO BIT(4)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_EURR BIT(3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_EFER BIT(2)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_ENFER BIT(1)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_ctrl_status_ECER BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_link_cap -
    Bits: 31:24 PN(ro) - Port Number: Specifies the port number assigned to the PCI Express link connected to this device.
    Bits: 23    R5(ro) - Reserved: Reserved
    Bits: 22    AOC(ro) - ASPM Optionality Compliance: Setting this bit indicates that the device supports the ASPM Optionality feature. It can be turned off by writing a 0 to this bit position through the local management bus.
    Bits: 21    LBNC(ro) - Link Bandwidth Notification Capability: A value of 1b indicates support for the Link Bandwidth Notification status and interrupt mechanisms. Reserved for Endpoint.
    Bits: 20    DLLARC(ro) - Data Link Layer Active Reporting Capability: Set to 1 if the device is capable of reporting that the DL Control and Management State Machine has reached the DL_Active state. This bit is hardwired to 0, as this version of the core does not support the feature.
    Bits: 19    SDERC(ro) - Surprise Down Error Reporting Capability: Indicates the capability of the device to report a Surprise Down error condition. This bit is hardwired to 0, as this version of the core does not support the feature.
    Bits: 18    CPM(ro) - Clock Power Management: Indicates that the device supports removal of referenc clocks. It is set by default to the value of the define in reg_defaults.h. It can be re-written independently for each function from the local management bus.
    Bits: 17:15 L1EL(ro) - L1 Exit Latency: Specifies the exit latency from L1 state. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 14:12 L0SEL(ro) - L0S Exit Latency: Specifies the time required for the device to transition from L0S to L0. This parameter is dependent on the Physical Layer implementation. It is set by default to the value define in reg_defaults.h. It can be re-written independently for each Function from the local management bus.
    Bits: 11:10 ASPM(ro) - Active State Power Management: Indicates the level of ASPM support provided by the device. This field can be re-written independently for each Function from the local management bus. When SRIS is enabled in local management register bit, L0s capability is not supported and is forced low.
    Bits:  9:4  MLW(ro) - Maximum Link Width: Indicates the maximum number of lanes supported by the device. This field is hardwired based on the setting of the LANE_COUNT_IN strap input.
    Bits:  3:0  MLS(ro) - Maximum Link Speed: Indicates the maximum speed supported by the link. (2.5 GT/s, 5 GT/s, 8 GT/s per lane). This field is hardwired to 0001 (2.5GT/s) when the strap input PCIE_GENERATION_SEL is set to 0, to 0010 (5 GT/s) when the strap is set to 1, and to 0011 (8 GT/s) when the strap input is set to 10.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap     0x000000cc
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_PN(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_PN_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_R5 BIT(23)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_AOC BIT(22)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_LBNC BIT(21)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_DLLARC BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_SDERC BIT(19)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_CPM BIT(18)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_L1EL(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_L1EL_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_L0SEL(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_L0SEL_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_ASPM(_x) (((_x) & 0x3) << 10)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_ASPM_of(_x) (((_x) >> 10) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_MLW(_x) (((_x) & 0x3f) << 4)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_MLW_of(_x) (((_x) >> 4) & 0x3f)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_MLS(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_link_cap_MLS_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_PCIE_cap_struct_i_pcie_dev_cap_2 -
    Bits: 31:24 R14(ro) - Reserved: Reserved
    Bits: 23:22 MEEP(ro) - Max End-End TLP Prefixes: Indicates the maximum number of End-End TLP Prefixes supported by the Function. The supported values are: 01b 1 End-End TLP Prefix 10b 2 End-End TLP Prefixes
    Bits: 21    EEPS(ro) - End-End TLP Prefix Supported: Indicates whether the Function supports End-End TLP Prefixes. A 1 in this field indicates that the Function supports receiving TLPs containing End-End TLP Prefixes.
    Bits: 20    EXFS(ro) - Extended Format Field Supported: Indicates that the Function supports the 3-bit definition of the Fmt field in the TLP header. This bit is hardwired to 1 for all Physical Functions.
    Bits: 19:18 OPFFS(ro) - OBFF Supported: A 1 in this bit position indicates that the Function supports the Optimized Buffer Flush/Fill (OBFF) capability using message signaling.
    Bits: 15:14 R13(ro) - Reserved: Reserved
    Bits: 13:12 TCS(ro) - TPH Completer Supported: These bits, when set, indicate that the Function is capable of serving as a completer for requests with Transaction Processing Hints (TPH). It can be turned off for all Physical Functions by writing into PF 0. Defined Encodings are: 00b TPH and Extended TPH Completer not supported. 01b TPH Completer supported Extended TPH Completer not supported. 10b Reserved. 11b Both TPH and Extended TPH Completer supported.
    Bits: 11    LMS(ro) - LTR Mechanism Supported: A 1 in this bit position indicates that the Function supports the Latency Tolerance Reporting (LTR) Capability. This bit is set to 1 by default, but can be turned off for all Physical Functions by writing into PF 0.
    Bits: 10    R12(ro) - Reserved: Reserved
    Bits:  9    BAOCS128(ro) - 128-Bit CAS Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for the Compare-and- Swap (CAS) Atomic Operation with 128-bit operands. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  8    BAOCS64(ro) - 64-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 64-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  7    BAOCS32(ro) - 32-Bit Atomic Op Completer Supported: A 1 in this bit position indicates that the Function supports completer capability for 32-bit Atomic Operations. This bit is set to 1 by default, but can be overwritten independently for each Function from the local management bus.
    Bits:  6    OPRS(ro) - OP routing supported: Atomic OP routing supported.
    Bits:  5    AFS(ro) - ARI forwarding support: ARI forwarding supported. This field is hard coded to zero
    Bits:  4    CTDS(ro) - Completion Timeout Disable Supported: A 1 in this field indicates that the associated Function supports the capability to turn off its Completion timeout. This bit is set to 1 by default, but can be re-written independently for each Function from the local management bus.
    Bits:  3:0  CTR(ro) - Completion Timeout Ranges: Specifies the Completion Timeout values supported by the device. This field is set by default to 0010 (10 ms - 250 ms). The actual timeout values are in two programmable local management registers, which allow the timeout settings of the two sub-ranges within Range B to be programmed independently.
*/
#define NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2 0x000000e4
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_R14(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_R14_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_MEEP(_x) (((_x) & 0x3) << 22)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_MEEP_of(_x) (((_x) >> 22) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_EEPS BIT(21)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_EXFS BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_OPFFS(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_OPFFS_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_R13(_x) (((_x) & 0x3) << 14)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_R13_of(_x) (((_x) >> 14) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_TCS(_x) (((_x) & 0x3) << 12)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_TCS_of(_x) (((_x) >> 12) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_LMS BIT(11)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_R12 BIT(10)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS128 BIT(9)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS64 BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_BAOCS32 BIT(7)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_OPRS BIT(6)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_AFS BIT(5)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_CTDS BIT(4)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_CTR(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_i_vf_PCIE_cap_struct_i_pcie_dev_cap_2_CTR_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field reflects the setting of the corresponding field in the AER Enhanced Capability Header Register of PF 0.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the PCI Express AER Extended Capability Structure (0001 hex).
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr 0x00000100
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_AER_enhanced_cap_hdr_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_status -
    Bits: 31:23 R3(ro) - Reserved: Reserved
    Bits: 22    Uncorr_Int_Err_Status(ro) - Uncorrectable Internal Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 21    R2(ro) - Reserved: Reserved
    Bits: 20    URES(w1c) - Unsupported Request Error Status: This bit is set when the core has received a request from the link that it does not support. This error is not Function-specific. This error is considered non-fatal by default. In the special case described in Sections 6.2.3.2.4.1 of the PCI Express Specifications, the error is reported by sending an ERR_COR message. In all other cases, the error is reported by sending an ERR_NONFATAL message. The header of the received request that caused the error is logged in the Shared VF Header Log Registers. STICKY.
    Bits: 19    ECRC_Err_Status(ro) - ECRC Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 18    Malformed_TLP_Status(ro) - Malformed TLP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 17    Rcvr_Overflow_Status(ro) - Receiver Overflow Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 16    UCS(w1c) - Unexpected Completion Status: This bit is set when the core has received an unexpected Completion packet from the link. This error is not Function-specific. STICKY.
    Bits: 15    CAS(w1c) - Completer Abort Status: This bit is set when the core has returned the Completer Abort (CA) status to a request received from the link. This error is Function-specific. The header of the received request that caused the error is logged in the Shared VF Header Log Registers. STICKY.
    Bits: 14    CTS(w1c) - Completion Timeout Status: This bit is set when the completion timer associated with an outstanding request times out. This error is Function-specific. This error is considered non-fatal by default. STICKY.
    Bits: 13    FCPES(ro) - Flow Control Protocol Error Status: This bit is is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 12    PTS(w1c) - Poisoned TLP Status: This bit is set when the core receives a poisoned TLP from the link, targeted at this VF. This error is Function-specific. This error is considered non-fatal by default. The error is reported by sending an ERR_NONFATAL message. The header of the received TLP with error is logged in the Shared VF Header Log Registers associated with the VF. STICKY.
    Bits: 11:5  R1(ro) - Reserved: Reserved
    Bits:  4    DLPER(ro) - Data Link Protocol Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  3:0  R0(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status 0x00000104
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R3(_x) (((_x) & 0x1ff) << 23)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R3_of(_x) (((_x) >> 23) & 0x1ff)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_Uncorr_Int_Err_Status BIT(22)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R2 BIT(21)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_URES BIT(20)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_ECRC_Err_Status BIT(19)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_Malformed_TLP_Status BIT(18)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_Rcvr_Overflow_Status BIT(17)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_UCS BIT(16)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_CAS BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_CTS BIT(14)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_FCPES BIT(13)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_PTS BIT(12)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R1(_x) (((_x) & 0x7f) << 5)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R1_of(_x) (((_x) >> 5) & 0x7f)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_DLPER BIT(4)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R0(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_status_R0_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_mask -
    Bits: 31:0  R4(ro) - Reserved:
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_mask 0x00000108
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_mask_R4(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_mask_R4_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_uncorr_err_severity -
    Bits: 31:0  R8(ro) - Reserved:
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_severity 0x0000010c
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_severity_R8(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_uncorr_err_severity_R8_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_corr_err_status -
    Bits: 31:16 R14(ro) - Reserved: Reserved
    Bits: 15    HLOS(w1c) - Header Log Overflow Status: This bit is set on a Header Log Register overflow, that is, when the header could not be logged in the Header Log Register because it is occupied by a previous header. As per SR-IOV specification, this bit is hardwired to 0 since the Header Log is Shared among VFs.
    Bits: 14    CIES(ro) - Corrected Internal Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 13    ANFES(w1c) - Advisory Non-Fatal Error Status: This bit is set when an uncorrectable error occurs, which is determined to belong to one of the special cases described in Section 6.2.3.2.4 of the PCI Express 2.0 Specifications. This causes the core to generate an ERR_COR message in place of an ERR_NONFATAL message. STICKY.
    Bits: 12    RTTS(ro) - Replay Timer Timeout Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 11:9  R13(ro) - Reserved: Reserved
    Bits:  8    RNRS(ro) - Replay Number Rollover Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  7    BDS(ro) - Bad DLLP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  6    BTPS(ro) - Bad TP Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  5:1  R12(ro) - Reserved: Reserved
    Bits:  0    RES(ro) - Receiver Error Status: This bit is not implemented for Virtual Functions. Hardwired to 0.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status 0x00000110
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R14(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R14_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_HLOS BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_CIES BIT(14)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_ANFES BIT(13)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_RTTS BIT(12)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R13(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R13_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_RNRS BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_BDS BIT(7)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_BTPS BIT(6)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R12(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_R12_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_status_RES BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_corr_err_mask -
    Bits: 31:16 R17(ro) - Reserved:
    Bits: 15    HLOM(rw) - Header Log Overflow Mask: This bit, when set, masks the generation of error messages in response to a Header Log register overflow. STICKY. Header logs are shared across Vfs hence this field is reserved. This field is reserved since Header log sharing is selected for this configuration.
    Bits: 14    CIEM(ro) - Corrected Internal Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 13    ANFEM(ro) - Advisory Non-Fatal Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 12    RTTM(ro) - Replay Timer Timeout Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits: 11:9  R16(ro) - Reserved: Reserved
    Bits:  8    RNRM(ro) - Replay Number Rollover Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  7    BDM(ro) - Bad DLLP Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  6    BTM(ro) - Bad TLP Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
    Bits:  5:1  R15(ro) - Reserved: Reserved
    Bits:  0    REM(ro) - Receiver Error Mask: This bit is not implemented for Virtual Functions. Hardwired to 0.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask 0x00000114
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R17(_x) (((_x) & 0xffff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R17_of(_x) (((_x) >> 16) & 0xffff)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_HLOM BIT(15)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_CIEM BIT(14)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_ANFEM BIT(13)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_RTTM BIT(12)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R16(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R16_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_RNRM BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_BDM BIT(7)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_BTM BIT(6)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R15(_x) (((_x) & 0x1f) << 1)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_R15_of(_x) (((_x) >> 1) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_corr_err_mask_REM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_advcd_err_cap_ctrl -
    Bits: 31:11 R18(ro) - Reserved: Reserved
    Bits: 10    MHRE(ro) - Multiple Header Recording Enable: Setting this bit enables the Function to log multiple error headers in its Header Log Registers. It is hardwired to 0
    Bits:  9    MHRC(ro) - Multiple Header Recording Capable: This bit is set when the Function has the capability to log more than one error header in its Header Log Registers. It is hardwired to 0.
    Bits:  8    ECC(ro) - Enable ECRC Check: Setting this bit enables ECRC checking on the receive side of the core. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  7    ECCAP(ro) - ECRC Check Capability: This read-only bit indicates to the software that the device is capable of checking ECRC in packets received from the link. This bit is hardwired to 0. This setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  6    EEG(ro) - Enable ECRC Generation: Enables the ECRC generation on the transmit side of the core. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  5    EGC(ro) - ECRC Generation Capability: This read-only bit indicates to the software that the device is capable of generating ECRC in packets transmitted on the link. This bit is hardwired to 0. The setting of the corresponding bit in the Advanced Error Capabilities and Control Register of PF 0 applies to all Virtual Functions.
    Bits:  4:0  FER(ro) - First Error Pointer: This is a 5-bit pointer to the bit position in the Uncorrectable Error Status Register corresponding to the error that was detected first. When there are multiple bits set in the Uncorrectable Error Status Register, this field informs the software which error was observed first. To prevent the field from being overwritten before software was able to read it, this field is not updated while the status bit pointed by it in the Uncorrectable Error Status Register remains set. After the software clears this status bit, a subsequent error condition that sets any bit in the Uncorrectable Error Status Register will update the First Error Pointer. Any uncorrectable error type, including the special cases where the error is reported using an ERR_COR message, will set the First Error Pointer (assuming the software has reset the error pointed by it in the Uncorrectable Error Status Register). STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl 0x00000118
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_R18(_x) (((_x) & 0x1fffff) << 11)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_R18_of(_x) (((_x) >> 11) & 0x1fffff)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_MHRE BIT(10)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_MHRC BIT(9)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_ECC BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_ECCAP BIT(7)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_EEG BIT(6)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_EGC BIT(5)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_FER(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_advcd_err_cap_ctrl_FER_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_0 -
    Bits: 31:0  HD0(ro) - Header DWORD 0: First DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_0     0x0000011c
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_0_HD0(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_0_HD0_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_1 -
    Bits: 31:0  HD1(ro) - Header DWORD 1: Second DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_1     0x00000120
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_1_HD1(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_1_HD1_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_2 -
    Bits: 31:0  HD2(ro) - Header DWORD 2: Third DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_2     0x00000124
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_2_HD2(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_2_HD2_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_AER_cap_struct_i_hdr_log_3 -
    Bits: 31:0  HD3(ro) - Header DWORD 3: Fourth DWORD of captured TLP header STICKY.
*/
#define NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_3     0x00000128
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_3_HD3(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_AER_cap_struct_i_hdr_log_3_HD3_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG-assigned value for the version of the capability structure. This field is taken from the setting of the corresponding field in the ARI Extended Capability Header Register of PF 0.
    Bits: 15:0  PCCID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI-SIG to the ARI Extended Capability (000E hex).
*/
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr 0x00000140
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_PCCID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_ext_cap_hdr_PCCID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_ARI_cap_struct_i_ARI_cap_and_ctrl -
    Bits: 31:0  R13(ro) - Reserved: Reserved
*/
#define NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_cap_and_ctrl 0x00000144
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_cap_and_ctrl_R13(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_ARI_cap_struct_i_ARI_cap_and_ctrl_R13_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg -
    Bits: 31:20 NCO(ro) - Next Capability Offset: Indicates offset to the next PCI Express capability structure. The default next pointer value is dynamic and is dependent on whether the strap or LMI bits are set.
    Bits: 19:16 CV(ro) - Capability Version: Specifies the SIG assigned value for the version of the capability structure. This field is set by default to 1, but can be modified for all VFs by writing into this register field of Physical Function 0 from the local management bus.
    Bits: 15:0  PECID(ro) - PCI Express Extended Capability ID: This field is hardwired to the Capability ID assigned by PCI SIG to the TPH Requester Capability.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg 0x00000274
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_NCO(_x) (((_x) & 0xfff) << 20)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_NCO_of(_x) (((_x) >> 20) & 0xfff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_CV(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_CV_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_PECID(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ext_cap_header_reg_PECID_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_cap_reg -
    Bits: 31:27 R2(ro) - Reserved: Reserved
    Bits: 26:16 STTS(rw) - ST Table Size: Specifies the number of entries in the Steering Tag Table (0 = 1 entry, 1 = 2 entries, and so on). Max limit is 64 entries when the ST Table is located in the TPH Requester Capability Structure, and 2048 entries when located in the MSI-X table. Each entry is 16 bits long. This field can be modified from the local management bus.
    Bits: 15:11 R1(ro) - Reserved: Reserved
    Bits: 10:9  STTL(rw) - ST Table Location: The setting of this field indicates if a Steering Tag Table is implemented for this Function, and its location if present. (00 = ST Table not present, 01 = ST Table in the TPH Requester Capability Structure, 10 = ST values stored in the MSI-X Table in client RAM, 11 = reserved.). This field can be modified from the local management bus.
    Bits:  8    ERS(ro) - Extended TPH Requester Supported: When set to 1, indicates that the Function is capable of generating requests with a TPH TLP Prefix.
    Bits:  7:3  R0(ro) - Reserved: Reserved
    Bits:  2    DSMS(rw) - Device-Specific Mode Supported: A setting of 1 indicates that the Function supports the Device- Specific Mode for TPH Steering Tag generation. In this mode, the Steering Tags are supplied by the client for each request through the HAL master interface. The client typically chooses the Steering Tag values from the ST Table, but is not required to do so. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  1    IVMS(rw) - Interrupt Vector Mode Supported: A setting of 1 indicates that the Function supports the Interrupt Vector Mode for TPH Steering Tag generation. In the Interrupt Vector Mode, Steering Tags are attached to MSI/MSI-X interrupt requests. The Steering Tag for each interrupt request is selected by the MSI/MSI-X interrupt vector number. This bit is set to 1 by default, but can be modified from the local management bus.
    Bits:  0    NSTM(ro) - No ST Mode Supported: When set to 1, indicates that this Function supports the 'No ST Mode' for the generation of TPH Steering Tags. In the No ST Mode, the device must use a Steering Tag value of 0 for all requests. This bit is hardwired to 1, as all TPH Requesters are required to support the No ST Mode of operation.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg 0x00000278
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R2(_x) (((_x) & 0x1f) << 27)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R2_of(_x) (((_x) >> 27) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_STTS(_x) (((_x) & 0x7ff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_STTS_of(_x) (((_x) >> 16) & 0x7ff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R1(_x) (((_x) & 0x1f) << 11)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R1_of(_x) (((_x) >> 11) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_STTL(_x) (((_x) & 0x3) << 9)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_STTL_of(_x) (((_x) >> 9) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_ERS BIT(8)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R0(_x) (((_x) & 0x1f) << 3)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_R0_of(_x) (((_x) >> 3) & 0x1f)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_DSMS BIT(2)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_IVMS BIT(1)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_cap_reg_NSTM BIT(0)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg -
    Bits: 31:10 R10(ro) - Reserved: Reserved
    Bits:  9:8  TRE(rw) - TPH Requester Enable: When set , the Function is allowed to generate requests with Transaction Processing Hints. Defined Encodings are: 00b Function operating as a Requester is not permitted to issue Requests with TPH or Extended TPH. 01b Function operating as a Requester is permitted to issue Requests with TPH and is not permitted to issue Requests with Extended TPH. 10b Reserved. 11b Function operating as a Requester is permitted to issue Requests with TPH and Extended TPH.
    Bits:  2:0  STM(rw) - ST Mode: This field selects the ST mode (000 = No Steering Tag Mode, 001 = Interrupt Vector Mode, 010 = Device-Specific Mode, other values are reserved). The VF_TPH_ST_MODE output of the core reflects the setting of this register field (bits 3:0 for VF 0 and so on). This field can also be written from the local management bus.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg 0x0000027c
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_R10(_x) (((_x) & 0x3fffff) << 10)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_R10_of(_x) (((_x) >> 10) & 0x3fffff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_TRE(_x) (((_x) & 0x3) << 8)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_TRE_of(_x) (((_x) >> 8) & 0x3)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_STM(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_req_ctrl_reg_STM_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: i_vf_TPH_cap_struct_i_TPH_tab_0 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_1 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_2 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_3 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_4 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_5 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_6 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_7 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_8 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_9 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_10 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_11 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_12 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_13 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_14 -
  Register: i_vf_TPH_cap_struct_i_TPH_tab_15 -
    Bits: 31:24 ST1U(ro) - ST 1 Upper: This field is used for the upper 8 bits of the second Steering Tag when Extended TPH Requester support is enabled.
    Bits: 23:16 ST1L(rw) - ST 1 Lower: Lower 8 bits of the second Steering Tag. This is the 8-bit Steering Tag sent out in requests.
    Bits: 15:8  ST0U(ro) - ST 0 Upper: This field is used for the upper 8 bits of the first Steering Tag when Extended TPH Requester support is enabled.
    Bits:  7:0  ST0L(rw) - ST 0 Lower: Lower 8 bits of the first Steering Tag. This is the 8-bit Steering Tag sent out in requests.
*/
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_0     0x00000280
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_1     0x00000284
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_2     0x00000288
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_3     0x0000028c
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_4     0x00000290
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_5     0x00000294
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_6     0x00000298
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_7     0x0000029c
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_8     0x000002a0
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_9     0x000002a4
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_10    0x000002a8
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_11    0x000002ac
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_12    0x000002b0
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_13    0x000002b4
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_14    0x000002b8
#define NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_i_TPH_tab_15    0x000002bc
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST1U(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST1U_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST1L(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST1L_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST0U(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST0U_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST0L(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_VF_i_vf_TPH_cap_struct_TPH_st_table_vf_cl_ST0L_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig0 - Configures operation mode for PCIe Control Island component
    Bits: 31    PCIeConfigWren(rw) - Software must set this bit when writing to this register and before writing to the PCIeCtrlConfig1 and PCIeCtrlConfig3 registers. After the PCIe parameters have been written softare should clear this bit to protect the fields from being accidentally overwritten.
    Bits: 11:8  PfBusMasterEnable(ro) - Physical Function status indicates can issue Master requests
    Bits:  4    PcieSerdesClkMuxSel(rw) - Selects which lane to source PIPE clock from
    Bits:  3:2  PCIeLanes(rw) - Status of the number of active lanes.
    Bits:  1:0  GenEnable(rw) - Status of PCIe generation the Controller Core is configured
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0                0x00000000
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeConfigWren BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PfBusMasterEnable(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PfBusMasterEnable_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PcieSerdesClkMuxSel BIT(4)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PcieSerdesClkMuxSel_SEL_LANE0_CLK (0 << 4)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PcieSerdesClkMuxSel_SEL_LANE7_CLK BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes_X1 (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes_X2 (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes_X4 (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_PCIeLanes_X8 (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_GenEnable(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_GenEnable_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_GenEnable_Gen1 (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_GenEnable_Gen2 (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig0_GenEnable_Gen3 (2)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig1 - Configures operation mode for PCIe Control Island component
    Bits: 27:21 PcieCtrlmaxEvalIteration(rw) - MAX_EVAL_ITERATION input to Pcie Controller Core.
    Bits:  9    PcieCtrlClientReqExitL1(rw) - LINK_CLIENT_REQ_EXIT_L1 input to Pcie Controller Core.
    Bits:  7    PcieCtrlRawResetDropDisable(rw) - Set this bit to stop PCIE from dropping master requests and target completions if the raw reset is low but pcie reset disable is stopping from resetting.
    Bits:  6    PcieCtrlClientReqExitL2(rw) - LINK_CLIENT_REQ_EXIT_L2 input to Pcie Controller Core.
    Bits:  3    MgmtTyp1RegAccess(rw) - MGMT_TYP1_REG_ACCESS input to Pcie Controller Core.
    Bits:  2    ReqPmTransitionL23Ready(rw) - Control input to Pcie Controller Core.
    Bits:  1    NonPostedOverrideDisable(rw) - Setting this bit allows HAL Target posted requests to postpone and pass existing received non_posted requests (allowed per pcie spec). Default 0 allows HAL Target to fairly mix posted and non-posted requests.
    Bits:  0    ConfigEnable(rw) - Tied to Pcie Controller CONFIG_ENABLE input. When this bit is a 0 in the EP mode, the core will generate a CRS Completion in response to Configuration Requests. In systems where the core configuration registers are loaded from RAM on power-up, this prevents the core from responding to Configuration Requests before all the registers are loaded. When this bit is a 1 in the EP mode, the core will accept Configuration Requests.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1                0x00000004
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_PcieCtrlmaxEvalIteration(_x) (((_x) & 0x7f) << 21)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_PcieCtrlmaxEvalIteration_of(_x) (((_x) >> 21) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_PcieCtrlClientReqExitL1 BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_PcieCtrlRawResetDropDisable BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_PcieCtrlClientReqExitL2 BIT(6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_MgmtTyp1RegAccess BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_ReqPmTransitionL23Ready BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_NonPostedOverrideDisable BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig1_ConfigEnable BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig2 - Configures operation mode for PCIe Control Island component
    Bits: 25:10 PCIeCntrlrDebugData(ro) - Pcie Controller Core status of 16-bit output data from the debug bus.
    Bits:  9    HotResetStat(ro) - Reflects current state of the Hot Reset Status from the PCIe Controller. If set a hot reset was received from the link in the Endpoint mode.
    Bits:  8    HotResetInit(rw) - SW sets this bit when Pcie Controller Core needs to initiate a Hot Reset sequence on the PCIe link when in RC mode.
    Bits:  7    LinkDownResetOut(ro) - Pcie Controller Core status asserted when its LTSSM detects a link-down event (when the LINK_UP state variable goes to 0).
    Bits:  6    PhyInterrupt(rw1c) - PCIe Core output used in RC mode to signal a link training related event has occurred
    Bits:  5    LocalInterrupt(rw1c) - Pcie Controller Core status. Used to signal an error or abnormal condition to the local processor. The interrupting condition can be obtained by reading the Local Error Status Register.
    Bits:  4    FatalError(rw1c) - Pcie core detected a fatal error.
    Bits:  3    NonFatalError(rw1c) - Pcie core detected a non-fatal error.
    Bits:  2    CorrectableError(rw1c) - Pcie core detected a correctable error.
    Bits:  1    CorrectableErrorIn(wo) - Software writes a 1 to this bit when an correctable error has been detected. A correctable error can be a correctable error event from the Shared SRAM. The error is reported by the core through the PCI Express Advanced Error Reporting mechanism.
    Bits:  0    UncorrectableErrorIn(wo) - Software writes a 1 to this bit when an uncorrectable error has been detected. An uncorrectable error can be an uncorrectable error event from the Shared SRAM or a DMA Descriptor Rd Parity error. The error is reported by the core through the PCI Express Advanced Error Reporting mechanism.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2                0x00000008
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_PCIeCntrlrDebugData(_x) (((_x) & 0xffff) << 10)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_PCIeCntrlrDebugData_of(_x) (((_x) >> 10) & 0xffff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_HotResetStat BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_HotResetInit BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_LinkDownResetOut BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_PhyInterrupt BIT(6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_LocalInterrupt BIT(5)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_FatalError   BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_NonFatalError BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_CorrectableError BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_CorrectableErrorIn BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig2_UncorrectableErrorIn BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlConfig3 - Configures operation mode for PCIe Control Island component
    Bits: 12:2  PresetSweepMask(rw) - Controls masking off evalutating known bad TX Presets during link equalization
    Bits:  1    BypassRemoteTxEq(rw) - Controls bypassing the evaluation of the remote PHY Tx during Link Equalization
    Bits:  0    BypassPhase23(rw) - When in RC mode, controls Phase 2 and phase 3 of Link Equalization
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3                0x0000000c
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_PresetSweepMask(_x) (((_x) & 0x7ff) << 2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_PresetSweepMask_of(_x) (((_x) >> 2) & 0x7ff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassRemoteTxEq BIT(1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassRemoteTxEq_NoBypass (0 << 1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassRemoteTxEq_Bypass BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassPhase23 BIT(0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassPhase23_NoBypass (0 << 0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlConfig3_BypassPhase23_Bypass BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlrStat - PCIe Controller Status
    Bits: 27:20 RcbStatus(ro) - Indicates Pcie Controller Core status of Read Completion Boundary setting: 0 = 64B, 1 = 128B
    Bits: 19:18 NegotiatedSpeed(ro) - Reflects Pcie Controller Core status of current operating speed of the link (00 = 2.5 GT/s, 01 = 5 GT/s, 10 = 8 GT/s). Valid when LINK_STATUS = 10 or 11.
    Bits: 17:15 MaxReadReqSize(ro) - Indicates Pcie Controller Core status of the limit of the size of outgoing read requests. The 3-bit codes are the same as those defined in PCIe Specifications: 000 = 128 bytes, 001 = 256 bytes, 010 = 512 bytes, 011 = 1024 bytes, 100 = 2048 bytes 101 = 4096 bytes.
    Bits: 14:12 MaxPayloadSize(ro) - Reflects Pcie Controller Core status of the limit of the size of Outgoing Completion payloads. The 3-bit codes are the same as those defined in PCIe Specifications: 000 = 128 bytes, 001 = 256 bytes, 010 = 512 bytes.
    Bits: 11:8  LinkPowerState(ro) - Reflects Pcie Controller Core power state of the PCIe link. 0001 = L0, 0010 = L0s, 0100 = L1, 1000 = L2.
    Bits:  7:6  LinkStatus(ro) - Indicates Pcie Controller Core status of the PCI Express link. 00 = No receivers detected, 01 = Link training in progress, 10 = Link up , DL initialization in progress, 11 = Link up, DL initialization completed..
    Bits:  5:0  LtssmState(ro) - Reflects Pcie Controller Core state of the Link Training and Status State Machine.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat                  0x00000010
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_RcbStatus(_x)  (((_x) & 0xff) << 20)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_RcbStatus_of(_x) (((_x) >> 20) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_NegotiatedSpeed(_x) (((_x) & 0x3) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_NegotiatedSpeed_of(_x) (((_x) >> 18) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_MaxReadReqSize(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_MaxReadReqSize_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_MaxPayloadSize(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_MaxPayloadSize_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LinkPowerState(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LinkPowerState_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LinkStatus(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LinkStatus_of(_x) (((_x) >> 6) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LtssmState(_x) (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlrStat_LtssmState_of(_x) (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIePhysFuncStat - Physical function status
    Bits: 15:0  FunctionStatus(ro) - Indicates Pcie Controller Core status of the states of the Command Register bits in the PCI configuration space of each Function. There are 4-bits per physical function where bits [3:0] are PF0s functional status and bits [15:12] are PF3s functional status. These outputs are used to enable requests and completions from the host logic. The assignment of bits is as follows: Bit 0: Function 0 IO Space Enable, Bit 1: Function 0 Memory Space Enable, Bit 2: Function 0 Bus Master Enable, Bit 3: Function 0 INTx Disable.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePhysFuncStat               0x00000014
#define   NFP3800_PCIEX_CTRLCFG_PCIePhysFuncStat_FunctionStatus(_x) (((_x) & 0xffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePhysFuncStat_FunctionStatus_of(_x) (((_x) >> 0) & 0xffff)
/*----------------------------------------------------------------
  Register: PCIePhysFuncPwrState - Physical function power state
    Bits: 11:0  FunctionPowerState(ro) - Provides Pcie Controller Core status of the current power state of the Physical Functions. There are 3-bits per physical function where bits [2:0] are PF0s function power state and bits [11:9] are PF7s function power state. The possible power states are: 000: D0_uninitialized, 001: D0_active, 010: D1, 100: D3_hot.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePhysFuncPwrState           0x00000018
#define   NFP3800_PCIEX_CTRLCFG_PCIePhysFuncPwrState_FunctionPowerState(_x) (((_x) & 0xfff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePhysFuncPwrState_FunctionPowerState_of(_x) (((_x) >> 0) & 0xfff)
/*----------------------------------------------------------------
  Register: PCIeCtrlSpare0 - Spare
  Register: PCIeCtrlSpare1[5] - Spare
  Register: PCIeCtrlSpare2[23] - Spare
  Register: PCIeCtrlSpare3[23] - Spare
  Register: PCIeCtrlSpare4[5] - Spare
  Register: PCIeCtrlSpare5[4] - Spare register address, no hw implemented
  Register: PCIeCtrlSpare6 - Spare
  Register: PCIeCtrlSpare7 - Spare
  Register: PCIeCtrlSpare8[3] - Spare
  Register: PcieCtrlVscMap_PCIeCtrlVscMapSpare - Spare
  Register: PcieCtrlVscMap_PCIeCtrlVscSpare[21] - Spare
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare0                 0x0000001c
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare1(_x)             (0x0000006c + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare2(_x)             (0x000000a0 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare3(_x)             (0x00000120 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare4(_x)             (0x000001bc + (0x4 * ((_x) & 0x7)))
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare5(_x)             (0x00000210 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare6                 0x00000228
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare7                 0x0000022c
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSpare8(_x)             (0x00000314 + (0x4 * ((_x) & 0x3)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscMapSpare 0x00000334
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscSpare(_x) (0x0000033c + (0x4 * ((_x) & 0x1f)))
/*----------------------------------------------------------------
  Register: PCIeVf0Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (27-0)
    Bits: 31:4  VFEnableStat(ro) - Virtual Function enable status for VF 27-0.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf0Enable                  0x00000020
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0Enable_VFEnableStat(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0Enable_VFEnableStat_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (59-28)
    Bits: 31:0  VFEnableStat(ro) - Virtual Function enable status for VF (59-28).
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf1Enable                  0x00000024
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1Enable_VFEnableStat(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1Enable_VFEnableStat_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2Enable - 1-bit per VF, status of VF enable. 0=disabled, 1=enabled. VF# (63-60)
    Bits:  3:0  VFEnableStat(ro) - Virtual Function enable status for VF (63-60).
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf2Enable                  0x00000028
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2Enable_VFEnableStat(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2Enable_VFEnableStat_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeIntSidebandSignals0 - Interrupt sideband status signals 0-31
  Register: PCIeIntSidebandSignals1 - Interrupt sideband status signals 32-63
    Bits: 31:0  PCIE_INBT_SIDEBAND_SIGNALS(rw1c) - PCIe Interrupt sideband signals
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeIntSidebandSignals0        0x00000030
#define NFP3800_PCIEX_CTRLCFG_PCIeIntSidebandSignals1        0x00000034
#define   NFP3800_PCIEX_CTRLCFG_PCIeIntSideBandSignals_PCIE_INBT_SIDEBAND_SIGNALS(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeIntSideBandSignals_PCIE_INBT_SIDEBAND_SIGNALS_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf0BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (27-0)
    Bits: 31:4  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 27-0.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf0BusMstrEnable           0x00000040
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0BusMstrEnable_VFBusMstrEnableStat(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0BusMstrEnable_VFBusMstrEnableStat_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (59-28)
    Bits: 31:0  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 59-28.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf1BusMstrEnable           0x00000044
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1BusMstrEnable_VFBusMstrEnableStat(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1BusMstrEnable_VFBusMstrEnableStat_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2BusMstrEnable - 1-bit per VF, status of VF bus master enable. 0=disabled, 1=enabled. VF# (63-60)
    Bits:  3:0  VFBusMstrEnableStat(ro) - Virtual Function bus master enable status for VF 63-60.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf2BusMstrEnable           0x00000048
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2BusMstrEnable_VFBusMstrEnableStat(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2BusMstrEnable_VFBusMstrEnableStat_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlr0InProg - Virtual/Physicaa Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. PF# (0-3) VF# (0-27)
    Bits: 31:4  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (27-0)
    Bits:  3:0  FlrInProg(ro) - Physical Function, Function Level Reset in progress status
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeFlr0InProg                 0x00000060
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr0InProg_VfFlrInProg(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr0InProg_VfFlrInProg_of(_x) (((_x) >> 4) & 0xfffffff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr0InProg_FlrInProg(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr0InProg_FlrInProg_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlr1InProg - Virtual Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. VF# (59-28)
    Bits: 31:0  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (59-28)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeFlr1InProg                 0x00000064
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr1InProg_VfFlrInProg(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr1InProg_VfFlrInProg_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeFlr2InProg - Virtual Function Function Level Reset in progress. 0=No VF FLR in progress, 1=VF FLR in progress. VF# (63-60)
    Bits:  3:0  VfFlrInProg(ro) - Virtual Function, Function Level Reset in progress status for VF# (63-60).
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeFlr2InProg                 0x00000068
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr2InProg_VfFlrInProg(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlr2InProg_VfFlrInProg_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeVfPwrState[8] - 3 bits per VF, provide current power state of the Virtual Function, 000: D0_uninitialized, 001: D0_active, 010: D1, 100: D3_hot. VF# (7-0)*{{X+1}}
    Bits: 23:21 PCIeVfPwrStateN7(ro) - VFn7 Power State
    Bits: 20:18 PCIeVfPwrStateN6(ro) - VFn6 Power State
    Bits: 17:15 PCIeVfPwrStateN5(ro) - VFn5 Power State
    Bits: 14:12 PCIeVfPwrStateN4(ro) - VFn4 Power State
    Bits: 11:9  PCIeVfPwrState_N3(ro) - VFn3 Power State
    Bits:  8:6  PCIeVfPwrStateN2(ro) - VFn2 Power State
    Bits:  5:3  PCIeVfPwrStateN1(ro) - VFn1 Power State
    Bits:  2:0  PCIeVfPwrStateN(ro) - VFn Power State
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState(_x)             (0x00000080 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN7(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN7_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN6(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN6_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN5(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN5_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN4(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN4_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrState_N3(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrState_N3_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN2(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN2_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN1(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN1_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfPwrState_PCIeVfPwrStateN_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieHalPme - Indicates the activity in HAL switch, a value of zero indicates everything is idle.
    Bits:  2    PcieHalmComplInletFifoValid(rc) - pcie_halm_compl_inlet_fifo_valid
    Bits:  1    PcieHalmBurstComplFifoValid(rc) - pcie_halm_burst_compl_fifo_valid
    Bits:  0    PcieHalmOutletFifoValid(rc) - pcie_halm_outlet_fifo_valid
*/
#define NFP3800_PCIEX_CTRLCFG_PcieHalPme                     0x000000fc
#define   NFP3800_PCIEX_CTRLCFG_PcieHalPme_PcieHalmComplInletFifoValid BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PcieHalPme_PcieHalmBurstComplFifoValid BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PcieHalPme_PcieHalmOutletFifoValid BIT(0)
/*----------------------------------------------------------------
  Register: PCIeVfTphState[8] - TPH ST mode 3-bits per VF. VF# (7-0)*{{X+1}}
    Bits: 23:21 PCIeVfTphStModeN7(ro) - VFn7 TPH ST Mode
    Bits: 20:18 PCIeVfTphStModeN6(ro) - VFn6 TPH ST Mode
    Bits: 17:15 PCIeVfTphStModeN5(ro) - VFn5 TPH ST Mode
    Bits: 14:12 PCIeVfTphStModeN4(ro) - VFn4 TPH ST Mode
    Bits: 11:9  PCIeVfTphStModeN3(ro) - VFn3 TPH ST Mode
    Bits:  8:6  PCIeVfTphStModeN2(ro) - VFn2 TPH ST Mode
    Bits:  5:3  PCIeVfTphStModeN1(ro) - VFn1 TPH ST Mode
    Bits:  2:0  PCIeVfTphStModeN(ro) - VFn TPH ST Mode
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVfTphState(_x)             (0x00000100 + (0x4 * ((_x) & 0x7)))
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN7(_x) (((_x) & 0x7) << 21)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN7_of(_x) (((_x) >> 21) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN6(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN6_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN5(_x) (((_x) & 0x7) << 15)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN5_of(_x) (((_x) >> 15) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN4(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN4_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN3(_x) (((_x) & 0x7) << 9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN3_of(_x) (((_x) >> 9) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN2(_x) (((_x) & 0x7) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN2_of(_x) (((_x) >> 6) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN1(_x) (((_x) & 0x7) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN1_of(_x) (((_x) >> 3) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVfTphState_PCIeVfTphStModeN_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PcieIntMsiMsgAborted - Reporting Requester ID and Vector number of a MSI msg aborted occurred.
    Bits: 14    PcieMsiMsgAbortedMask(rw) - When set it indicates a MSI message aborted will be masked
    Bits: 13    PcieMsiMsgAborted(w1c) - When set it indicates a MSI message aborted occurred. When cleared the Vector number and Requester ID fields are invalid
    Bits: 12:5  PcieMsiMsgAbortReqId(ro) - Requester id of aborted MSI message
    Bits:  4:0  PcieMsiMsgAbortVector(ro) - Vector number of aborted MSI message.
*/
#define NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted           0x0000017c
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAbortedMask BIT(14)
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAborted BIT(13)
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAbortReqId(_x) (((_x) & 0xff) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAbortReqId_of(_x) (((_x) >> 5) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAbortVector(_x) (((_x) & 0x1f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PcieIntMsiMsgAborted_PcieMsiMsgAbortVector_of(_x) (((_x) >> 0) & 0x1f)
/*----------------------------------------------------------------
  Register: PCIeStateChangeStat - Contains the state change interrupt and status
    Bits: 21    FuncStatusChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 20    PwrStateChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 19    VfBusMstrEnStateChangeIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 18    VfEnableStateChangeIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 17    LinkPwrStateChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 16    LinkStatusChgIntMask(rw) - Software sets this bit to mask off the corresponding interrupt status bit.
    Bits: 15:8  CfgFuncNum(ro) - Contains the CONFIG_FUNCTION_NUM associated with the POWER_STATE_CHANGE_INTERRUPT.
    Bits:  5    FuncStatusChgInt(rw1c) - Interrupt status bit that indicates there was a change to the FUNCTION_STATUS bits from the PCIe core
    Bits:  4    PwrStateChgInt(rw1c) - Interrupt status bit that indicates there was a change to the FUNCTION_POWER_STATE or VF_POWER_STATE status from the PCIe core. Writing a 1 to this register asserts the POWER_STATE_CHANGE_ACK back to the PCIe Core.
    Bits:  3    VfBusMstrEnStateChangeInt(rw1c) - Interrupt status bit that indicates there was a change to the VF_BUS_MASTER_ENABLE status from the PCIe core
    Bits:  2    VfEnableStateChangeInt(rw1c) - Interrupt status bit that indicates there was a change to VF_ENABLE status from the PCIe core.
    Bits:  1    LinkPwrStateChgInt(rw1c) - Interrupt status bit that indicates the LINK_POWER_STATE has changed
    Bits:  0    LinkStatusChgInt(rw1c) - Interrupt status bit that indicates the LINK_STATUS has changed
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat            0x00000180
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_FuncStatusChgIntMask BIT(21)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_PwrStateChgIntMask BIT(20)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_VfBusMstrEnStateChangeIntMask BIT(19)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_VfEnableStateChangeIntMask BIT(18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_LinkPwrStateChgIntMask BIT(17)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_LinkStatusChgIntMask BIT(16)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_CfgFuncNum(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_CfgFuncNum_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_FuncStatusChgInt BIT(5)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_PwrStateChgInt BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_VfBusMstrEnStateChangeInt BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_VfEnableStateChangeInt BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_LinkPwrStateChgInt BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeStateChangeStat_LinkStatusChgInt BIT(0)
/*----------------------------------------------------------------
  Register: PCIeMsiDropError - Contains MSI Req Drop status, mask and function of the request error
    Bits: 10    IsLegacy(ro) - This bit indicates that the MSI recieved went down as legacy and was dropped due to INTx disable.
    Bits:  9    MSIReqErrorMask(rw) - Set this bit to mask event generation when an MSI Request Error is detected. Clear this bit to enable MSI Request Error event generation.
    Bits:  8    MSIReqError(rw1c) - This bit is set when a VF MSI Interrupt is received from the attached PCIe Island for a function that is masked for MSI
    Bits:  7:0  MSIFunction(ro) - Function number associated with the MSIReqError
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError               0x00000184
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError_IsLegacy    BIT(10)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError_MSIReqErrorMask BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError_MSIReqError BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError_MSIFunction(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiDropError_MSIFunction_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop - Top level MSI Mask Change Status register.
    Bits: 11:8  MsiMaskChgStat(w1c) - PF MSI Mask Change status for PF 0-3. A set bit indicates there was a write to the PF MSI Mask register associated with a Physical Function
    Bits:  2:0  VfMsiMaskChgTopStat(ro) - Used by software to indicate which of the three PCIeVfMsiMaskChgStat registers contains a set bit. Bit 0 equals the logical 'or' of the PCIeVfMsiMaskChgStat0 register. Bit 1 equals the logical 'or' of the PCIeVfMsiMaskChgStat2 register. Bit 2 equals the logical 'or' of the PCIeVfMsiMaskChgStat3 register.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop 0x00000188
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop_MsiMaskChgStat(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop_MsiMaskChgStat_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop_VfMsiMaskChgTopStat(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeMsiMaskChgStatTop_VfMsiMaskChgTopStat_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf0MsiMaskChgStat - VF MSI Mask Change Status register, VF# (27-0)
    Bits: 31:4  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF (27-0). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf0MsiMaskChgStat 0x0000018c
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf0MsiMaskChgStat_VfMsiMaskChgStat(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf0MsiMaskChgStat_VfMsiMaskChgStat_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf1MsiMaskChgStat - VF MSI Mask Change Status register VF# (59-28)
    Bits: 31:0  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF (59-28). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf1MsiMaskChgStat 0x00000190
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf1MsiMaskChgStat_VfMsiMaskChgStat(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf1MsiMaskChgStat_VfMsiMaskChgStat_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeMsiMaskChgStruct_PCIeVf2MsiMaskChgStat - VF MSI Mask Change Status register VF# (63-60)
    Bits:  3:0  VfMsiMaskChgStat(w1c) - VF MSI Mask Change status for VF(63-60). A set bit indicates there was a write to the VF MSI Mask register associated with a Virtual Function
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf2MsiMaskChgStat 0x00000194
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf2MsiMaskChgStat_VfMsiMaskChgStat(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeMsiMaskChgStruct_PCIeVf2MsiMaskChgStat_VfMsiMaskChgStat_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIeFlrDone - Function Level Reset Done Registers
    Bits: 10:5  VfFlrDoneChannel(rw) - Virtual Function, Function Level Reset Done Channel
    Bits:  4    VfFlrDone(wo) - Virtual Function, Function Level Reset Done
    Bits:  2:1  FlrDoneChannel(rw) - Physical Function, Function Level Reset Done Channel
    Bits:  0    FlrDone(wo) - Physical Function, Function Level Reset Done
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeFlrDone                    0x000001ac
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_VfFlrDoneChannel(_x) (((_x) & 0x3f) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_VfFlrDoneChannel_of(_x) (((_x) >> 5) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_VfFlrDone        BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_FlrDoneChannel(_x) (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_FlrDoneChannel_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeFlrDone_FlrDone          BIT(0)
/*----------------------------------------------------------------
  Register: PCIeVf0TphReqEnable - Virtual Function TPH requester enable for VF 27-0.
    Bits: 31:4  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (27-0)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf0TphReqEnable            0x000001b0
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0TphReqEnable_PCIeVfTphReqEnaN(_x) (((_x) & 0xfffffff) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf0TphReqEnable_PCIeVfTphReqEnaN_of(_x) (((_x) >> 4) & 0xfffffff)
/*----------------------------------------------------------------
  Register: PCIeVf1TphReqEnable - Virtual Function TPH requester enable for VF# 59-28
    Bits: 31:0  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (59-28)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf1TphReqEnable            0x000001b4
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1TphReqEnable_PCIeVfTphReqEnaN(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf1TphReqEnable_PCIeVfTphReqEnaN_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PCIeVf2TphReqEnable - Virtual Function TPH requester enable for VF# 63-0
    Bits:  3:0  PCIeVfTphReqEnaN(ro) - Virtual Function TPH requester enable for VF (63-60)
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVf2TphReqEnable            0x000001b8
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2TphReqEnable_PCIeVfTphReqEnaN(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVf2TphReqEnable_PCIeVfTphReqEnaN_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff0 - map presets to their coefficients. Preset 0
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff0               0x000001d0
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff0_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff0_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff0_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff0_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff1 - map presets to their coefficients. Preset 1
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff1               0x000001d4
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff1_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff1_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff1_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff1_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff2 - map presets to their coefficients. Preset 2
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff2               0x000001d8
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff2_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff2_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff2_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff2_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff3 - map presets to their coefficients. Preset 3
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff3               0x000001dc
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff3_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff3_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff3_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff3_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff4 - map presets to their coefficients. Preset 4
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff4               0x000001e0
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff4_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff4_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff4_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff4_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff5 - map presets to their coefficients. Preset 5
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff5               0x000001e4
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff5_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff5_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff5_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff5_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff6 - map presets to their coefficients. Preset 6
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff6               0x000001e8
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff6_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff6_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff6_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff6_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff7 - map presets to their coefficients. Preset 7
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff7               0x000001ec
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff7_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff7_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff7_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff7_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff8 - map presets to their coefficients. Preset 8
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff8               0x000001f0
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff8_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff8_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff8_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff8_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff9 - map presets to their coefficients. Preset 9
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff9               0x000001f4
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff9_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff9_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff9_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff9_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIePresetCoeff10 - map presets to their coefficients. Preset 10
    Bits: 31:18 Reserved(ro) - Reserved
    Bits: 17:0  PCIePresetCoeff(rw) - Map presets to their coefficients.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff10              0x000001f8
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff10_Reserved(_x) (((_x) & 0x3fff) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff10_Reserved_of(_x) (((_x) >> 18) & 0x3fff)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff10_PCIePresetCoeff(_x) (((_x) & 0x3ffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIePresetCoeff10_PCIePresetCoeff_of(_x) (((_x) >> 0) & 0x3ffff)
/*----------------------------------------------------------------
  Register: PCIeSramCtrlReg - Sram Ctrl Reg for LINK memories
    Bits: 31    PcieSramCtlWen(wo) - Write to 1 to initiate a write to the selected sram control register.
    Bits: 18:16 PCIeSramCtlSel(rw) - Selects which SRAM Control register to write to or read from.
    Bits: 10    TStab0(rw) - SRAM0: Stability test during Read operation. Low during functional mode.
    Bits:  9    TWbt0(rw) - SRAM0: Weak Bit Test. Low during functional mode. Used for margin test by implementing small speed up in Sense-amp timings during read operations and small decrease in Wordline pulse-width during write operation.
    Bits:  8    MaTpb0(rw) - SRAM0: Margin Adjust Port B.
    Bits:  7    MaTpa0(rw) - SRAM0: Margin Adjust Port A.
    Bits:  6:5  MaWras0(rw) - SRAM0: Margin Adjust: Write Assist timings.
    Bits:  4:3  MaWl0(rw) - SRAM0: Margin Adjust: Wordline pulse width only. See SRAMs specs.
    Bits:  2:1  MaSawl0(rw) - SRAM0: Margin Adjust: Sense-Amp timing and Wordline pulse width. See SRAMs specs.
    Bits:  0    MaWrasd0(rw) - SRAM0: Margin Adjust: Write Assist function disable. See SRAMs specs.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg                0x000001fc
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PcieSramCtlWen BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel(_x) (((_x) & 0x7) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_of(_x) (((_x) >> 16) & 0x7)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_PnPFIFORam (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_ReplayBufferRam (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_ComplFIFORam (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_SCTableRam (3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_SCTableTimerRam (4)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_SCTableBCRam (5)
#define     NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_PCIeSramCtlSel_TPHRam (6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_TStab0       BIT(10)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_TWbt0        BIT(9)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaTpb0       BIT(8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaTpa0       BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaWras0(_x)  (((_x) & 0x3) << 5)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaWras0_of(_x) (((_x) >> 5) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaWl0(_x)    (((_x) & 0x3) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaWl0_of(_x) (((_x) >> 3) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaSawl0(_x)  (((_x) & 0x3) << 1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaSawl0_of(_x) (((_x) >> 1) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeSramCtrlReg_MaWrasd0     BIT(0)
/*----------------------------------------------------------------
  Register: PCIeLocalLowFreq[2] - Provides the Low Frequency (LF) values used for quad SERDES #X. These signals are only used at the 8.0 GT/s signaling rate.
    Bits: 31:24 Reserved(ro) - Reserved
    Bits: 23:18 LocalLf_lane_n3(rw) - Lane n3 Low Frequency (LF) value considered during TX equalization.
    Bits: 17:12 LocalLf_lane_n2(rw) - Lane n2 Low Frequency (LF) value considered during TX equalization.
    Bits: 11:6  LocalLf_lane_n1(rw) - Lane n1 Low Frequency (LF) value considered during TX equalization.
    Bits:  5:0  LocalLf_lane_n0(rw) - Lane n0 Low Frequency (LF) value considered during TX equalization.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq(_x)           (0x00000200 + (0x4 * ((_x) & 0x1)))
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_Reserved(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_Reserved_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n3(_x) (((_x) & 0x3f) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n3_of(_x) (((_x) >> 18) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n2(_x) (((_x) & 0x3f) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n2_of(_x) (((_x) >> 12) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n1(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n1_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n0(_x) (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalLowFreq_LocalLf_lane_n0_of(_x) (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIeLocalFullSwing[2] - Provides the Full Swing values used for quad SERDES #X. These signals are only used at the 8.0 GT/s signaling rate.
    Bits: 31:24 Reserved(ro) - Reserved
    Bits: 23:18 LocalFs_lane_n3(rw) - Lane n3 Low Frequency (FS) value considered during TX equalization.
    Bits: 17:12 LocalFs_lane_n2(rw) - Lane n2 Low Frequency (FS) value considered during TX equalization.
    Bits: 11:6  LocalFs_lane_n1(rw) - Lane n1 Low Frequency (FS) value considered during TX equalization.
    Bits:  5:0  LocalFs1_lane_n0(rw) - Lane n0 Low Frequency (FS) value considered during TX equalization.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing(_x)         (0x00000208 + (0x4 * ((_x) & 0x1)))
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_Reserved(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_Reserved_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n3(_x) (((_x) & 0x3f) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n3_of(_x) (((_x) >> 18) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n2(_x) (((_x) & 0x3f) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n2_of(_x) (((_x) >> 12) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n1(_x) (((_x) & 0x3f) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs_lane_n1_of(_x) (((_x) >> 6) & 0x3f)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs1_lane_n0(_x) (((_x) & 0x3f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeLocalFullSwing_LocalFs1_lane_n0_of(_x) (((_x) >> 0) & 0x3f)
/*----------------------------------------------------------------
  Register: PCIeCtrlIntOutSel - Legacy interrupt select for PF0-PF7
    Bits:  7:6  InterruptOutSelectPF3(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  5:4  InterruptOutSelectPF2(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  3:2  InterruptOutSelectPF1(rw) - Selects which interrupt pin legacy interrupts are mapped to.
    Bits:  1:0  InterruptOutSelectPF0(rw) - Selects which interrupt pin legacy interrupts are mapped to.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel              0x00000220
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3(_x) (((_x) & 0x3) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3_of(_x) (((_x) >> 6) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3_INTA (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3_INTB (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3_INTC (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF3_INTD (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2_INTA (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2_INTB (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2_INTC (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF2_INTD (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1_INTA (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1_INTB (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1_INTC (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF1_INTD (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0_INTA (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0_INTB (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0_INTC (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlIntOutSel_InterruptOutSelectPF0_INTD (3)
/*----------------------------------------------------------------
  Register: PCIeVsecCtrl0 - VSEC Ctrl inputs to the controller PF0-PF3
    Bits: 31:24 VsecCtrlPF3(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits: 23:16 VsecCtrlPF2(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits: 15:8  VsecCtrlPF1(rw) - VSEC Ctrl input to Pcie Controller Core.
    Bits:  7:0  VsecCtrlPF0(rw) - VSEC Ctrl input to Pcie Controller Core.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0                  0x00000224
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF3(_x) (((_x) & 0xff) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF3_of(_x) (((_x) >> 24) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF2(_x) (((_x) & 0xff) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF2_of(_x) (((_x) >> 16) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF1(_x) (((_x) & 0xff) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF1_of(_x) (((_x) >> 8) & 0xff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF0(_x) (((_x) & 0xff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeVsecCtrl0_VsecCtrlPF0_of(_x) (((_x) >> 0) & 0xff)
/*----------------------------------------------------------------
  Register: PCIeCtrlAsrtCfg - Link Assertion Config
    Bits: 17:16 PcieAsrtCfgEnableFsms(rw) - Set to enable FSM assertions, one bit for each of the 2 assertion drive modules.
    Bits:  1:0  PcieAsrtCfgDisableAssertions(rw) - Set to disable the assertions, one bit for each of the 2 assertion drive modules.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlAsrtCfg                0x000002a0
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlAsrtCfg_PcieAsrtCfgEnableFsms(_x) (((_x) & 0x3) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlAsrtCfg_PcieAsrtCfgEnableFsms_of(_x) (((_x) >> 16) & 0x3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlAsrtCfg_PcieAsrtCfgDisableAssertions(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlAsrtCfg_PcieAsrtCfgDisableAssertions_of(_x) (((_x) >> 0) & 0x3)
/*----------------------------------------------------------------
  Register: MsiMaskChangeEventEn - Set this bit to enable event generation for MSI Mask changes.
    Bits:  0    MsiMaskChangeEventEn(rw) - Set this bit to enable event generation for MSI mask changes.
*/
#define NFP3800_PCIEX_CTRLCFG_MsiMaskChangeEventEn           0x000002a4
#define   NFP3800_PCIEX_CTRLCFG_MsiMaskChangeEventEn_MsiMaskChangeEventEn BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlResetStat - Link Reset status
    Bits:  4    PcieRawResetStatus(ro) - Live status of the raw reset.
    Bits:  3    PcieRawResetFallingMask(rw) - Bit to Mask the event generation for a falling edge on the raw reset.
    Bits:  2    PcieRawResetFalling(rc) - Set to 1 if there has been a falling edge on the raw reset.
    Bits:  1    PcieRawResetRisingMask(rw) - Bit to Mask the event generation for a rising edge on the raw reset.
    Bits:  0    PcieRawResetRising(rc) - Set to 1 if there has been a rising edge on the raw reset.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat              0x000002ac
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat_PcieRawResetStatus BIT(4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat_PcieRawResetFallingMask BIT(3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat_PcieRawResetFalling BIT(2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat_PcieRawResetRisingMask BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlResetStat_PcieRawResetRising BIT(0)
/*----------------------------------------------------------------
  Register: PCIeCtrlPerfCfg - Link Performance Mux Control Register
    Bits: 20:18 AuxSelect(None) - Module select for module 3.
    Bits: 17:14 HiMuxSelect(None) - High 16 to 1 mux select
    Bits: 13:10 MidMuxSelect(None) - Middle 16 to 1 mux select.
    Bits:  9:6  LowMuxSelect(None) - Low 16 to 1 mux select.
    Bits:  5:4  LaneSelectHi(None) - Lane select for bits [32;64]
    Bits:  3:2  LaneSelectMid(None) - Lane select for bits [32;32]
    Bits:  1:0  LaneSelectLo(None) - Lane select for bits [32;0]
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg                0x000002b0
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_AuxSelect(_x) (((_x) & 0x7) << 18)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_AuxSelect_of(_x) (((_x) >> 18) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_HiMuxSelect(_x) (((_x) & 0xf) << 14)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_HiMuxSelect_of(_x) (((_x) >> 14) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_MidMuxSelect(_x) (((_x) & 0xf) << 10)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_MidMuxSelect_of(_x) (((_x) >> 10) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LowMuxSelect(_x) (((_x) & 0xf) << 6)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LowMuxSelect_of(_x) (((_x) >> 6) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi(_x) (((_x) & 0x3) << 4)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi_of(_x) (((_x) >> 4) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi_Deselect (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi_LowSelect (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi_MidSelect (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectHi_HiSelect (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid(_x) (((_x) & 0x3) << 2)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid_of(_x) (((_x) >> 2) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid_Deselect (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid_LowSelect (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid_MidSelect (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectMid_HiSelect (3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo(_x) (((_x) & 0x3) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo_of(_x) (((_x) >> 0) & 0x3)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo_Deselect (0)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo_LowSelect (1)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo_MidSelect (2)
#define     NFP3800_PCIEX_CTRLCFG_PCIeCtrlPerfCfg_LaneSelectLo_HiSelect (3)
/*----------------------------------------------------------------
  Register: PCIeCtrlSwCreditLimit0 - SW credit limits for credit trackers in HAL switch
    Bits: 14:12 PcieHalmComplOutletCt(rw) - SW limit for halm compl outlet Fifo.
    Bits: 11:3  PcieHalmComplBurstComplCt(rw) - SW limit for halm compl Burst Compl Fifo.
    Bits:  2:0  PciemHalmComplC1Ct(rw) - SW limit for pciem halm compl fifo.
*/
#define NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0         0x00000300
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PcieHalmComplOutletCt(_x) (((_x) & 0x7) << 12)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PcieHalmComplOutletCt_of(_x) (((_x) >> 12) & 0x7)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PcieHalmComplBurstComplCt(_x) (((_x) & 0x1ff) << 3)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PcieHalmComplBurstComplCt_of(_x) (((_x) >> 3) & 0x1ff)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PciemHalmComplC1Ct(_x) (((_x) & 0x7) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PCIeCtrlSwCreditLimit0_PciemHalmComplC1Ct_of(_x) (((_x) >> 0) & 0x7)
/*----------------------------------------------------------------
  Register: SerDesCtrl - Control Register for serdes registers' read write operations.
    Bits: 31    SerDesErrorW12C(rw1c) - Gives the status of the serdes error, w12c
    Bits: 21:2  SerDesAddr(rw) - Address [19:0] of the serdes AHB address
    Bits:  1    SerDesRNW(rw) - 1=Read, 0=Write
    Bits:  0    SerDesBusy(rw) - Write 1 to this bit to start the serdes operation. Self clears after ack. Read this bit before writing a new op again
*/
#define NFP3800_PCIEX_CTRLCFG_SerDesCtrl                     0x00000260
#define   NFP3800_PCIEX_CTRLCFG_SerDesCtrl_SerDesErrorW12C   BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_SerDesCtrl_SerDesAddr(_x)    (((_x) & 0xfffff) << 2)
#define   NFP3800_PCIEX_CTRLCFG_SerDesCtrl_SerDesAddr_of(_x) (((_x) >> 2) & 0xfffff)
#define   NFP3800_PCIEX_CTRLCFG_SerDesCtrl_SerDesRNW         BIT(1)
#define   NFP3800_PCIEX_CTRLCFG_SerDesCtrl_SerDesBusy        BIT(0)
/*----------------------------------------------------------------
  Register: SerDesWrData - Write port to serdes registers.
    Bits: 31:0  SerDesWrData(rw) - Write Data for serdes registers
*/
#define NFP3800_PCIEX_CTRLCFG_SerDesWrData                   0x00000264
#define   NFP3800_PCIEX_CTRLCFG_SerDesWrData_SerDesWrData(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_SerDesWrData_SerDesWrData_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: SerDesRdData - Read return data for serdes.
    Bits: 31:0  SerDesRdData(ro) - Read Data for serdes registers
*/
#define NFP3800_PCIEX_CTRLCFG_SerDesRdData                   0x00000268
#define   NFP3800_PCIEX_CTRLCFG_SerDesRdData_SerDesRdData(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_SerDesRdData_SerDesRdData_of(_x) (((_x) >> 0) & 0xffffffff)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlVscLastVf0 - PCI Vendor Specific Capability Last VF register, used for PF0-3
    Bits: 31    Pf3LastVfRsvd(ro) - Reserved
    Bits: 30:24 Pf3LastVF(rw) - Last VF[6;0] associated with Physical function 3
    Bits: 23    Pf2LastVfRsvd(ro) - Reserved
    Bits: 22:16 Pf2LastVF(rw) - Last VF[6;0] associated with Physical function 2
    Bits: 15    Pf1LastVfRsvd(ro) - Reserved
    Bits: 14:8  Pf1LastVF(rw) - Last VF[6;0] associated with Physical function 1
    Bits:  7    Pf0LastVfRsvd(ro) - Reserved
    Bits:  6:0  Pf0LastVF(rw) - Last VF[6;0] associated with Physical function 0
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0 0x00000330
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf3LastVfRsvd BIT(31)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf3LastVF(_x) (((_x) & 0x7f) << 24)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf3LastVF_of(_x) (((_x) >> 24) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf2LastVfRsvd BIT(23)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf2LastVF(_x) (((_x) & 0x7f) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf2LastVF_of(_x) (((_x) >> 16) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf1LastVfRsvd BIT(15)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf1LastVF(_x) (((_x) & 0x7f) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf1LastVF_of(_x) (((_x) >> 8) & 0x7f)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf0LastVfRsvd BIT(7)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf0LastVF(_x) (((_x) & 0x7f) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscLastVf0_Pf0LastVF_of(_x) (((_x) >> 0) & 0x7f)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlVscRegionEna - PCI Vendor Specific Capability Region Enables
    Bits: 19:16 MsixOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting MSI-X configuration registers at offset 0xb0-0xbc. There is one enable per physical function.
    Bits: 11:8  MsiOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting MSI configuration registers at offset 0x90-0xac. There is one enable per physical function.
    Bits:  3:0  PwrOvrdEna(rw) - When set the Vendor Specific Configuration registers override the exiting power-management configuration registers at offset 0x88-0x8c. There is one enable per physical function.
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna 0x00000338
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_MsixOvrdEna(_x) (((_x) & 0xf) << 16)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_MsixOvrdEna_of(_x) (((_x) >> 16) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_MsiOvrdEna(_x) (((_x) & 0xf) << 8)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_MsiOvrdEna_of(_x) (((_x) >> 8) & 0xf)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_PwrOvrdEna(_x) (((_x) & 0xf) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscRegionEna_PwrOvrdEna_of(_x) (((_x) >> 0) & 0xf)
/*----------------------------------------------------------------
  Register: PcieCtrlVscMap_PCIeCtrlPF0VscCfg[32] - PF0 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF1VscCfg[32] - PF1 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF2VscCfg[32] - PF2 PCI Vendor Specific Capablity Register X
  Register: PcieCtrlVscMap_PCIeCtrlPF3VscCfg[32] - PF3 PCI Vendor Specific Capablity Register X
    Bits: 31:0  PCIeVendorSpecificCapabilityReg(rw) - Programmable Vendor Specific Capability Registers
*/
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlPF0VscCfg(_x) (0x00000390 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlPF1VscCfg(_x) (0x00000410 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlPF2VscCfg(_x) (0x00000490 + (0x4 * ((_x) & 0x1f)))
#define NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlPF3VscCfg(_x) (0x00000510 + (0x4 * ((_x) & 0x1f)))
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscCfg_PCIeVendorSpecificCapabilityReg(_x) (((_x) & 0xffffffff) << 0)
#define   NFP3800_PCIEX_CTRLCFG_PcieCtrlVscMap_PCIeCtrlVscCfg_PCIeVendorSpecificCapabilityReg_of(_x) (((_x) >> 0) & 0xffffffff)

#endif /* NFP3800_LONGNAMES */


#endif /* NFP3800_PCIE_H */
