#! /usr/bin/env python

import sys
import os
import mmap
import struct
import getopt

def main():

    operation = None;
    pattern   = None;
    start  = -1;
    length = -1;    

    short_opts = "o:p:s:l:h"
    long_opts  = ["operation=", "pattern=", "start=", "length=", "help"]

    try:
        options, remainder = getopt.getopt(sys.argv[1:], short_opts, long_opts)  
    except getopt.GetoptError, err:
        print str(err)
        usage()
        sys.exit(1)

    try:
        for opt, arg in options:
            if   opt in ("-o", "--operation"):
                if arg in ("FILL", "VALIDATE", "DISPLAY"):
                    operation = arg
                else:
                    raise Exception("invalid operation")
            elif opt in ("-p", "--pattern"):
                if arg in ("ZEROES", "ONES", "OFFSET"):
                    pattern = arg
                elif is_integer(arg):
                    pattern = "LITERAL"
                    literal = int(arg,0)
                else:
                    raise Exception("invalid pattern")
            elif opt in ("-s", "--start"):
                if int(arg,0) >= 0:
                    start = int(arg,0)
                else:
                    raise Exception("invalid start address")
            elif opt in ("-l", "--length"):
                if int(arg,0) > 0:
                    length = int(arg,0)
                else:
                    raise Exception("invalid length")
            elif opt in ("-h", "--help"):
                usage(sys.argv[0])
                sys.exit(0)
            else:
                raise Exception("unhandled option")

        if None == operation:
            raise Exception("operation not provided")

        if None == pattern and "DISPLAY" != operation:
            raise Exception("pattern not provided")

        if -1 == start:
            raise Exception("start address not provided")

        if -1 == length:
            raise Exception("length not provided")

    except Exception as inst:
        print inst
        usage(sys.argv[0])
        sys.exit(1)

    f = os.open("/dev/mem", os.O_RDWR | os.O_SYNC)
    m = mmap.mmap(f, length, mmap.MAP_SHARED, mmap.PROT_WRITE | mmap.PROT_READ, offset=start)
    m.seek(0)

    if 'FILL' == operation:

        if 'ZEROES' == pattern:
            for i in xrange(0, length, 4):
                struct.pack_into('=L', m, i, 0)
        elif 'ONES' == pattern:
            for i in xrange(0, length, 4):
                struct.pack_into('=L', m, i, 0xffffffff)
        elif 'OFFSET' == pattern:
            for i in xrange(0, length, 4):
                struct.pack_into('=L', m, i, i/4)
        elif 'LITERAL' == pattern:
            for i in xrange(0, length, 4):
                struct.pack_into('=L', m, i, literal)

    elif 'VALIDATE' == operation:

        error_count = 0

        if 'ZEROES' == pattern:
            for i in xrange(0, length, 4):        
                contents = struct.unpack_from('=L', m, i)
                if contents[0] != 0:
                    error_count = error_count + 1
                    # print >> sys.stderr, '0x%08x [%08x] [%08x]'%(i+address_start,0,contents[0])

        if 'ONES' == pattern:
            for i in xrange(0, length, 4):        
                contents = struct.unpack_from('=L', m, i)
                if contents[0] != 0xffffffff:
                    error_count = error_count + 1
                    # print >> sys.stderr, '0x%08x [%08x] [%08x]'%(i+address_start,0,contents[0])

        elif 'OFFSET' == pattern:
            for i in xrange(0, length, 4):
                contents = struct.unpack_from('=L', m, i)
                if contents[0] != i/4:
                    error_count = error_count + 1
                    # print >> sys.stderr, '0x%08x [%08x] [%08x]'%(i+address_start,i,contents[0])

        elif 'LITERAL' == pattern:
            for i in xrange(0, length, 4):
                contents = struct.unpack_from('=L', m, i)
                if contents[0] != literal:
                    error_count = error_count + 1
                    # print >> sys.stderr, '0x%08x [%08x] [%08x]'%(i+address_start,i,contents[0])

        print error_count

    else:

        try:
            for i in xrange(0, length, 32):
                contents = struct.unpack_from('=LLLLLLLL', m, i)
                print '0x%08x:  0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x'%(i+start,contents[0],contents[1],contents[2],contents[3],contents[4],contents[5],contents[6],contents[7])

        except IOError, e:
            # Error 32 is broken pipe (which occurs, for example, after entering 'q' within 'less'
            if e.errno != 32: 
                print e.errno
                print e      


    m.close()
    os.close(f)


def usage(script_name):
    print "Usage: " + script_name + " [options] where options is combination of the following:"
    print "  -o, --operation=FILL:VALIDATE:DISPLAY" 
    print "                         operation to apply to block of memory"
    print "  -p, --pattern=ZEROES:ONES:OFFSET:{32-bit integer}"
    print "                         pattern to apply to block of memory if operation is"
    print "                         FILL or VALIDATE"
    print "  -s, --start=ADDRESS    starting address of memory block"
    print "  -l, --length=LENGTH    length of memory block on which to apply operation"  
    print "  -h, --help             display this help and exit"
    print ""

def is_integer(a_string):
    try: 
        x = int(a_string,0)
    except:
        return False;

    return True;

if __name__ == "__main__":
    main()
